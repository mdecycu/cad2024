var tipuesearch = {"pages": [{'title': 'About', 'text': 'Repo:  https://github.com/mdecycu/cad2024 \n Site:  https://mde.tw/cad2024 \n 課程目標: \n 學習如何利用\xa0CAD 套件與 Python 程式協助執行機電整合系統設計 \n Python 課程教材: \n Intro_to_Mechatronics.pdf  ( Source ) \n Programming with Python for Engineers \n USB 隨身碟: \n 下載  python_2025_lite.7z  (428 MB, 解開壓縮後約 1.5 GB) \n CAD 套件:  Solvespace \xa0and\xa0 Siemens NX \n 下載  NX2312 可攜 CAD 壓縮檔案 (1.85 GB, 解開後約 9 GB) \n 下載 \xa0NX2406 可攜 CAD 壓縮檔案 (1.76 GB, 解開後約 9 GB) \n 機電模擬:  CoppeliaSim \n 課程評分: \n 出席 (10%) - 自行舉證評分 \n Github Classroom 作業與隨堂考試 (60%) - 以 Github 帳號領取作業倉儲後, 建立包含操作流程影片與檔案下載的網頁 \n 期末口頭與書面專題報告 (30%) - 利用網頁內容進行簡報並提交 pdf 格式書面報告 \n \n 行事曆 \n  全頁檢視  \n \n', 'tags': '', 'url': 'About.html'}, {'title': 'Jupyter', 'text': "USB 隨身碟: \n 下載  python_2025_lite.7z  (428 MB, 解開壓縮後約 1.5 GB) \n 利用 Jupyter 建立 .ipynb 格式的 notebook 檔案: \n \n 以 start_ipv6.bat 開啟隨身碟中的可攜程式環境 \n 在命令列視窗中, 輸入 jupyter lab --collaborative 後可在瀏覽器中開啟 Jupyter lab \n 系統內定以執行 jupyter lab --collaborative 指令所在目錄作為根目錄 \n Jupyter lab 的伺服器 ip 設定位於 home_ipv6\\.jupyter\\jupyter_server_config.py 檔案中的 c.ServerApp.ip 變數, 內定為 localhost, 使用者可以自行修改為電腦連外 IPv4 或 IPv6 位址 \n home_ipv6\\.jupyter\\jupyter_server_config.py 檔案中的 c.ServerApp.port = 8888 為內定連線埠號 \n 系統內定使用 http 連線, 使用者可利用 openssl 建立 cert.pem 與 key.pem, 並與 c.ServerApp.certfile 及c.ServerApp.keyfile 等系統變數綁定後, 使用 https 連線 \n 若希望讓其他用戶透過網路進行協同編輯, 可從命令列視窗中, 輸入 jupyter server list 取得登入所需的 token, 或將設定修改為使用者自訂的密碼登入 \n 各 Jupyter lab 用戶可從左方的 Collaboration 頁面中檢視參與協同者的名單 \n 使用結束後, 以 File - Shutdown 關閉 Jupyterlab \n \n 利用 openssl 指令建立 cert.pem 與 key.pem: \n openssl req -newkey rsa:2048 -new -nodes -x509 -days 3650 -keyout key.pem -out cert.pem \n 使用 https 連線時, cert.pem 與 key.pem 設定: \n c.ServerApp.certfile = u'y:\\home_ipv6\\.jupyter\\cert.pem' \n c.ServerApp.keyfile = u'y:\\home_ipv6\\.jupyter\\key.pem' \n", 'tags': '', 'url': 'Jupyter.html'}, {'title': 'Mechatronics', 'text': '機電整合 (Mechatronics) 一詞將機械 (mecha) 和電子 (tronics) 結合在一起。意即在產品的設計與製造流程中，將機械工程、電子技術和智能計算機控制的相關技術加以結合。機電整合產品經常利用電子元件取代傳統的機械功能，從而 實現更大的靈活性、更簡單的重新設計與重新編程，並提升自動化數據收集與報告生成的能力 。 \n https://github.com/s40723210/cd2020/tree/master/downloads \xa0 \n 40723210_2020.7z \n https://github.com/s40723221/cd2020/tree/master/downloads \xa0 \n 機電整合未來發展與挑戰 \xa0( version 2 ) \n 40723221_2020.7z \n https://www.20sim.com/downloads/files/20sim.exe \n https://openmodelica.org/download/download-windows/ \n', 'tags': '', 'url': 'Mechatronics.html'}, {'title': 'Topics', 'text': "Topic 1: \xa0 基於瀏覽器的分散式版次管理與整合程式開發環境 (複習) \n USB 隨身碟: \n 下載  python_2025_lite.7z  (428 MB, 解開壓縮後約 1.5 GB) \n 下載  NX2312 可攜 CAD 壓縮檔案 (1.85 GB, 解開後約 9 GB) \n What are Github and Codespace? \n Hello World - GitHub Docs \n 利用包含學號的字串作為帳號, 申請免費使用 Github. \n Topic 2: \xa0 計算機程式課程作業與學員網頁 (複習) \n What is Github Classroom? \n GitHub Classroom \n Your repository and Web site \n Topic 3: 利用 CAD 套件建立零組件 ( 零件 ,  組立件 ) \n 利用  Solvespace  建立機械系統的零組件 \n Solvespace Tutorial \n 利用  Solvespace \xa0進行單一輸入的平面機構模擬 \n 利用  Siemens NX  建立機械系統的零組件 ( NX CAD Buyer's Guide ,\xa0 2024\xa0 Siemens 推出 NX X ,  Fact Sheet , Why?) \n “NX X enables our customers to move to a cloud-based, collaborative engineering environment. Our solution allows them to retain their intellectual property and continue their innovative work, without disruption; no need to reinvent their working practices,” said  Bob Haubrock , senior vice president, Product Engineering Software, Siemens Digital Industries Software. \n Homework 1 (10%): \n 利用 Solvespace 與 NX2312 建立  Parts  頁面中的零件 \n 其他 零件模擬練習 \n Homework 2 (10%): \n 利用 Solvespace 與 NX2312 建立  Balance on Wheels  組立件 \n Topic 4: 機電整合系統模擬與控制 \n 利用 \xa0 CoppeliaSim \xa0 建立機電模擬系統 \n 利用 \xa0 Python \xa0 跨網路控制瀏覽器上的機電模擬系統 \n Homework 3 (20%): \n 建立  Balance on Wheels  控制系統設計模擬場景 \n https://github.com/mdecycu/Balance_On_Wheels \n \n \n Balance_on_wheels_nx2312.7z \n Balance_on_Wheel_scene.7z \n Homework 4 (20%): \n 建立  Dingo 機器狗 控制系統設計模擬場景 \n https://github.com/mdecycu/DingoQuadruped \n DINGO_QUADRUPED_CAD.7z \n \n", 'tags': '', 'url': 'Topics.html'}, {'title': 'Topic 1', 'text': '主題:\xa0 基於瀏覽器的分散式版次管理與整合程式開發環境 (複習) \n 主題摘要: \n USB 隨身碟 (可配置在自己的電腦): \n 下載  python_2025_lite.7z  (428 MB, 解開壓縮後約 1.5 GB) \n 下載  NX2312 可攜 CAD 壓縮檔案 (1.85 GB, 解開後約 9 GB) \n 使用電腦教室中的電腦: \n 下載  python_2025_lite.7z  (428 MB, 解開壓縮後約 1.5 GB) \n 使用電腦所安裝的 NX2312 \n \n python_2025_lite.7z  與 可攜 NX2312 CAD  可以直接放在 USB 3.0 格式以上的 USB 隨身碟中, 並在任何 Windows 64 位元以上電腦中使用. \n 解開  python_2025_lite.7z  壓縮檔案後, 可將 可攜 NX2312 CAD  檔案放入 data 目錄中的 nx 子目錄中, 以 start_ipv6.bat 啟動可攜程式系統後, 若在 IPv4 環境, 可在命令提示字元視窗中執行: \n set SPLM_LICENSE_SERVER=29000@認證主機_IPv4_位址, 然後執行 ugraf -nx 開啟 NX2312 \n 若在 IPv6 環境, 可在命令提示字元視窗中執行: \n set SPLM_LICENSE_SERVER=29000@[認證主機_IPv6_位址], 然後執行 ugraf -nx 開啟 NX2312 \n 若要使用 Jupyterlab 協同執行環境, 可在命令提示字元視窗中執行: \n jupyter lab --collaborative \n 之後便可在瀏覽器中開啟 localhost 中的 jupyterlab 執行環境. \n 若要讓其他用戶透過瀏覽器連接至 jupyterlab 協同環境, 可修改 home_ipv6\\.jupyter\\jupyter_server_config.py 檔案中的 c.ServerApp.ip 變數, 改為電腦網路 IPv4 或 IPv6 位址後, 重新執行: \n jupyter lab --collaborative \n \n What are Github and Codespaces? \n Hello World - GitHub Docs \n 利用包含學號的字串作為帳號, 申請免費使用 Github. \n Demo: \n 在 stud.cycu (Linux) 伺服器安裝 Jupyter Notebook: \n pip3 install jupyter\nsudo apt install jupyter-notebook\n# 建立 ./jupyter/jupyter_notebook_config.py\njupyter notebook --generate-config\n# 設法修改 .jupyter/jupyter_notebook_config.py 中的 c.ServerApp.ip 與 c.ServerApp.port\n# 若使用 IPv6, 設定 c.ServerApp.ip = \'2001:288:6004:XX::1\'\n# 以 jupyter notebook list 取得登入 token, 並據以改變登入密碼\n# 啟動 jupyter notebook\njupyter-notebook\n \n 在 Windows 安裝 Jupyter Notebook: \n pip install jupyter\n# 建立 home_ipv4/.jupyter/jupyter_notebook_config.py\njupyter notebook --generate-config\n# 設法修改 .jupyter/jupyter_notebook_config.py 中的 c.ServerApp.ip 與 c.ServerApp.port\n# 若使用 IPv6, 設定 c.ServerApp.ip = \'2001:288:6004:XX::1\'\n# 以 jupyter server list 取得登入 token, 並據以改變登入密碼\n# 啟動 jupyter notebook\njupyter notebook \n 完成設定後, 多名系統設計者可以利用瀏覽器連接 Jupyter Notebook, 編寫 ZMQ Remote API Python 程式, 控制位於 CoppeliaSim server 上的機電系統, 並透過瀏覽器觀測控制結果. \n Jupyter server: \n pip install jupyter-server \n jupyter server --generate-config \n pip install jupyter-collaboration \n jupyter lab --collaborative \n 針對 cp2024.ipynb 進行  realtime 協同編輯 \n http://[2001:288:6004:xx::1]:8888/lab/workspaces/auto-v/tree/RTC%3Acp2024.ipynb \n https://colab.research.google.com/ \xa0 \n https://deepnote.com/pricing \xa0 \n https://jupyterhub.readthedocs.io \xa0 \n Use  Stunnel  to serve jupyter notebook or jupyter lab under https or just setup under  Jupyter : \n Use openssl.exe to generate self-signed key.pem and cert.pem: \n openssl req -newkey rsa:2048 -new -nodes -x509 -days 3650 -keyout key.pem -out cert.pem \n stunnel.conf: \n [https]\naccept = [2001:288:6004:XX::1]:443\nconnect = [2001:288:6004:XX::1]:8888\ncert = cert.pem\nkey = key.pem\nTIMEOUTclose = 0 \n 利用系統管理員身分執行批次檔案指令, 設定防火牆允許 TCP 封包對 CoppeliaSim zmq server 連線 (in 權限開啟 23000-23050): \n allow_23000-23050_tcp_in_firewall_setting.7z \n echo off\nREM netsh advfirewall firewall add rule name="RULENAME" dir=[in/out] action=[allow/block/bypass] protocol=[tcp/udp] localip=[any] remoteip=[any]\nREM allow tcp in for port 23000-23050\nnetsh advfirewall firewall add rule name="allow_23000-23050" dir=in action=allow protocol=TCP localport=23000-23050\nnetsh advfirewall firewall add rule name="allow_23000-23050" dir=out action=allow protocol=TCP localport=23000-23050 \n', 'tags': '', 'url': 'Topic 1.html'}, {'title': 'Topic 2', 'text': '主題: \xa0 計算機程式課程作業與學員網頁 (複習) \n What is Github Classroom? \n GitHub Classroom \n Your repository and Web site \n Demo: 指定 Github Classroom cad2024 上的個人專案作業倉儲 \n', 'tags': '', 'url': 'Topic 2.html'}, {'title': 'Topic 3', 'text': "主題: 利用 CAD 套件建立零組件 ( 零件 ,  組立件 ) \n 利用  Solvespace  建立機械系統的零組件 \n Solvespace Tutorial \n 利用  Solvespace \xa0進行單一輸入的平面機構模擬 \n 利用  Siemens NX  建立機械系統的零組件 ( NX CAD Buyer's Guide ,\xa0 2024\xa0 Siemens 推出 NX X ,  Fact Sheet , Why?) \n “NX X enables our customers to move to a cloud-based, collaborative engineering environment. Our solution allows them to retain their intellectual property and continue their innovative work, without disruption; no need to reinvent their working practices,” said  Bob Haubrock , senior vice president, Product Engineering Software, Siemens Digital Industries Software. \n Homework 1: \n 利用 Solvespace 與 NX2312 建立  Parts  頁面中的零件 \n 其他 零件模擬練習 \n Homework 2: \n 利用 Solvespace 與 NX2312 建立  Balance on Wheels  組立件 \n", 'tags': '', 'url': 'Topic 3.html'}, {'title': 'Topic 4', 'text': '主題: 機電整合系統模擬與控制 \n 利用 \xa0 CoppeliaSim \xa0 建立機電模擬系統 \n 利用 \xa0 Python \xa0 跨網路控制瀏覽器上的機電模擬系統 \n Homework 3: \n 建立  Balance on Wheels  控制系統設計模擬場景 \n https://github.com/mdecycu/Balance_On_Wheels \n \n \n Balance_on_wheels_nx2312.7z \n Balance_on_Wheel_scene.7z \n Balance_on_Wheel_w_GPS_sensor_ttt_lua.7z  (使用 GPS 感測器取出輪車移動時, 平台的特定點座標) \n Homework 4: \n 建立  Dingo 機器狗 控制系統設計模擬場景 \n https://github.com/mdecycu/DingoQuadruped \n DINGO_QUADRUPED_CAD.7z \n', 'tags': '', 'url': 'Topic 4.html'}, {'title': 'HW 3', 'text': '建立  Balance on Wheels  控制系統設計模擬場景 \n https://github.com/mdecycu/Balance_On_Wheels \n 上列倉儲中有兩個採 Solidworks 繪製的系統模型, 可以直接以 NX2312 開啟後存為 .prt 檔案. 只是各零組件並沒有詳細的零組件繪製流程. 學員可以自行利用 Solvespace 與 NX2312 建立相同尺寸的零組件. \n \n 以下為取自簡化過的  Balance_on_wheels_nx2312.7z  系統組立件, 從 NX2312 以 Export 功能轉為 .stl 後, 再轉入 CoppeliaSim, 過程中自行利用 Cuboid 建立上平台, 並增大厚度以便讓連桿可以直接接在兩側. \n 由於原始系統模型在部分軸接孔並沒有圓柱件可以讓 Revolute Joint 定位, 必須透過圓孔的 Shape Editor 設法建立. 且原始 Wheel 形狀較為複雜, 在 CoppeliaSim 建立運動模擬場景時, 必須設法簡化, 以下直接採用單一圓柱體作為輪子的動態模擬物件. \n 另外由於連接平台與輪軸的機構為封閉式, 在 CoppeliaSim 場景中進行組裝時, 必須透過兩個 Dummy 物件, 以 Dynamic, overlap constraint 的 Dummy Type 進行連接. 而且各連桿在 CoppeliaSim Shape Editor 後, 可能因碰撞檢測設定而產生的干涉, 可以利用  Respondable Mask  的設定避開. \n 最後, 因為此雙輪車的機構設計目的, 是希望透過輪軸上方致動器的運動控制, 讓輪車透過平台瞬間運動所產生的慣性上下跳躍運動. 但初步階段在雙輪車能夠穩定平衡控制之前, 除輪軸馬達外, 其餘連接軸上的馬達 Control Mode 設為 Position, 均施以 250 N.m 的扭力, 並令其 Target angle 為 0 度. \n 根據以上流程建立的 CoppeliaSim 系統場景畫面與檔案如下: \n \n Balance_on_Wheel_scene.7z \n 有關雙輪車平衡控制方法可以參考: \n invertedPendulum_ttt_for_4.7.0_rev4.7z \n Inverted Pendulum: System Modeling \n https://github.com/mdecycu/VREP-Coppeliasim-Linear-first-order-inverted-pendulum \n https://github.com/mdecycu/vrep_inverted_pendulum \n Project-Based Teaching in Control Theory Education Based on V-REP: A Cart Inverted Pendulum Case \n Balance Control of an Inverted Pendulum on a Quadruped Robot by Reinforcement Learning \n Control strategies for inverted pendulum: A comparative analysis of linear, nonlinear, and artificial intelligence approaches \n Design of nonlinear controller for bi-axial inverted pendulum system \n \n', 'tags': '', 'url': 'HW 3.html'}, {'title': 'References', 'text': 'What do I do as a mechanical design engineer? \n Overview of mechanical design engineering \n What does a mechanical design engineer do? \n Guide to mechanical design engineering course \n References \xa0 \n CAD: \n 2010\xa0THE FUTURE AND THE EVOLUTION OF CAD \n cadbook.pdf  (from cadp2018 course) \n cad_history.pdf   (from cadp2018 course) \n NX-12-for-Engineering-Design.pdf  (from\xa0 https://me5763.github.io/lab/assets/books/NX-12-for-Engineering-Design.pdf ) \n Git: \n Git for Electronic Circuit Design - CAD and Version Control for Electrical Engineers.pdf \xa0(from\xa0 Springer ) \n ODOO: \n https://github.com/odoo/odoo \xa0 \n https://mde.tw/pj4101 \xa0 \n', 'tags': '', 'url': 'References.html'}, {'title': 'Parts', 'text': 'https://support.industrysoftware.automation.siemens.com/training/se/en/ST3/pdf/spse01550.pdf \xa0 \n \n \n cad2024_part_ex1_solvespace.7z \n Solvespace 零件繪圖: \n Sketch Rectangle (R) \n Tangle Arc at Point (Shift + A) \n Sketch Circle (C) \n Constraint distance / diameter / length (D) \n New group extruding active sketch (X) \n Sketch line segment (S) \n Sketch In Workplane (2) \n Toggle construction (G) \n Sketch in new workplane (Shift + W) - one point and specific orientation, origin and two lines \n NX 零件繪圖: \n Shift + mouse middle button pressed and move = Pane \n Ctrl + f key = Fit \n Sketch \n Rectangle From Center \n Fillet \n Circle \n Line \n Arc \n Center mouse click = Finish \n Include - Includes and projects external objects into the sketch \n Dimension - Display as PMI \n Datum Plane \n Two Lines \n Extrude \n Width - Value, Symmetric Value \n \n cad2024_part_ex1_nx2312.7z \n cad2024_part_ex1_nx1872.7z \n \n \n', 'tags': '', 'url': 'Parts.html'}, {'title': 'BonW', 'text': 'Balance on Wheels \n https://github.com/mdecycu/Balance_On_Wheels \n \n 專案第一階段執行過程: \n \n 利用 Solvespace 建立零組件 \n 將零組件轉入 CoppeliaSim \n 根據系統零組件從屬關係進行零件組立 \n 針對系統動態運動模型運算簡化零件 \n 進行初步開放系統的運動模擬 \n 加入所需致動器與感測器 \n 針對系統運動設定零件起始位置與機構運動範圍 \n 利用 ZMQ Remote API 程式進行回授控制系統設計 \n \n 專案第二階段執行過程: \n \n 利用 NX2312 建立零組件 \n 將零組件轉入 CoppeliaSim \n 根據系統零組件從屬關係進行零件組立 \n 針對系統動態運動模型運算簡化零件 \n 進行初步開放系統的運動模擬 \n 加入所需致動器與感測器 \n 針對系統運動設定零件起始位置與機構運動範圍 \n 利用 ZMQ Remote API 程式進行回授控制系統設計 \n \n 專案第三階段執行過程: \n \n 利用 NXOpen 評估能否採二次程式開發流程建立系統零組件 \n 利用 CoppeliaSim 的 Simple XML 模型檔案格式, 評估能否直接利用 NX2312 轉出的零件 STL 檔案建立模擬場景 \n 結合 Jupyterlab 的 collaborative 模式 (或 Linux 上的 Jupyterhub server), 評估將潛在客戶導入協同產品設計的可行性 \n \n \n \n', 'tags': '', 'url': 'BonW.html'}, {'title': 'Quadruped', 'text': 'pj40922_downloads.7z \n \n \n \n Actuator module: \n \n \n quadruped_8dof_v2_sw_nx.7z \xa0(built with Solidworks and open\xa0under NX2312) ( File source ,  site ) \n 2020 An Open Torque-Controlled Modular Robot Architecture for Legged Locomotion Research \xa0( Journal ) \n 2024 Learning-based legged locomotion state of the art and future perspectives \n 2024 Planar Motion Control of a Quadruped Robot \xa0( Github ) \n https://github.com/mdecycu/quadruped \xa0 \n https://github.com/mdecycu/Eklavya-QuadrupedMotionSimulation \xa0 \n https://github.com/mdecycu/jelly_mechanical \n \n https://pupper-independent-study.readthedocs.io/en/latest/ \n \n https://github.com/dagor-dev \n https://github.com/mdecycu/DingoQuadruped \n DINGO_QUADRUPED_CAD.7z \n \n \n', 'tags': '', 'url': 'Quadruped.html'}, {'title': 'Rover', 'text': 'https://github.com/Roger-random/Sawppy_Rover \xa0( in Onshape ) \n \n 40723221_2019_rover.7z \n 40723221_2019_curiosity.7z \n 1996  Rocky_Mars_Rover_Prototyp.pdf \xa0( Source ) \n https://science.nasa.gov/mars/ \xa0 \n https://science.nasa.gov/mission/msl-curiosity/ \xa0 \n Curiosity mars rover 3D model \n Design and terramechanics analysis of a Mars rover utilising active suspension \n 2004_Design_of_a_Mars_Rover_Suspension_Mechanism.pdf \n \n', 'tags': '', 'url': 'Rover.html'}, {'title': 'meArm', 'text': 'Foundation of Robotics  (Course document) \n Elements of Robotics  (Open ebook) \n uArm_manipulator_en.pdf  ( uArm_manipulator_es.pdf ) \n \n \n Forward Kinematics and Inverse Kinematics of uArm robot: \n Inverse Kinematics: \n 利用  sympy  根據  meArm Pi Technical Overview  中的說明 (修正錯誤後), 解出 Inverse Kinematics 如下: \n 當已知 manimpulator 端點的座標為 (x, y ,z) 時, 求 theta, ltheta (low arm link theta) 與 utheta (upper arm link theta). 利用  sympy  之前必須先以 pip install sympy 安裝模組. \n import sympy as sp\n   \n# Define symbols\ntheta, ltheta, utheta, r, x, y, z = sp.symbols("theta ltheta utheta r x y z")\n   \n# Define equations, rearranged so expressions equal 0\neq1 = 15 + 50 + 80*sp.sin(ltheta) + 80*sp.sin(utheta) - r\neq2 = 53 + 80*sp.cos(ltheta) - 80*sp.cos(utheta) - z\n# 從 eq3 與 eq4 可以得到 eq5 與 eq6, 將 r 及 theta 表示成 x, y 輸入的函式\n# 因此 r 與 theta 在得知 x, y, z 時就可視為已知\neq3 = r*sp.cos(theta) - x\neq4 = r*sp.sin(theta) - y\neq5 = sp.sqrt(x*x + y*y) - r\neq6 = sp.atan(y/x) - theta\n   \n# Solve for theta1 & theta3\nsolution = sp.solve([eq1, eq2], [ltheta, utheta], dict=True)\nprint(solution)\n   \n\'\'\'\n[{ltheta: pi - asin(r/80 + sin(2*atan((-160*r + sqrt(-r**4 + 260*r**3 - 2*r**2*z**2 + 212*r**2*z - 5368*r**2 + 260*r*z**2 - 27560*r*z - 1499160*r - z**4 + 212*z**3 + 296*z**2 - 1222392*z + 130593244) + 10400)/(r**2 - 130*r + z**2 - 266*z + 15514))) - 13/16), \n   \nutheta: -2*atan((-160*r + sqrt(-r**4 + 260*r**3 - 2*r**2*z**2 + 212*r**2*z - 5368*r**2 + 260*r*z**2 - 27560*r*z - 1499160*r - z**4 + 212*z**3 + 296*z**2 - 1222392*z + 130593244) + 10400)/(r**2 - 130*r + z**2 - 266*z + 15514))}, \n   \n{ltheta: asin(-r/80 + sin(2*atan((160*r + sqrt(-r**4 + 260*r**3 - 2*r**2*z**2 + 212*r**2*z - 5368*r**2 + 260*r*z**2 - 27560*r*z - 1499160*r - z**4 + 212*z**3 + 296*z**2 - 1222392*z + 130593244) - 10400)/(r**2 - 130*r + z**2 - 266*z + 15514))) + 13/16) + pi, \n   \nutheta: 2*atan((160*r + sqrt(-r**4 + 260*r**3 - 2*r**2*z**2 + 212*r**2*z - 5368*r**2 + 260*r*z**2 - 27560*r*z - 1499160*r - z**4 + 212*z**3 + 296*z**2 - 1222392*z + 130593244) - 10400)/(r**2 - 130*r + z**2 - 266*z + 15514))}, \n   \n{ltheta: -asin(-r/80 + sin(2*atan((160*r + sqrt(-r**4 + 260*r**3 - 2*r**2*z**2 + 212*r**2*z - 5368*r**2 + 260*r*z**2 - 27560*r*z - 1499160*r - z**4 + 212*z**3 + 296*z**2 - 1222392*z + 130593244) - 10400)/(r**2 - 130*r + z**2 - 266*z + 15514))) + 13/16), \n   \nutheta: 2*atan((160*r + sqrt(-r**4 + 260*r**3 - 2*r**2*z**2 + 212*r**2*z - 5368*r**2 + 260*r*z**2 - 27560*r*z - 1499160*r - z**4 + 212*z**3 + 296*z**2 - 1222392*z + 130593244) - 10400)/(r**2 - 130*r + z**2 - 266*z + 15514))}, \n   \n{ltheta: asin(r/80 + sin(2*atan((-160*r + sqrt(-r**4 + 260*r**3 - 2*r**2*z**2 + 212*r**2*z - 5368*r**2 + 260*r*z**2 - 27560*r*z - 1499160*r - z**4 + 212*z**3 + 296*z**2 - 1222392*z + 130593244) + 10400)/(r**2 - 130*r + z**2 - 266*z + 15514))) - 13/16), \n   \nutheta: -2*atan((-160*r + sqrt(-r**4 + 260*r**3 - 2*r**2*z**2 + 212*r**2*z - 5368*r**2 + 260*r*z**2 - 27560*r*z - 1499160*r - z**4 + 212*z**3 + 296*z**2 - 1222392*z + 130593244) + 10400)/(r**2 - 130*r + z**2 - 266*z + 15514))}] \n \n', 'tags': '', 'url': 'meArm.html'}, {'title': 'Codespaces', 'text': '利用 Codespaces 維護課程網站的步驟: \n \n chmod u+x init_replit \n ./init_replit \n python3 main.py \n 以瀏覽器開啟動態網站進行網站內容編輯 \n 動態網頁內容編輯告一段落後, 利用 Convert 功能將動態內容轉為靜態網站資料 \n 最後利用 Shell, 以  ./acp "輸入提交註記說明字串"  完成 git add, git commit -m 與 git push, 將動態與靜態網站內容送到對應的倉儲中 \n \n main.py: \n from cmsimde import flaskapp\nfrom gevent.pywsgi import WSGIServer\n\n#flaskapp.app.run(host="0.0.0.0", debug=True)\nhttp_server = WSGIServer((\'0.0.0.0\', 8080), flaskapp.app)\nhttp_server.serve_forever() \n main2.py: \n # Run static server\nimport static\nfrom gevent.pywsgi import WSGIServer\n\nhttp_server = WSGIServer((\'0.0.0.0\', 8081), static.app)\nhttp_server.serve_forever() \n 以及與 main2.py 結合使用的 static.py: \n from flask import Flask, send_from_directory\n\napp = Flask(__name__)\n\n# Route to serve the index.html file\n@app.route(\'/\')\ndef index():\n    return send_from_directory(\'.\', \'index.html\')\n\n# Route to serve static files from the ./cmsimde/static directory\n@app.route(\'/cmsimde/static/<path:filename>\')\ndef serve_static(filename):\n    return send_from_directory(\'cmsimde/static\', filename)\n\n# Route to serve other HTML files from the root directory\n@app.route(\'/<path:filename>\')\ndef serve_html(filename):\n    return send_from_directory(\'.\', filename)\n\nif __name__ == \'__main__\':\n    app.run(debug=True)\n \n \n', 'tags': '', 'url': 'Codespaces.html'}, {'title': 'CAD', 'text': 'Engineers Edge:  https://www.engineersedge.com/ \n Computer Aided Design: \n https://en.wikipedia.org/wiki/Polygon_mesh \n https://en.wikipedia.org/wiki/Constructive_solid_geometry \n https://fr.wikipedia.org/wiki/B-Rep \n 2015 Space Modeling with SolidWorks and NX \n Pymadcad (執行的電腦需要配置獨立顯卡): \n https://madcad.netlify.app/ \n https://pymadcad.readthedocs.io/en/latest/reference/index.html \n https://github.com/jimy-byerley/pymadcad  ( https://github.com/mdecycu/pymadcad ) \n Modification:  Render Text  using UTF-8 encoding \n https://pymadcad.readthedocs.io/en/latest/algorithms/gearprofile.html \n https://github.com/jimy-byerley/uimadcad  ( https://github.com/mdecycu/uimadcad ) \n .ply io.read and io.write -  https://github.com/dranjan/python-plyfile  ( https://github.com/mdecycu/python-plyfile ) \n .stl io.read and io.write -  https://github.com/WoLpH/numpy-stl  ( https://github.com/mdecycu/numpy-stl ) \n .obj io.read and io.write -  https://github.com/pywavefront/PyWavefront  ( https://github.com/mdecycu/PyWavefront ) \n 系統先安裝  https://visualstudio.microsoft.com/zh-hant/visual-cpp-build-tools/ \n 重新開機後, 啟動可攜程式系統, 利用 pip install pymadcad numpy numpy-stl plyfile pywavefront uimadcad \n git clone  https://github.com/mdecycu/pymadcad.git \n 利用可攜系統中的 SciTE 開啟 examples 目錄中的 axis-holder.py 修改 write() 如下後, 利用 Tools - Go 執行. \n 啟動 uimadcad: python -m uimadcad \n from madcad import *\n\n# define a base of vectors: origin and directions\nO = vec3(0,0,0)\nX = vec3(1,0,0)\nY = vec3(0,1,0)\nZ = vec3(0,0,1)\n\n# part parameters\ndint = 20\ndext = 100\nh = 30\nrvis = dext/3\ndvis = 3\nhvis = 3\n\n\n# create the revolution profile, called \'cone\'\n# --------------------------------------------\n\nB = vec3(dint/2, 0, 0)\nS = vec3(dint/2, 0, h)\nE = vec3(dext/2, 0, 0)\nEh = E+2*Z\nSe = S+5*X\n# sketch a profile\nline = [\n\tSegment(B,S),\n\tArcCentered(((Se+S)/2, Y), S, Se),\n\tSegment(Se, Eh),\n\tSegment(Eh, E),\n\tSegment(E, B),\n\t]\n# mutate the profile to fit some geometrical constraints\nsolve([\n\t\tTangent(line[0], line[1], S),\n\t\tTangent(line[1], line[2], Se),\n\t\tRadius(line[1], 5),\n\t\tDistance(E, Eh, 10),\n\t\tOnPlane((O,Y), [B,S,E,Eh,Se]),\n\t\t],\n\tfixed=[O,X,Y,Z,B,S,E],\n\tprecision=1e-12\n\t)\n# generate the cone\ncone = revolution(\n\t\t\tradians(360), \n\t\t\t(O,Z), \n\t\t\tweb(line))\n# merge the start and end sections of the revolution (because its a 360° revolution)\ncone.mergeclose()\n# chamfer the lower edge: this is a chamfer over a circular edge\nchamfer(cone, cone.frontiers((0,4)), (\'depth\', 3))\n\n\n\n# create the slots for screws\n# ---------------------------\n# we remove a partially defined volume\n\nrplace = dvis*3+2\nC = vec3(rvis,0,hvis)\nA = vec3(rvis, rplace,hvis)\nB = vec3(rvis,-rplace,hvis)\nAe = A+vec3(dext/2, 60,0)\nBe = B+vec3(dext/2,-60,0)\n# sketch its line\nline = [\n\tSegment(Ae, A),\n\tArcCentered((C,Z), A, B),\n\tSegment(B, Be),\n\t]\nsolve([\n\t\tTangent(line[0], line[1], A),\n\t\tTangent(line[2], line[1], B),\n\t\tRadius(line[1], 3*dvis),\n\t\tDistance(Ae, O, dext),\n\t\tDistance(Be, O, dext),\n\t\tAngle(Segment(Ae,A), Segment(Be,B), radians(60)),\n\t\tOnPlane((C,Z), [A,B,Ae,Be]),\n\t\t],\n\tfixed=[O,X,Y,Z,C],\n\tprecision=1e-12,\n\t)\n# extrude that base line and add a bottom face\nplace = (\textrusion(vec3(0,0,h), line) \n\t\t+\tflatsurface(wire(line).flip())\n\t\t)\n# merge outlines of both generated faces\nplace.mergeclose()\n# round the cutting edge to have smooth transition\nbevel(\n\tplace, \t\n\t(   place.frontiers(0,3) \t# this is the frontier line between group 0 and group 3\n\t  + place.frontiers(1,3) \t# this is the frontier line between group 1 and group 3\n\t  + place.frontiers(2,3) ), \n\t(\'depth\', 2))\n\n# make the screw holes:\n# a cylinder (not necessarily closed on its ends as we don\'t care of that surfaces)\nvis = extrusion(vec3(0,0,-2*h), web(Circle((C+vec3(0,0,h),-Z), dvis)))\n\n\n# assemble everything\n# -------------------\n# get 6 shapes with the slot and the hole for the scren\nbig = repeat(\n\t\tunion(place, vis), \t# this union cuts the slot to add the hole\n\t\t6, rotatearound(radians(60), (O,Z)))\n# cut the cone to put the slots and holes\npart = difference(cone, big)\n# this is the final touch for parts: optimize the buffers and check mesh validity\npart.finish()\n\n\n\n\n# if we want we can at any moment place some fancy notes\nnotes = [\n\tnote_leading(part.group(2), text="conic surface"),\n\tnote_leading(part.group(11), vec3(-5,0,-10), text=\'ø\'+str(dvis)),\n\t]\n\n# write the part to a ply file\n#write(part, \'tests/axis-holder.ply\')\nwith open(\'tests/axis-holder.ply\', \'w\') as f:\n    f.write(str(part))\n\n# display what we want\nshow([part, notes])\n \n pymatcad solid read and write to stl, obj and ply: \n from madcad import *\ns = screw(10, 20) # s is a `Solid`\n# Write\nio.write(s["part"], "screw.stl")\n# Read\nread_mesh = io.read("screw.stl")\nread_mesh.mergeclose()\nshow([read_mesh]) \n Solvespace \n SolveSpace 所提供的主要功能: \n 1. 2D 草圖設計:  - 繪製基本 2D 形狀(線、矩形、圓等)  - 添加約束(長度、距離、角度等)  - 完全參數化設計 \n 2. 3D 實體建模:  - 通過擠出、旋轉等方式從 2D 草圖生成 3D 實體  - 支持 3D 實體的布林運算(並集、差集、交集)  - 提供渲染和陰影視覺效果 \n 3. 參數化和約束求解:  - 可添加各種幾何和代數約束  - 支持尺寸驅動設計  - 自動求解過約束或過約定系統 \n 4. 分析工具:  - 質量屬性分析(體積、表面積、質心等)  - 公差分析  - 運動學模擬(僅限簡單機構) \n 5. 輔助建模工具:  - 添加工程參考幾何(平面、軸線等)  - 支持配置不同的草圖視圖和投影視圖 \n 6. 開發者擴展性:  - 開源代碼,支持定製化擴展  - 可通過 C++、Python 等語言擴充功能 \n 7. 操作界面:  - 傳統的圖形用戶界面  - 支持鍵盤快捷鍵和命令行輸入 \n 8. 導入導出格式:  - 支持導入/導出 STEP、STL、DXF 等 CAD 文件格式  - 可嵌入網頁或其他應用程序 \n Onshape \n Onshape 是一款基於雲端的3D CAD軟體,它提供了許多功能來協助設計和工程工作。Onshape 作為全功能的雲端CAD工具,提供了建模、協作、分析、數據管理等全面的功能,適合用於產品設計、工程項目等領域。 \n 以下是 Onshape 提供的主要功能: \n 1. 全功能3D參數式建模工具: \n - 實體和曲面建模  - 參數化和約束幾何體  - 自動生成製造製圖  - 直覺式草圖工具 \n 2. 直接編輯功能: \n - 不需要返回設計樹狀結構  - 可以直接編輯和修改現有幾何體 \n 3. 版本控制和分支: \n - 類似 Git 的版本控制系統  - 可以創建分支和合併分支  - 方便協作和跟踪修改歷史 \n 4. 數據管理和整合: \n - 整合PDM/PLM系統  - 材料庫和標準件庫  - Onshape App Store 提供各種插件 \n 5. 實時協作和評註: \n - 多人同時編輯同一個文件  - 添加評註和討論設計細節 \n 6. 模擬和分析工具: \n - 有限元分析(FEA)  - 運動學模擬  - 碰撞檢測 \n 7. 雲端計算和存儲: \n - 無需安裝軟體  - 所有設計都存儲在雲端  - 可隨時隨地訪問 \n 8. 開放API和集成: \n - 可與其他軟體系統集成  - 提供API進行自動化和定製 \n', 'tags': '', 'url': 'CAD.html'}, {'title': 'NX', 'text': 'NX Tutorial \n 西門子NX的發展歷程可以追溯至 1969 年, 當時麥道公司成立了自動化部門 McAuto, 開始發展內部 CAD/CAM系統CADD。CADD 最初運行於 IBM 360/40 電腦上,並使用 IBM 2250 圖形顯示終端機。 \n 1976年, McAuto 收購了 United Computing, 獲得該公司開發的互動式 CAD 系統 Unigraphics。Unigraphics 最初運行於通用自動化 SPC-16 小型機上, 並使用 Tektronix 顯示終端機。 \n 1982年, McAuto 開始開發新一代 Unigraphics II, 目標是打造更強大的三維設計、繪圖和 NC 加工系統。Unigraphics II 1.0 版於 1983 年發布,首次支援圖形著色。 \n 1985年, 麥道公司將 McAuto 重組為 McDonnell Douglas Information Systems Company, Unigraphics 歸入其中。 \n 1988年, 麥道公司收購 Shape Data, 獲得其開發的 Parasolid 幾何造型核心。 \n 1989年, Unigraphics 7.0 版發布, 首次支援 Parasolid 造型核心。 \n 1991年, 電子資料系統公司收購 MISCO, Unigraphics 成為 EDS 的一部門, 更名為 EDS Unigraphics。 \n 1992年, Unigraphics 10.0 版發布, 強調參數化設計和三維造型。 \n 1996年, Unigraphics 12.0 版發布, 首次支援 Windows NT 平台, 並加入 UG Scenario 分析軟體。 \n 1997年, Unigraphics 13.0 版發布, 引入 WAVE 技術, 提高設計效率。 \n 1998年, EDS 成立 Unigraphics Solutions, 完成對 Intergraph 機械部門的收購, 合併 Solid Edge 產品線。 \n 1999年, UGS 發布 Unigraphics 16.0 版, 強調基於網路的協同設計。 \n 2000年, EDS 將 UGS 拆分為獨立公司並上市。UGS 發布 Unigraphics 17.0 版, 首次支援 JT 數據交換格式。 \n 2001年, EDS 收購 SDRC, UGS 成為 EDS PLM Solutions 的一部分, 更名為 EDS PLM Solutions。 \n 2002年, UGS PLM Solutions 發布 NX 1.0 版, 旨在整合 Unigraphics 和 I-DEAS。 \n 2003年, UGS PLM Solutions 發布 NX 2.0 版, 改進使用者介面和知識庫設計。 \n 2004年, UGS 被 Bain Capital、Silver Lake Partners 和 Warburg Pincus 等三家私募股權公司收購,更名為 UGS Corporation。同年發布 NX 3.0 版, 實現 Unigraphics 和 I-DEAS 的整合。 \n 2007年, 西門子公司收購 UGS Corporation, 更名為 Siemens PLM Software, NX 成為其旗艦產品。同年發布NX 5.0 版, 進一步最佳化使用者介面和模型編輯功能。 \n 2007年之後的版本請參考:\xa0 https://en.wikipedia.org/wiki/Siemens_NX \xa0 \n https://github.com/mdecycu/nxlab \xa0 \n https://github.com/me5763 \xa0 \n \n NX2312 需要 Windows 操作系統帶有\xa0Windows Desktop Runtime 6.0.16. \n NX2312 client 連線到認證主機設定採 29000 時, client 端需要讓防火牆可以對 29000 與 29001 port 連外, 至於 server 端則需要讓防火牆可以對 29000 與 29001 port 連入. \n NX2312 與 NX2406 已經不再使用 VENDOR ugslmg 執行認證, 也就是不再需要 ugslmg.exe, 而是採用 Siemens Advanced Licensing Technology Daemon ( SALTD ), 並且透過 Mentor Standard Licensing (MSL) - (mgcld) utility 進行使用授權認證, license file 設定更動如下: \n SERVER 伺服器名稱 COMPOSITE=對應的編碼 29000\nVENDOR saltd saltd PORT=29001 \n 完整的 NX2312 總共有超過 11 萬個檔案, 總容量超過 33 GB. \n 開啟 NX - NX2312\\NXBIN\\ugraf.exe -nx \n 開啟 NX 2D Edit - NX2312\\NXBIN\\nx2dedit.exe \n 開啟 NX Layout - NX2312\\NXBIN\\ugraf.exe -layout \n 開啟 NX Viewer - NX2312\\NXBIN\\ugraf.exe -view \n 開啟 Simcenter 3D - NX2312\\NXBIN\\simcenter3d.exe \n 開啟 Sincenter 3D Results ㄒiewer - NX2312\\NXBIN\\simcenter3d.exe -simviewer \n 開啟 Simens Mechatronics Concept Designer - NX2312\\NXBIN\\ugraf.exe -mechatronics \n 開啟 NX Manufacturing - NX CAM - NX2312\\NXBIN\\ugraf.exe -nxcam \n NX3 Help Library  (for internal IPv6 users only) \n NX2312 DOC  (英文) \n MenuScript \n NX2312 DOC  (中文) \n 草圖  (Sketch) \n 建模  (Modeling) \n 創意塑型  (Realize Shape) \n 組立  (Assembly) \n 效能預測器  (Performance Predictor) \n Design Simulation \n Simcenter 3D  ( Simulation with NX / Simcenter 3D  or  local download ) \n', 'tags': '', 'url': 'NX.html'}, {'title': 'Ebooks', 'text': "Mechanical Design  or  local download \n Mechanical Design Engineering Handbook  or  local download \n Mechanical Engineer's Handbook  or  local download \n Product Design Modeling using CAD/CAE  or  local download \n Advanced Engineering Dynamics  or  local download \n Advanced Vehicle Technology  or  local download \n Vehicle Collision Dynamics  or  local download \n Linear Feedback Controls  or  local download \n Mechatronics  or  local download \n Sensors for Mechatronics  or  local download \n Analog Circuits Design  or  local download \n Op Amps for Everyone  or  local download \n NX CAD Tutorial \n NX Surface Tutorial \n", 'tags': '', 'url': 'Ebooks.html'}, {'title': 'NX3', 'text': "下載 \xa0NX3 可攜 CAD/CAE 壓縮檔案 (196 MB, 解開壓縮後約 761 MB) \n NX3 尚無 NXOpen Python 延伸程式開發架構, 僅能以 Visual Basic、C 或 C++ 執行開發. \n NX3 Help Library \xa0(for internal IPv6 users only) \n UGOpen C 程式架構請參考 \xa0 UG_Open-API_Programming.pdf \n UGOpen 技術文件請參考: \n Open C Programmer's Guide \xa0 (for internal IPv6 users only) \n Open C Reference Manual \xa0 (for internal IPv6 users only) \n", 'tags': '', 'url': 'NX3.html'}, {'title': 'NX12', 'text': 'File - Utilities - Customer Defaults - General - Miscellaneous \n Product Excellence Program -\xa0 turn off the Participate and Display initial Message \n \n NX12 NXOpen Python 動態連結程式庫採用 Python\xa03.6.5 版本編譯. \n 下載  NX12_CAD_portable.7z (947 MB, 解開壓縮後約 4.7 GB) \n', 'tags': '', 'url': 'NX12.html'}, {'title': 'NX1872', 'text': '可攜 NX1872 製作: \n nx1872_from_installed_to_portable_batch_setup.7z  中的檔案可以說明如何將 NX1872 安裝版轉為可攜啟動的設定過程. 從安裝版啟動後的 Menu - Help - Log File 可以取得系統系統過程的所有細節, 其中包括各對應 .bat 執行過程所設定的環境變數, 以及所啟動的 .dll 檔案. \n 上列 .7z 檔案即包括從此 Log File 中的環境變數註記, 經過 Python 程式轉為 .bat 設定外, 還利用 %cd% 取代原先安裝版本的 C:\\NX1872, 並且以 %USERNAME% 取代安裝時的使用者 pj2022, 之後只要再納入 NX1872 的認證伺服器與所購買的 bundles, 就可以將安裝版 NX1872 轉為可存入 USB 隨身碟的可攜版本. \n NX1872 NXOpen Python 動態連結程式庫採用 Python \xa03.7.1 版本編譯 . \n 下載  NX1872_CAD_portable.7z \xa0(1151 MB, 解開壓縮後約 5.2 GB) \n To edit the settings of the active sketch, use Settings in the Edit menu: 例如要關閉 Continuous Auto Dimensioning 則需在 Sketch 編輯中的 Settings 中進行設定. \n', 'tags': '', 'url': 'NX1872.html'}, {'title': 'NX1980', 'text': 'NX1980 NXOpen Python 動態連結程式庫採用 Python\xa03.8.8 版本編譯. \n 下載 可攜 NX1980 CAD 壓縮檔案 (解開壓縮後約 6457 MB) \n', 'tags': '', 'url': 'NX1980.html'}, {'title': 'NX2008', 'text': 'NX2008 NXOpen Python 動態連結程式庫採用 Python\xa03.8.12 版本編譯. \n 下載 可攜 NX2008 CAD 壓縮檔案 (1410 MB, 解開壓縮後約 6457 MB) \n', 'tags': '', 'url': 'NX2008.html'}, {'title': 'NX2312', 'text': 'NX2312 NXOpen Python 動態連結程式庫採用 Python \xa03.10.12 版本編譯 . \n 下載 \xa0NX2312 可攜 CAD 壓縮檔案 (1.85 GB, 解開後約 9 GB) \n NX2312 安裝後, 透過 Local_Machine - Software - Siemens 登錄檔案儲存下列資料, 其中包括認證主機的埠號與 IP: \n Windows Registry Editor Version 5.00\n\n[HKEY_LOCAL_MACHINE\\SOFTWARE\\Siemens]\n\n[HKEY_LOCAL_MACHINE\\SOFTWARE\\Siemens\\Installed Products]\n"NX 2312"="[{\\"ProductCode\\":\\"{BC25F476-AA6E-41ED-BBA3-F7CA7DE8EB92}\\",\\"ChannelType\\":\\"Main\\"}]"\n\n[HKEY_LOCAL_MACHINE\\SOFTWARE\\Siemens\\NX 2312]\n@="D:\\\\NX2312\\\\"\n"NXOPEN_EXTENSIONS"=""\n"NXOPEN_INSTALL"="YES"\n"INSTALLDIR"="D:\\\\NX2312\\\\"\n"LANGUAGE"="english"\n"LICENSESERVER"="29000@your_license_server"\n"UGII_BASE_DIR"="D:\\\\NX2312" \n \n 透過  get_dir_size.py  可以取得 Siemens NX 各子目錄與總容量. \n 各目錄的功能: \n AUTOMATION_DESIGNER: 自動化設計工具, 用於創建和管理自動化系統。\nCAPITALINTEGRATION: 與 Siemens Capital 軟件集成,用於電氣系統設計。\nCATIAV5: CATIA V5 文件的轉換器和介面。\nCMM_INSPECTION: 座標測量機(CMM)檢測功能。\nDESIGN_TOOLS: 各種輔助設計工具和功能。\nDIAGRAMCORE: 圖表和示意圖的核心功能。\nDIAGRAMMING: 用於創建各種工程和系統圖表。\nDRAFTING: 2D製圖和文檔創建工具。\nIGES: 初始圖形交換規範(IGES)文件的導入/導出。\nINSTALL: 安裝相關文件和腳本。\nLOCALIZATION: 多語言支持和本地化文件。\nMACH: 工具機加工和 CNC 編程功能。\nMANUFACTURING_PLANNING: 製造規劃和工藝設計工具。\nMECH: 機械設計和工程功能。\nMECHATRONICS: 機電整合設計工具。\nMOLDWIZARD: 模具設計和分析工具。\nMPA: 運動模擬和分析功能。\nNXASSEMBLY: 零件裝配和管理工具。\nNXBIN: NX 的核心檔案和執行檔。\nNXCAE_EXTRAS: 額外的電腦輔助工程(CAE)工具和功能。\nNXHUMAN: 人體工程學和人因工程設計工具。\nNXJOIN: 零件連接和焊接功能。\nNXNASTRAN: 有限元素分析(FEA)求解器。\nNXPARTS: 零件設計和模擬工具。\nNXPLOT: 繪圖和可視化工具。\nNXPROE: Pro/ENGINEER 文件的轉換器和介面。\nNXREPORTS: 報告生成和管理工具。\nNXSHIP: 船舶設計專用工具。\nPOSTBUILD: 後處理和結果分析工具。\nPSTUDIO: 產品工作室, 用於產品設計和管理。\nPVTRANS: 產品視覺化轉換工具。\nREL_INFO: 發布資訊和檔案。\nSIMULATION: 各種模擬和分析工具。\nSTAMPING_TOOLS: 沖壓工具設計功能。\nSTEP203UG 和 STEP214UG: STEP 文件格式的導入/導出。\nTDP: Technical Data Package 創建和管理工具。\nTemp 和 temp_module: 臨時文件存儲目錄。\nTOOLING_BASE: 工具設計的基礎功能。\nTRANSLATORS: 各種文件格式轉換器。\nUGALLIANCE: 與其他 CAD 系統的集成工具。\nUGAUTOMOTIVE: 汽車行業專用設計工具。\nUGCATIA: CATIA文件的轉換器和介面。\nUGFLEXLM: FlexLM許可證管理系統。\nUGFPCD: 印刷電路板(PCB)設計工具。\nUGII: NX 用戶界面和基礎功能。\nUGIMW: 整合材料管理工作台。\nUGMANAGER: 文件和專案管理工具。\nUGOPEN: 開發模組和API。\nUGOPENPP: C++ 開發模組。\nUGPCBXCHANGE: PCB數據交換工具。\nUGPHOTO: 高級著色和視覺工具。\nUGSTRUCTURES: 結構分析和設計工具。\nUGSTUDIO: 產品設計工作室。\nUGTIPS: 用戶提示和幫助文件。\nUGTO2D: 3D到2D轉換工具。\nUGWEB: Web 整合和協同工具。\nUGWELD: 焊接設計和分析工具。\nUNFOLD: 鈑金展開工具。 \n NX2312 完整版各目錄容量: \n ACOUSTICS : 1.28 GB\nAM_SIMULATION : 67.7 MB\nAUTOMATED_TESTING : 3.19 MB\nAUTOMATIC_UPDATE : 541.0 B\nAUTOMATION_DESIGNER : 336.83 MB\nCAPITALINTEGRATION : 2.04 MB\nCATIAV5 : 901.76 KB\nCLOUDDM : 13.18 KB\nCMM_INSPECTION : 319.18 MB\nCOMPOSITES : 54.18 KB\nDESIGNSPACEEXPLORER : 8.04 KB\nDESIGN_TOOLS : 135.75 MB\nDIAGRAMCORE : 5.81 MB\nDIAGRAMMING : 118.67 MB\nDOCUMENT : 666.71 KB\nDRAFTING : 115.44 MB\nDXFDWG : 197.04 MB\nFABRICMODELER : 5.03 KB\nGCTOOLKIT : 230.19 MB\nIGES : 5.47 MB\nIMMERSIVEEXPERIENCE : 1016.81 MB\nINSTALL : 55.39 KB\nLOCALIZATION : 94.3 KB\nMACH : 2.41 GB\nMANUFACTURING_PLANNING : 160.74 MB\nMBD : 67.83 MB\nMECH : 871.99 MB\nMECHATRONICS : 278.23 MB\nMENDIXREPORTING : 1.05 MB\nMOLDCOOLING : 12.37 KB\nMOLDWIZARD : 236.79 MB\nMPA : 1.48 MB\nNX2DEDIT : 1.25 MB\nNXAECDESIGN : 70.86 MB\nNXASSEMBLY : 91.5 MB\nNXBIN : 6.47 GB\nNXCABLEROUTER : 29.51 KB\nNXCAE_EXTRAS : 4.55 GB\nNXCOATINGS : 632.24 KB\nNXCREO : 5.71 MB\nNXHUMAN : 247.74 MB\nNXJOIN : 24.34 MB\nNXNASTRAN : 3.23 GB\nNXPARTS : 64.96 MB\nNXPLOT : 246.92 MB\nNXREPORTS : 3.66 MB\nNXSHIP : 339.88 MB\nNXSTRUCTUREDESIGN : 119.29 MB\nNXVR : 534.04 MB\nNX_VSA : 12.73 MB\nPARTMFG : 32.08 MB\nPLASTIC_DESIGNER : 6.49 MB\nPOSTBUILD : 35.08 MB\nPSTUDIO : 35.5 MB\nPVTRANS : 106.92 KB\nREL_INFO : 36.92 KB\nROUTING : 433.54 MB\nRULE : 306.25 KB\nSAFETY : 24.39 KB\nSIMULATION : 2.68 GB\nSTAGE_MODEL : 4.06 MB\nSTAMPING_TOOLS : 163.08 MB\nSTEP203UG : 1.44 MB\nSTEP214UG : 1.44 MB\nTDP : 219.56 MB\nTOOLING_BASE : 254.04 KB\nTRANSLATORS : 150.1 MB\nUGALLIANCE : 89.19 KB\nUGAUTOMOTIVE : 147.22 MB\nUGCATIA : 6.04 MB\nUGFLEXLM : 30.28 MB\nUGFPCD : 31.89 KB\nUGII : 550.7 MB\nUGIMW : 8.45 MB\nUGMANAGER : 127.12 MB\nUGOPEN : 530.1 MB\nUGOPENPP : 692.91 KB\nUGPCBX : 342.48 KB\nUGPCBXCHANGE : 102.96 MB\nUGPHOTO : 3.94 GB\nUGSTRUCTURES : 346.62 MB\nUGSTUDIO : 14.03 MB\nUGTIPS : 56.22 MB\nUGTO2D : 886.88 KB\nUGWEB : 9.08 MB\nUGWELD : 2.07 MB\nUNFOLD : 71.92 KB\nVDA : 26.31 KB\nVDV : 5.34 MB\ntotal: 33.32 GB \n NX2312 各功能對應目錄: \n Simcenter Nastran - NXNASTRAN\nSimcenter 3D Acoustics - ACOUSTICS\nProgramming Tools - UGALIANCE UGOPEN UGOPENPP\nModel Based Part Manufacturing - PARTMFG DOCUMENT DIAGRAMMING\nShip Building - NXSHIP NXCABLEROUTER\nGreater China Tools - GCTOOLKIT\nAutomated Testing Studio - AUTOMATED_TESTING\nAutomotive - UGAUTOMOTIVE DESIGN_TOOLS STAMPING_TOOLS TOOLING_BASE UGWELD VDV VDA\nComposites - COMPOSITES\nDiagramming - DIAGRAMMING\nDrafting - DRAFTING NX2DEDIT\nFabric Modeler - FABRICMODELER\nImmersive - IMMERSIVEEXPERIENCE\nInductrial Electrical Design - AUTOMATION_DESIGNER\nManufacturing - MACH CMM_INSPECTION MBD NX_VSA POSTBUILD PSTUDIO STAGE_MODEL UNFOLD\nManufacturing Planning - MANUFACTURING_PLANNING\nMechatronics Concept Designer - MECHATRONICS\nNX Reporting - MENDIXREPORTING\nOptimization Tools - DESIGNSPACEEXPLORER\nMolded Part Design - PLASTIC_DESIGNER\nRouting - ROUTING CAPITALINTEGRATION\nSimcenter 3D - COMPOSITES MECH MOLDCOOLING NXCAE_EXTRAS SAFETY SIMULATION UGSTRUCTURE UGPCBEXCHANGE UGPCBX UGFPCD\nStudio Render - UGSTUDIO UGPHOTO\nTooling Design & NX Joint - DESIGN_TOOLS MOLDWIZARD NXAECDESIGN NXCOATINGS NXJOIN NXREPORTS NXSTRUCTUREDESIGN STAMPING_TOOLS TOOLING_BASE UGAUTOMOTIVE UGWELD\nTranslators - CATIAV5 DXFDWG IGES NXCREO STEP203UG STEP214UG UGCATIA UGMW UGTO2D TRANSLATORS\nValidation - DESIGN_TOOLS NXREPORTS MPA\nNX VR - NXVR \n \n', 'tags': '', 'url': 'NX2312.html'}, {'title': 'NX2406', 'text': 'NX2406 NXOpen Python 動態連結程式庫採用 Python \xa03.10.12 版本編譯 . \n 下載  NX2406 可攜 CAD 壓縮檔案 (1.76 GB, 解開後約 9 GB) \n 有關 NX on 2024.June: \n NX2406 在 Windows 安裝需要 MS Windows Desktop Runtime 6.0.16 以上版本. \n NX2406 安裝目錄與容量: \n \n NX Platform: 必要檔案容量 6953 MB, 若加上 Simcenter NASTRAN (4265 MB), Programming Tools (562 MB), Drafting (119MB), Optimization Tools (11 MB) and Translators (140 MB), Ugstructures (353 MB),\xa0 Ncae_extras (4120 MB), Simulation (2690 MB) 將是具備可攜基本 CAD/CAE 與延伸程式開發功能的 NX 套件, 容量約 20 GB. \n Localizations: 若選擇 Traditional Chinese 介面, 目錄名稱 Localizations, 增加 107 MB, 但一般建議直接使用英文介面即可. \n Simcenter Nastran: FE solver for simulation products, Mach stress and vibration wizards. 目錄名稱為 NASTRAN, 增加 4265 MB. \n Simcenter 3D Acoustics: Acoustics BEM 與 Ray solvers, 目錄名稱 ACOUSTICS, 增加 1418 MB. \n Programming Tools: Programming Interfaces, 目錄名稱 UGALLIANCE, UGOPEN, UGOPENPP, 增加 562 MB. \n Model Based Part Manufacturing: 目錄名稱 PARTMFG, DOCUMENT, DIAGRAMMING, 增加 176 MB. \n Additive Manufacturing Simulation: 目錄名稱 AM_SIMULATION, COMPOSITE, MACH, NXCAE_EXTRAS, SIMULATION, UGSSTRUCTURES, 增加 10 GB. \n Ship Building: 目錄名稱 NXSHIP, NXCABLEROUTER, 增加 353 MB. \n Greater China Tools: 目錄名稱 GCTOOLKIT, 增加 233 MB. \n Automated Testing Studio: 目錄名稱 AUTOMATED_TESTING, 增加 4848 KB. \n Automotive: 目錄名稱 UGAUTOMOTIVE, DESIGN_TOOLS, MOLDWIZARD, NXREPORTS, STAMPING_TOOLS, TOOLING_BASE, UGWELD, VDV, VDA, 增加 842 MB. \n Composites: 目錄名稱 COMPOSITES, 增加 208 MB. \n Digramming: 目錄名稱 DIAGRAMMING, 增加 135 MB. \n Drafting: Extends 2D and 3D drawing tools, 目錄名稱 DRAFTING, NX2EDIT, 增加 119 MB. \n Fabric Modeler: 目錄名稱 FABRICMODELER, 增加 2744 KB. \n Immersive: 目錄名稱 IMMERSIVEEXPERIENCE, 增加 1056 MB. \n Industrial Electrical Design: 目錄名稱 AUTOMATION_DESIGNER,\xa0 增加 404 MB. \n Manufacturing: 目錄名稱 MACH, CMM_INSPECTION, MBD, NX_VSA, POSTBUILD, PSTUDIO, STAGE_MODEL, UNFOLD, 增加 3565 MB. \n Manufacturing Planning: 目錄名稱 MANUFACTURING_PLANNING, 增加 449 MB. \n Mechatronics Concept Designer: 目錄名稱 MECHATRONICS, 增加 332 MB. \n NX Reporting: 目錄名稱 MENDIXREPORTING, 增加 1312 KB. \n Optimization Tools: 目錄名稱 DESIGNSPACEEXPLORER, 增加 11 MB. \n Molded Part Design: 目錄名稱 PLASTIC_DESIGNER, 增加 13 MB. \n Routing: 目錄名稱 ROUTING, CAPITALINTEGRATION, 增加 467 MB. \n Simcenter 3D: 目錄名稱 COMPOSITES, MECH, MOLDCOOLING, NXCAE_EXTRAS, SAFETY, SIMULATION, UGSTRUCTURES, UGPCBXCHANGE, UGPCBX, UGFPCB, 增加 9007 MB. \n Studio Render: 目錄名稱 UGSTUDIO, UGPHOTO, 增加 4085 MB. \n Tooling Desing and NX Join: 目錄名稱 DESIGN_TOOLS, MOLDWIZARD, NXAECDESIGN, NXCAATINGS, NXJOIN, NXREPORT, NXSTRUCTUREDESIGN, STAMPING_TOOLS, TOOLING_BASE, UGAUTOMOTIVE, UGWELD, 增加 1079 MB. \n Translators: 目錄名稱\xa0CATIAV5, DXFDWG, IGES, NXCREO, STEP203UG\xa0STEP214UG, UGCATIA, UGIMW, UGTO2D, TRANSLATORS, 增加 815 MB. \n Validation: 目錄名稱 DESIGN_TOOLS, TOOLS_NXREPORTS, MPA, 增加 182 MB. \n \n \n https://plm.sw.siemens.com/en-US/nx/best-cad-cam-software-industry-awards/ \xa0 \n NX X: \n 2024\xa0 Siemens 推出 NX X . \n https://resources.sw.siemens.com/en-US/video-introducing-nx-x-nx-as-a-saas-solution \xa0 \n https://plm.sw.siemens.com/en-US/nx/products/compare-nx-x-cad-bundles/ \xa0 \n https://blogs.sw.siemens.com/nx-manufacturing/whats-new-in-nx-for-manufacturing-june-2024/ \n \n NX2406  新增功能 \n NX2406  文件瀏覽 \n NX2406  草圖文件 \n NX2406  建模文件 \n NX2406  組立文件 \n', 'tags': '', 'url': 'NX2406.html'}, {'title': 'NXOpen', 'text': "https://github.com/mdecycu/nxopen \n Browse Programming Tools Help \n Overview of Programmer's Guide \n Open C Programmer's Guide \n Open C Reference Guide \n msys64_20240507.7z  (183MB) \n NXOpen Python Reference Guide \n 若使用 NX2312, 其中需要設計並繪製減速機中的正齒輪組 (Spur Gear Train), 若採 UGOPEN C 編寫延伸程式, 可以利用 MSYS2 中的 gcc 進行編譯與連結: \n mkdir build\n \nmkdir dist\n \nREM compile gear.c\ngcc.exe -c -g -IC:\\nx2312_portable\\data\\nx2312\\UGOPEN -MMD -MP -MF build/gear.o.d -o build/gear.o gear.c\n \nREM link with libufun.lib and libugopenint.lib\ngcc.exe -shared -o dist/gear.dll build/gear.o C:\\nx2312_portable\\data\\nx2312\\UGOPEN\\libufun.lib C:\\nx2312_portable\\data\\nx2312\\UGOPEN\\libugopenint.lib \n 取得 gear.dll 後, 可開啟 new Model file 後, 以 File -> Execute -> NX Open 執行 gear.dll. \n UGOpen C 程式架構請參考  UG_Open-API_Programming.pdf \n UGOpen 技術文件請參考: \n Open C Programmer's Guide  (for internal IPv6 users only) \n Open C Reference Manual  (for internal IPv6 users only) \n \n  接下來將 mp4 檔案從 downloads 目錄取出  \n \n \n gear_model2.c.txt \n uarm_gear_design_for_NX.zip \n using MSYS2 compile gear.c:  spur_gear_NXOpen_C_NX2312.7z \n NXOpen_ref.7z \n", 'tags': '', 'url': 'NXOpen.html'}, {'title': 'NXOpen_Python', 'text': 'NX2312 與 NX2406 必須配合 Python 3.10 使用 (以 Python 3.10.12 編譯 .pyd), 這裡利用 gen_python_for_nx2312.py 如下, 建立 Python310 備用 (由於 Python 3.10.12 可攜目錄無法使用下列程式建立, 因此退至 Python 3.10.11): \n import urllib.request\nimport os\n    \ndir_path = os.path.dirname(os.path.realpath(__file__))\n# basic files for Python installation\n# before 3.12.0\npy_list = ["core", "dev", "exe", "lib", "tcltk", "tools"]\n# 3.12.1 no tools.msi\n#py_list = ["core", "dev", "exe", "lib", "tcltk"]\n# Python version 3.10.11 for NX2312\nversion = "3.10.11"\n# Python msi download URL\nftp = "https://www.python.org/ftp/python/" + version + "/amd64/"\n# location for Portable Python\npath = "y:\\\\tmp\\\\Python310"\n# create directory\ntry:\n    os.mkdir(path)\nexcept:\n    # path exists\n    pass\n# get Python installation msi files and extract into target dir\nfor i in py_list:\n    filename = i + ".msi"\n    url = ftp + filename\n    # download basic python msi file\n    urllib.request.urlretrieve(url, filename)\n    os.system("msiexec.exe /a " + i + ".msi targetdir=" + path)\n    # delete msi file\n    os.remove(dir_path + "\\\\" + i + ".msi")\n    os.remove(path + "\\\\" + i + ".msi") \n 其中可攜程式系統啟動批次檔, 必須將 NX\\NXbin\\python 納入 PYTHONPATH 設定, 因為 NXOptn 相關的動態連結程式庫 *.pyd 都放在這個目錄. \n set PYTHONPATH=%Disk%:\\Python310\\DLLs;%Disk%:\\Python310\\Lib;%Disk%:\\Python310\\Lib\\site-packages;%Disk%:\\NX\\NXBIN\\python; \n 在可攜啟動批次檔案中的 path 指令搜尋路徑之後, 讓 NX2312 取得使用授權後啟動: \n REM for NX2312, must after path setup \nset SPLM_LICENSE_SERVER=29000@192.168.56.3\nset UGII_LANG=english\nset UGS_LICENSE_BUNDLE=ACD11,ACD10\nset UGII_BASE_DIR=%Disk%:\\NX\\\nset UGII_TMP_DIR=%Disk%:\\NX\\temp\nset UGII_LIB_PATH=%Disk%:\\NX\\NXBIN\\python\nset ugii=%Disk%:\\NX\\ugii;%Disk%:\\NX\\nxbin;\npath = %ugii%;%path%\nXcopy %Disk%:\\home_ipv6\\AppData\\Local\\Siemens\\NX2312 C:\\users\\%USERNAME%\\AppData\\Local\\Siemens\\NX2312 /E /H /C /I /Y \n AppData\\Local\\Siemens\\NX2312\\NX_user.dpv 內容設定: \n <?xml version="1.0" encoding="UTF-8"?>\n\n<?xml-stylesheet type="text/xsl" href="NX_user.xsl"?>\n<PrefValues defaultLockStatus="unlocked">\n<Pref Application="Gateway" Category="General" Tab="Data Privacy" displayValue="No" modified="2024-08-09T08:48:09" name="NX_ProductExcellenceProgram" title="Product Excellence Program - Participate" value="false"/>\n<Pref Application="Gateway" Category="General" Tab="Miscellaneous" displayValue="No" modified="2024-08-09T08:25:55" name="NX_ProductExcellenceProgramMessage" title="Product Excellence Program - Display Initial Startup Message" value="false"/>\n<Pref Application="Gateway" Category="User Interface" Tab="Journal" displayValue="Python" modified="2024-08-09T08:26:17" name="UG_journalLanguage" title="Journal Language" value="4"/>\n</PrefValues> \n nxopen_ex.7z \n', 'tags': '', 'url': 'NXOpen_Python.html'}, {'title': 'Open C', 'text': 'The following table lists the Open C functions that have been wrapped for use in NXOpen.NET. The list provides the Open C function name and the corresponding C# method. \n \n \n \n \n Open C Function \n \n \n C# Wrapper Method \n \n \n \n \n \n \n uc4577 \n \n \n UFCFI::GetUniqueFilename \n \n \n \n \n uc5822 \n \n \n UFPATT::AskData \n \n \n \n \n uc5823 \n \n \n UFPATT::Import \n \n \n \n \n uc5824 \n \n \n UFPATT::CycleErrors \n \n \n \n \n uf5940 \n \n \n UFTrns::CreateCsysMappingMatrix \n \n \n \n \n uf5941 \n \n \n UFTrns::MapPosition \n \n \n \n \n uf5942 \n \n \n UFTrns::MultiplyMatrices \n \n \n \n \n uf5943 \n \n \n UFTrns::CreateTranslationMatrix \n \n \n \n \n uf5944 \n \n \n UFTrns::CreateScalingMatrix \n \n \n \n \n uf5945 \n \n \n UFTrns::CreateRotationMatrix \n \n \n \n \n uf5946 \n \n \n UFTrns::CreateReflectionMatrix \n \n \n \n \n uf5947 \n \n \n UFTrns::TransformObjects \n \n \n \n \n uc6409 \n \n \n UFView::AskViewDependentStatus \n \n \n \n \n uc6434 \n \n \n UFView::SetViewMatrix \n \n \n \n \n uc1615 \n \n \n UFUi::PickPoint \n \n \n \n \n uc1616 \n \n \n UFUi::PointSubfunction \n \n \n \n \n uc1630 \n \n \n UFUi::PickCsys \n \n \n \n \n uc1652 \n \n \n UFUi::PickView \n \n \n \n \n uc1653 \n \n \n UFUi::AskLastPickedView \n \n \n \n \n uc1600 \n \n \n UFUi::AskStringInput \n \n \n \n \n uc1601 \n \n \n UFUi::DisplayMessage \n \n \n \n \n uc1603 \n \n \n UFUi::DisplayMenu \n \n \n \n \n uc1605 \n \n \n UFUi::DisplayMultiSelectMenu \n \n \n \n \n \n \n \n Non-wrapped NX Open C functions \n \n \n The Non-wrapped NX Open C functions are Open C functions that do not have .NET, Java, or Python bindings provided. This is mainly due to the following reasons: \n \n \n Corresponding functions have no use in .NET, Java, or Python \n \n \n Functions in C are so complex that we cannot map them to .NET, Java, or Python \n \n \n The following are the non-wrapped NX Open C functions: \n UF_ASSEM_free_deform_warnings_data UF_ASSEM_free_prev16_aligns UF_CLONE_free_validation_options UF_CUT_LEVELS_free UF_DRF_free_comp_data UF_FAM_free_class_data UF_FBM_GEOM_free_classified_set_list UF_GDT_free UF_KF_free_list_object_contents UF_KF_free_rule_value UF_LIB_free_rset_map UF_MODL_free_bsurf_data UF_MODL_free_compare_data UF_MODL_free_compare_data_3 UF_MODL_free_law UF_MODL_free_law_extension UF_MODL_free_refit_face_feature_data UF_MODL_free_rough_offset_data UF_MODL_free_silhouette_flange UF_MODL_free_snip_surface_feature_data UF_MODL_free_string_list UF_MODL_shape_pattern_free_client_data UF_MODL_SWEEP_free_trim_data UF_MODL_udf_free_exp_data UF_NXSM_free_closed_corner_data UF_NXSM_free_flange_data UF_NXSM_free_flange_sketch_data UF_NXSM_free_rebend_data UF_NXSM_free_unbend_data UF_PART_free_load_status UF_PD_free_business_modifier_data UF_PD_free_product_attribute_data UF_PD_free_product_attribute_data_2 UF_PD_free_product_attribute_value_data UF_ROUTE_free_places UF_SF_free_defeature_parms UF_SF_free_idealize_parms UF_SF_free_idealize_region UF_SF_free_midsrf_user_parms UF_SF_LEGEND_free_attr UF_SUBDIV_free UF_WAVE_free_linked_feature_info UF_WEIGHT_free_exceptions \n \n \n \n \n \n', 'tags': '', 'url': 'Open C.html'}, {'title': 'MSYS2', 'text': 'msys64_20240507.7z  (183MB) \n', 'tags': '', 'url': 'MSYS2.html'}, {'title': 'Solvespace', 'text': 'Solvespace 採 C++ 編寫, 原始碼位於\xa0 https://github.com/solvespace/solvespace , 以下將採用可攜程式系統 python_2025 中的 msys2 ( msys64_20240507.7z ) 以及 cmake 3.20.1 進行編譯 (若採用目前最新版的 cmake 3.30.2, 必須對 Solvespace v3.1 中的 CMakeLists.txt 進行修改). \n 舊版的 cmake 3.21.0 可以利用下列連結取得: \n https://github.com/Kitware/CMake/releases/download/v3.21.0/cmake-3.21.0-windows-x86_64.zip \xa0 \n msys64_20240507.7z  則必須安裝 mingw32-make: \n pacman -S mingw-w64-ucrt-x86_64-make \n 最新版的 python_2025 可攜程式環境架構位於:  https://github.com/mdecycu/pyhton_2025 , 各目錄套件可自行根據  https://mde.tw/cad2024/content/Python.html  中的說明下載, 或者自行配置. \n 機械設計工程師採用可攜程式套件的原因, 是希望能彈性配置 Python 版本, 因為大多數主流 CAD/E/M 套件都非開源軟體, 各版本的 API 相關的動態連結程式庫, 都採用特定的 Python 版本程式碼編譯而成. 例如: Siemens NX12 採用 Python 3.6.5, NX1872 採用 Python 3.7.1, NX1980 採用 Python 3.8.8, NX2312 使用 Python 3.10.12. 假如採用可攜程式套件, 除了可以如虛擬 Python 環境一樣, 將能配合 NXOpen 程式開發, 將所需的 Python 版本與相關模組放在同一目錄, 且能夠在不同的 64 位元 Windows 操作系統中執行. \n 接著取得 Solvespace v3.1 的原始碼, 可以直接從\xa0 https://github.com/solvespace/solvespace/releases \xa0取得, 或以\xa0以 git clone --recurse-submodules  https://github.com/solvespace/solvespace.git \xa0之後, \n cd solvespace \n git checkout v3.1 \n 接下來則必須修改\xa0solvespace\\extlib\\angle\\src\\libANGLE\\HandleAllocator.cpp 加入標頭檔案: \n #include <limits> \n 接著就可以進行程式碼的編譯與連結: \n mkdir build \n cd build \n cmake .. -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=Release \n mingw32-make \n 完成編譯後, solvespace.exe 即位於 build\\bin 目錄中, 執行時則需要\xa0libwinpthread-1.dll 動態連結程式庫. \n 進行上述流程編譯的原始碼\xa0 solvespace_v3.1_src.7z , 以及編譯完成的  solvespace_v3.1_msys2.7z . \n \n \n \n', 'tags': '', 'url': 'Solvespace.html'}, {'title': 'CoppeliaSim', 'text': '下載相容於 IPv6 的 CoppeliaSim 4.7.0 rev4:  CoppeliaSim_Edu_4.7.0_rev4_for_2024Fall.7z \n ZMQ Remote API Python Examples:  https://github.com/benzr/cdfrob2024-coppeliasim-zeromq-remote-api  (修改為 4.7.0 相容範例:  cdfrob2024-coppeliasim-zeromq-remote-api.7z ) \n 官方 4.7.0 Visualization Stream 瀏覽器前端允許使用者變動場景中的物件位置與方位, 若要移除此一功能, 必須修改 threejsFrontend.html 與 threejsFrontend.js. (下載已經修改後的 超文件與 js 檔案 ) \n 模擬場景範例:  tricycle_ttt.7z ,  GPSsensor_ttt.7z \n CoppeliaSim Tutorial Videos \n Get started with CoppeliaSim \n \n CoppeliaSim 在 2024.06.14 推出  4.7.0 版 , 其中沿用至 4.6.0 版的 zmqRemoteApi 模組已經改名為 coppeliasim_zmqremoteapi_client, 部分模組的內容也進行些微更動, 導致先前所編寫的 ZMQ Rempte API Python 程式都必須因應修改, 否則無法執行. \n KMOLab 在 4.5.1 版為了讓 CoppeliaSim 的 ZMQ Remote API Python 遠端控制程式能夠在 IPv6 網路協定中執行, 修改了 Server 與 Client 模組中的 ZMQ 程式設定, 若要讓 4.7.0 版也能相容於 IPv6, 則必須修改下列程式碼: \n lua\\pythonWrapperV2.lua \n function initPython(prog)\n    local pyth = sim.getStringParam(sim.stringparam_defaultpython)\n    local pyth2 = sim.getNamedStringParam("python")\n    if pyth2 then pyth = pyth2 end\n    if pyth == nil or #pyth == 0 then\n        local p = sim.getInt32Param(sim.intparam_platform)\n        if p == 0 then\n            pyth = \'py\'\n        else\n            pyth = \'python3\'\n        end\n    end\n    local errMsg\n    if pythonExecutable then\n        pyth = pythonExecutable\n    end\n    if pyth and #pyth > 0 then\n        subprocess, controlPort = startPythonClientSubprocess(pyth)\n        if controlPort then\n            pyContext = simZMQ.ctx_new()\n            pySocket = simZMQ.socket(pyContext, simZMQ.REQ)\n            -- enable IPv6 for ZMQ, default is false to IPv6 from KMOLab\n            simZMQ.setsockopt(pySocket,simZMQ.IPV6,sim.packUInt32Table{1})\n            simZMQ.setsockopt(pySocket,simZMQ.IPV4ONLY,sim.packUInt32Table{0})\n            -- end for enabling IPv6 for ZMQ\n            simZMQ.setsockopt(pySocket, simZMQ.LINGER, sim.packUInt32Table {0})\n            simZMQ.connect(pySocket, controlPort)\n            virtualPythonFilename = sim.getStringParam(sim.stringparam_scene_path_and_name) \n 另外必須注意的是 4.7.0 在 Windows 中使用虛擬硬碟代號 z:, 若控制程式的開發是在可攜程式系統中進行, 必須避開使用 z:. \n 另外在 lua\\motion.lua 中將封包傳送綁定在 localhost, 嘗試修改如下: \n function sim.generateTimeOptimalTrajectory(...)\n    simZMQ = require \'simZMQ\'\n    local path, pathLengths, minMaxVel, minMaxAccel, trajPtSamples, boundaryCondition, timeout =\n        checkargs({\n            {type = \'table\', item_type = \'float\', size = \'2..*\'},\n            {type = \'table\', item_type = \'float\', size = \'2..*\'},\n            {type = \'table\', item_type = \'float\', size = \'2..*\'},\n            {type = \'table\', item_type = \'float\', size = \'2..*\'},\n            {type = \'int\', default = 1000},\n            {type = \'string\', default = \'not-a-knot\'},\n            {type = \'float\', default = 5},\n    }, ...)\n\n    local confCnt = #pathLengths\n    local dof = math.floor(#path / confCnt)\n\n    if (dof * confCnt ~= #path) or dof < 1 or confCnt < 2 or dof ~= #minMaxVel / 2 or\n        dof ~= #minMaxAccel / 2 then error("Bad table size.") end\n    local lb = sim.setStepping(true)\n\n    local pM = Matrix(confCnt, dof, path)\n    local mmvM = Matrix(2, dof, minMaxVel)\n    local mmaM = Matrix(2, dof, minMaxAccel)\n\n    sim.addLog(sim.verbosity_scriptinfos,\n        "Trying to connect via ZeroMQ to the \'toppra\' service... " ..\n        "make sure the \'docker-image-zmq-toppra\' container is running. " ..\n        "Details can be found at https://github.com/CoppeliaRobotics/docker-image-zmq-toppra"\n    )\n    local context = simZMQ.ctx_new()\n    local socket = simZMQ.socket(context, simZMQ.REQ)\n    simZMQ.setsockopt(socket, simZMQ.RCVTIMEO, sim.packInt32Table {1000 * timeout})\n    simZMQ.setsockopt(socket, simZMQ.LINGER, sim.packInt32Table {500})\n    -- local result = simZMQ.connect(socket, \'tcp://localhost:22505\')\n    -- try to make it IPv6 compatable\n    local result = simZMQ.connect(socket, \'tcp://*:22505\')\n    if result == -1 then\n        local err = simZMQ.errnum()\n        error(\'connect failed: \' .. err .. \': \' .. simZMQ.strerror(err))\n    end \n 另外, 在 coppeliasim_zmqremoteapi_client 模組,\xa0 __init__.py 中, 也必須納入 IPv6 相容設定: \n class RemoteAPIClient:\n    """Client to connect to CoppeliaSim\'s ZMQ Remote API."""\n\n    def __init__(self, host=\'localhost\', port=23000, cntport=None, *, verbose=None):\n        """Create client and connect to the ZMQ Remote API server."""\n        self.verbose = int(os.environ.get(\'VERBOSE\', \'0\')) if verbose is None else verbose\n        self.context = zmq.Context()\n        self.socket = self.context.socket(zmq.REQ)\n        # Enable IPv6 on the socket\n        self.socket.setsockopt(zmq.IPV6, 1)\n        self.socket.connect(f\'tcp://{host}:{port}\')\n        self.uuid = str(uuid.uuid4())\n        self.callbackFuncs = {}\n        self.requiredItems = {}\n        self.VERSION = 2\n        self.timeout = 10 * 60\n        self.sendCnt = 0\n        main_globals = sys.modules[\'__main__\'].__dict__\n        main_globals[\'require\'] = self.require \n 最後 addOns\\ZMQ remote API server.lua 中也必須改為 IPv6 相容: \n --    if zmqRemoteApi.verbose() > 0 then\n        sim.addLog(\n            sim.verbosity_scriptinfos,\n            string.format(\'ZeroMQ Remote API server starting (rpcPort=%d)...\', rpcPort)\n        )\n--    end\n    cbor = require \'org.conman.cbor\'\n    context = simZMQ.ctx_new()\n    rpcSocket = simZMQ.socket(context, simZMQ.REP)\n    -- enable IPv6 for ZMQ, default is false to IPv6\n    simZMQ.setsockopt(rpcSocket,simZMQ.IPV6,sim.packUInt32Table{1})\n    -- ZMQ IPv4ONLY default is true: http://api.zeromq.org/4-2:zmq-setsockopt\n    simZMQ.setsockopt(rpcSocket,simZMQ.IPV4ONLY,sim.packUInt32Table{0})\n    -- end enabling IPv6\n    simZMQ.bind(rpcSocket, string.format(\'tcp://*:%d\', rpcPort))\n    if zmqRemoteApi.verbose() > 0 then\n        sim.addLog(sim.verbosity_scriptinfos, \'ZeroMQ Remote API server started\')\n    end \n 在 4.7.0 中執行的 ZMQ Remote API Python 測試程式: \n # CoppeliaSim 4.7.0 rev4 適用\n# 與 4.5.1 只差在:\n\'\'\'\n# 利用 size 數列, 建立圓柱物件, 2 代表 cylinder\n# 8 表示 respondable, 1 為 質量\ndigit1_handle = sim.createPureShape(2, 8, size, 1, None)\n已經改為 4.7.0 的:\ndigit1_handle = sim.createPrimitiveShape(sim.primitiveshape_cylinder, size, 0)\nrespondable 屬性與質量必須另外設定\n\'\'\'\n# zmqRemoteApi_IPv6 為將 zmq 通訊協定修改為 IPv4 與 IPv6 相容\n# pip install pyzmq cbor keyboard\n# for 4.5.1\n#from zmqRemoteApi_IPv6 import RemoteAPIClient\n# for 4.7.0\nfrom coppeliasim_zmqremoteapi_client import RemoteAPIClient\nimport time\nimport math\nimport keyboard\n  \n# 利用 zmqRemoteAPI 以 23000 對場景伺服器進行連線\nclient = RemoteAPIClient(\'[::1]\', 23000)\n# 以 getObject 方法取得場景物件\nsim = client.getObject(\'sim\')\nbox = sim.getObject(\'/box\')\n  \n# 啟動模擬\nsim.startSimulation()\n# 建立尺寸數列, 分別定義 x, y, z 方向尺寸\nx = 0.2\ny = 0.2\nz = 0.1\nsize = [x, y, z]\n  \n# 利用 size 數列, 建立圓柱物件\n# https://manual.coppeliarobotics.com/en/regularApi/simCreatePrimitiveShape.htm\ndigit1_handle = sim.createPrimitiveShape(sim.primitiveshape_cylinder, size, 0)\n# 將 digit1 設為動態\n# 設置質量屬性\nsim.setObjectFloatParam(digit1_handle, sim.shapefloatparam_mass , 1.0)\n# 設置物體為動態\nsim.setObjectInt32Param(digit1_handle, sim.shapeintparam_static, 0)\nsim.resetDynamicObject(digit1_handle)\n# 設為具備碰撞檢測屬性\nsim.setObjectInt32Param(digit1_handle, sim.shapeintparam_respondable , 1)\n# 將圓柱物件命名為 digit1, 若用於機械計分可做為個位數轉盤\n# 之後可再導入帶有數字組立的外型零件\nsim.setObjectAlias(digit1_handle, \'digit1\')\n# 轉角單位為徑度\nsim.setObjectOrientation(digit1_handle, -1, [0, math.pi/2, 0])\n# 起始物件中心位於 [0, 0, 0], 為了位於地板, 往 z 提升一個半徑高度\nsim.setObjectPosition(digit1_handle, -1, [0, 0, x/2])\n  \n# 建立 revolute joint 命名為 joint, 且將 joint mode 設為 dynamic, control mode 設為 velocity\njoint1_handle = sim.createJoint(sim.joint_revolute_subtype, sim.jointmode_dynamic, 0, None)\nsim.setObjectInt32Param(joint1_handle, sim.jointintparam_dynctrlmode, sim.jointdynctrl_velocity)\nsim.setObjectAlias(joint1_handle, \'joint1\')\n  \n# 取得 cylinder 的位置座標\ndigit1_pos = sim.getObjectPosition(digit1_handle, -1)\njoint1_pos = [digit1_pos[0], digit1_pos[1], digit1_pos[2]]\n  \n# 將 joint1 至於 cylinder 中心\nsim.setObjectPosition(joint1_handle, -1, joint1_pos)\n# 取得 digit1_handle 的方位\ndigit1_ori = sim.getObjectOrientation(digit1_handle, -1)\n# 將 joint1_handle 方位與 digit1 對齊\nsim.setObjectOrientation(joint1_handle, -1, digit1_ori)\n  \n# 將 joint1 置於 box 上\nsim.setObjectParent(joint1_handle, box, True)\n# 將 cylinder 置於 joint1 上\nsim.setObjectParent(digit1_handle, joint1_handle, True)\n  \n# 鎖定 joint1\n# for 4.5.1\n#sim.setJointForce(joint1_handle, float(\'inf\'))\n# for 4.7.1\nsim.setJointTargetForce(joint1_handle, float(\'inf\'))\n  \nprint("基本場景建立完成!")\n  \n# 設定主迴圈\nwhile True:\n    # 設定 joint1 目標速度\n    sim.setJointTargetVelocity(joint1_handle, 10)\n    # 讓 coppeliasim 有時間按照設定讓 joint1 旋轉\n    time.sleep(0.01) \n  \n    if keyboard.is_pressed(\'q\'):\n        # 可以按下 q 鍵跳出重複執行迴圈\n        break\n  \n# 終止模擬\nsim.stopSimulation() \n 若加入 Model 程式庫中的加速度規於輪子上, 並將轉動感測數據列出: \n from coppeliasim_zmqremoteapi_client import RemoteAPIClient\nimport time\nimport math\nimport keyboard\n\n# 利用 zmqRemoteAPI 以 23000 對場景伺服器進行連線\nclient = RemoteAPIClient(\'[::1]\', 23000)\n# 以 getObject 方法取得場景物件\nsim = client.getObject(\'sim\')\nbox = sim.getObject(\'/box\')\n\n# 啟動模擬\nsim.startSimulation()\n\n# 建立尺寸數列, 分別定義 x, y, z 方向尺寸\nx = 0.2\ny = 0.2\nz = 0.1\nsize = [x, y, z]\n\n# 利用 size 數列, 建立圓柱物件\ndigit1_handle = sim.createPrimitiveShape(sim.primitiveshape_cylinder, size, 0)\nsim.setObjectAlias(digit1_handle, \'digit1\')\nsim.setObjectOrientation(digit1_handle, -1, [0, math.pi/2, 0])\nsim.setObjectPosition(digit1_handle, -1, [0, 0, x/2])\n\n# 將 digit1 設為動態\n# 設置質量屬性\nsim.setObjectFloatParam(digit1_handle, sim.shapefloatparam_mass , 1.0)\n# 設置物體為動態\nsim.setObjectInt32Param(digit1_handle, sim.shapeintparam_static, 0)\nsim.resetDynamicObject(digit1_handle)\n# 設為具備碰撞檢測屬性\nsim.setObjectInt32Param(digit1_handle, sim.shapeintparam_respondable , 1)\n\n# 建立 revolute joint 命名為 joint, 且將 joint mode 設為 dynamic, control mode 設為 velocity\njoint1_handle = sim.createJoint(sim.joint_revolute_subtype, sim.jointmode_dynamic, 0, None)\nsim.setObjectInt32Param(joint1_handle, sim.jointintparam_dynctrlmode, sim.jointdynctrl_velocity)\nsim.setObjectAlias(joint1_handle, \'joint1\')\n\n# 取得 cylinder 的位置座標\ndigit1_pos = sim.getObjectPosition(digit1_handle, -1)\njoint1_pos = [digit1_pos[0], digit1_pos[1], digit1_pos[2]]\n\n# 將 joint1 至於 cylinder 中心\nsim.setObjectPosition(joint1_handle, -1, joint1_pos)\n# 取得 digit1_handle 的方位\ndigit1_ori = sim.getObjectOrientation(digit1_handle, -1)\n# 將 joint1_handle 方位與 digit1 對齊\nsim.setObjectOrientation(joint1_handle, -1, digit1_ori)\n\n# 將 joint1 置於 box 上\nsim.setObjectParent(joint1_handle, box, True)\n# 將 cylinder 置於 joint1 上\nsim.setObjectParent(digit1_handle, joint1_handle, True)\n\n# 鎖定 joint1\nsim.setJointTargetForce(joint1_handle, float(\'inf\'))\n\nprint("基本場景建立完成!")\n\n# 載入加速度計模型\naccel_model_path = \'models/components/sensors/Accelerometer.ttm\'\naccel_handle = sim.loadModel(accel_model_path)\n\n# 確保加速度計在圓柱物件上\nsim.setObjectPosition(accel_handle, digit1_handle, [0, 0, x/2])\nsim.setObjectParent(accel_handle, digit1_handle, True)\n\n# 取得加速度計的句柄\n# 通常模型載入後的物件名稱是 \'Accelerometer\'\naccel_sensor_handle = sim.getObjectHandle(\'Accelerometer\')\n\n# 設定主迴圈\nwhile True:\n    # 設定 joint1 目標速度\n    sim.setJointTargetVelocity(joint1_handle, 10)\n\n    # 嘗試讀取加速度計的數據\n    # 使用 getObjectPosition 和 getObjectOrientation 來讀取加速度計數據\n    # 這僅僅是示例，你需要根據實際 API 文檔來確定如何讀取數據\n    position = sim.getObjectPosition(accel_sensor_handle, -1)\n    orientation = sim.getObjectOrientation(accel_sensor_handle, -1)\n    \n    # 根據感測器的數據進行處理，這裡僅為示例\n    print(f\'Accelerometer position: {position}\')\n    print(f\'Accelerometer orientation: {orientation}\')\n\n    # 讓 CoppeliaSim 有時間按照設定讓 joint1 旋轉\n    time.sleep(0.1)  # 增加延遲以便更穩定地讀取數據\n\n    if keyboard.is_pressed(\'q\'):\n        # 可以按下 q 鍵跳出重複執行迴圈\n        break\n\n# 終止模擬\nsim.stopSimulation()\n \n 上列 ZMQ Remote API Python 範例含 CoppeliaSim 4.7.0 rev4 程式庫:  zmq_remote_api_ex.7z \n \n cad2024_foosball_with_ball_python_script.7z \n 將上列採用 Python script 控制的手足球, 改為使用 ZMQ Remote API Python 執行控制: \n cad2024_foosball.7z \n Ball-Plate-Control:\xa0 https://github.com/mdecycu/Ball-Plate-Control \xa0', 'tags': '', 'url': 'CoppeliaSim.html'}, {'title': 'ZMQ', 'text': 'https://learning-0mq-with-pyzmq.readthedocs.io/en/latest/index.html \n ØMQ is a neat messaging library that allows you to build your own messaging infrastructure. ØMQ does not provide out of box messaging system experience like ActiveMQ or RabbitMQ. It is higher level concept than sockets and provides as low level conceptual framework as possible to build messaging systems. It can help build framework that scales where services could be handled by different applications that does one job well. \n Distributed applications are also easier to change compared to a monolithic applications. It’s expensive to try to define the behavior of each of many software applications that work together in a large network. It’s much cheaper, and more flexible, to define the interfaces between them: the APIs. Messaging is an API that can be stretched across a network. ØMQ 是一個精簡的訊息傳遞程式庫 (messaging library)，允許使用者自行建立訊息傳遞基礎架構。ØMQ 不像 ActiveMQ 或 RabbitMQ 那樣提供開箱即用的訊息系統體驗。ØMQ 是比封包更高層級的概念，同時提供了儘可能低階的概念框架來構建訊息傳遞系統。它能夠幫助構建可擴展的框架 (framework)，使得這個框架中，不同的服務可以由專注於單一任務的獨立應用程式來處理。 \n 與單一應用程式相比，分散式應用程式更容易更改。嘗試定義在大型網路中協同工作的眾多軟體應用程式的行為，其成本很高; 定義它們之間的介面（API）要便宜得多，也更靈活。使得訊息傳遞是一種可以跨網路擴展的 API。 \n 使用 pyzmq 建立程式範例: \n server: \n import zmq\nimport time\n\ncontext = zmq.Context()\nsocket = context.socket(zmq.REP)\nsocket.bind("tcp://*:5555")\n\ndef process_request(request):\n    # 模擬處理請求\n    time.sleep(1)\n    return f"已處理請求: {request}"\n\nprint("服務器已啟動，等待請求...")\n\nwhile True:\n    message = socket.recv_string()\n    print(f"收到請求: {message}")\n    \n    response = process_request(message)\n    \n    socket.send_string(response) \n client: \n import zmq\n\ncontext = zmq.Context()\nsocket = context.socket(zmq.REQ)\nsocket.connect("tcp://localhost:5555")\n\nfor request in range(5):\n    print(f"發送請求 {request}...")\n    socket.send_string(f"請求 {request}")\n    \n    response = socket.recv_string()\n    print(f"收到回覆: {response}") \n 上列採用 pyzmq 模組的程式組合，主要展示 ZMQ 程式庫在兩個應用程式間負責傳遞訊息，其特性如下: 1. 通訊介面： 伺服器端和客戶端之間透過 ZMQ 定義了一個簡單的通訊介面。雙方不需要了解對方的內部運作，只需知道如何發送和接收訊息。 2. 跨網路的應用程式介面（API）： 使用 ZMQ 建立了一個可以跨網路運作的 API。伺服器和客戶端程式可以在不同的電腦上執行，只要能夠透過網路連線即可傳遞訊息。 3. 彈性： 使用者可以輕鬆修改伺服器的內部邏輯（例如: 變更用來處理請求的函式設計），而不需要更動客戶端的程式碼。 同樣地，使用者也可以新增更多客戶端或甚至替換現有客戶端，只要客戶端程式遵循相同的訊息傳遞格式。 4. 成本效益： 定義這個簡單的訊息傳遞介面，比起詳細規劃每個應用程式的所有可能行為要簡單得多。 5. 可擴展性： 此一模型可以輕鬆擴展到更複雜的情境 (例如:新增多個伺服器、實現負載平衡等)，而基本的訊息傳遞模式可保持不變。 \n 另外一組範例，以解二階微分方程為例： \n y\'\' + p(x)y\' + q(x)y = f(x), with boundary conditions y(a) = α and y(b) = β \n 可將問題範圍分割成多個子區間，每個工作者負責解決一個子區間。 \n 首先，建立一個任務派送器： \n # task_dispatcher.py\nimport zmq\nimport numpy as np\nimport time\n\ndef task_dispatcher():\n    try:\n        context = zmq.Context()\n        task_sender = context.socket(zmq.PUSH)\n        task_sender.bind("tcp://127.0.0.1:5557")\n        print("Task sender bound to tcp://127.0.0.1:5557")\n\n        result_receiver = context.socket(zmq.PULL)\n        result_receiver.bind("tcp://127.0.0.1:5558")\n        print("Result receiver bound to tcp://127.0.0.1:5558")\n\n        print("Task dispatcher started. Waiting for workers to connect...")\n        time.sleep(1)  # 給工作者一些時間來連接\n        \n        # 定義問題參數\n        a, b = 0, 1  # 邊界\n        alpha, beta = 0, 1  # 邊界條件\n        N = 1000  # 總點數\n        num_workers = 4  # 工作者數量\n\n        h = (b - a) / (N - 1)  # 步長\n        x = np.linspace(a, b, N)\n\n        # 定義方程係數\n        def p(x): return 1\n        def q(x): return -2\n        def f(x): return np.exp(-x)\n\n        print("Dispatching tasks...")\n        # 分配任務\n        points_per_worker = N // num_workers\n        for i in range(num_workers):\n            start = i * points_per_worker\n            end = (i + 1) * points_per_worker if i < num_workers - 1 else N\n            task = {\n                \'worker_id\': i,\n                \'start\': start,\n                \'end\': end,\n                \'x\': x[start:end].tolist(),\n                \'h\': h,\n                \'p\': [p(xi) for xi in x[start:end]],\n                \'q\': [q(xi) for xi in x[start:end]],\n                \'f\': [f(xi) for xi in x[start:end]]\n            }\n            task_sender.send_pyobj(task)\n            print(f"Task sent to worker {i}")\n\n        print("All tasks dispatched. Waiting for results...")\n\n        # 收集結果\n        results = [None] * num_workers\n        for _ in range(num_workers):\n            result = result_receiver.recv_pyobj()\n            worker_id = result[\'worker_id\']\n            results[worker_id] = result[\'y\']\n            print(f"Received result from worker {worker_id}")\n\n        # 組合結果\n        y = np.concatenate(results)\n\n        # 應用邊界條件\n        y[0] = alpha\n        y[-1] = beta\n\n        print("Solution computed. First few values:", y[:5])\n        print("Last few values:", y[-5:])\n\n    except zmq.ZMQError as e:\n        print(f"ZMQ Error occurred: {e}")\n    except Exception as e:\n        print(f"An unexpected error occurred: {e}")\n\nif __name__ == "__main__":\n    task_dispatcher() \n 接著安排負責運算的 client 端程式: \n # worker.py\nimport zmq\nimport numpy as np\n\ndef solve_segment(x, h, p, q, f):\n    n = len(x)\n    A = np.zeros((n, n))\n    b = np.zeros(n)\n\n    # 設置三對角矩陣\n    for i in range(1, n-1):\n        A[i, i-1] = 1 - h * p[i] / 2\n        A[i, i] = -2 + h**2 * q[i]\n        A[i, i+1] = 1 + h * p[i] / 2\n        b[i] = h**2 * f[i]\n\n    # 設置邊界條件（這裡使用自然邊界條件）\n    A[0, 0] = A[-1, -1] = 1\n    A[0, 1] = A[-1, -2] = -1\n\n    return np.linalg.solve(A, b)\n\ndef worker(worker_id):\n    context = zmq.Context()\n    task_receiver = context.socket(zmq.PULL)\n    task_receiver.connect("tcp://localhost:5557")\n\n    result_sender = context.socket(zmq.PUSH)\n    result_sender.connect("tcp://localhost:5558")\n\n    print(f"Worker {worker_id} started. Waiting for task...")\n\n    task = task_receiver.recv_pyobj()\n    print(f"Worker {worker_id} received task")\n\n    x = np.array(task[\'x\'])\n    h = task[\'h\']\n    p = np.array(task[\'p\'])\n    q = np.array(task[\'q\'])\n    f = np.array(task[\'f\'])\n\n    y = solve_segment(x, h, p, q, f)\n\n    result = {\n        \'worker_id\': worker_id,\n        \'y\': y.tolist()\n    }\n    result_sender.send_pyobj(result)\n    print(f"Worker {worker_id} sent result")\n\nif __name__ == "__main__":\n    import sys\n    worker(int(sys.argv[1]) if len(sys.argv) > 1 else 0) \n 執行流程，先執行任務派送程式: \n python task_dispatcher.py \n 然後在不同的終端中運行多個工作者： \n python worker.py 0 python worker.py 1 python worker.py 2 python worker.py 3 \n 此一系統的工作原理: \n \n 任務派發器將整個問題域分割成幾個子區間。 \n 每個子區間的資料（包括 x 值、步長 h、方程式係數 p、q 和 f）被打包成一個任務，發送給工作者。 \n 每個工作者接收一個子區間的任務，使用有限差分法解決該子區間的方程。 \n 工作者將解決方案發送回任務派發器。 \n 任務派發器收集所有工作者的結果，將它們組合成完整的解，並應用邊界條件。 \n \n 這個例子展示了如何使用 pyzmq 來實現一個分散式計算系統，用於解決複雜的數值問題。它將一個大問題分解成多個小問題，利用多台機器或多個處理器並行計算，從而提高計算效率。 \n 注意：這個實現使用了自然邊界條件（Neumann邊界條件）來處理子區間的邊界。在實際應用中，可能需要根據具體問題調整邊界條件的處理方式。 \n Reference \n', 'tags': '', 'url': 'ZMQ.html'}, {'title': 'Python', 'text': '以 Python 為主的可攜程式環境架構: \n https://github.com/mdecycu/python_2025 \n 2024 Fall 開始採用的 python_2025.7z (5.2GB), 包含下列模組: \n 與 NX2406 配合的  Python310_pip_only.7z  (3.10.11 版) \n Python310_jupyter_notebook.7z \n Python310_jupyter_lab_collaborative.7z \n python_2025_batch_files.7z  (2.64KB) \n 下載 \xa0NX2406 可攜 CAD 壓縮檔案 (1.76 GB, 解開後約 9 GB) \n CoppeliaSim_Edu_4.7.0_rev4_for_2024Fall.7z  (190MB) \n homes_and_tmp.7z  (84MB) \n msys64_20240507.7z  (188MB) \n git_putty_python.7z  (559MB) \n sharex_wscite_wink3.7z  (44.2MB) \n solvespace_and_utilities.7z  (7.28MB) \n kmolab_ex.7z  (314MB) \n \n Python 3.12 版已經移除 distutils, 表示先前利用 MSYS2 編譯模組的 設定 , 已經不再適用: \n The entire  distutils  package is deprecated, to be removed in Python 3.12. Its functionality for specifying package builds has already been completely replaced by third-party packages  setuptools  and  packaging , and most other commonly used APIs are available elsewhere in the standard library (such as  platform ,  shutil ,  subprocess  or  sysconfig ). There are no plans to migrate any other functionality from  distutils , and applications that are using other functions should plan to make private copies of the code. Refer to  PEP 632  for discussion. \n The  bdist_wininst  command deprecated in Python 3.8 has been removed. The  bdist_wheel  command is now recommended to distribute binary packages on Windows. (Contributed by Victor Stinner in  bpo-42802 .) \n 若希望在 Windows 環境中利用 Visual Studio C++ 編譯 Python 模組, 可以下載\xa0  https://visualstudio.microsoft.com/zh-hant/visual-cpp-build-tools/  安裝後, 重新開機即可. \n 若要將 visual-cpp-build-tools 配置為可攜套件模組, 則可透過  https://github.com/Data-Oriented-House/PortableBuildTools  完成. \n nxopen_base_and_center_pole_python.txt \n split_pdf.py \n # pypdf2_split.py\n# pip install pypdf2 pycryptodome\nimport os\nfrom PyPDF2 import PdfWriter, PdfReader\n \npdfReader = PdfReader(open("parm.pdf", "rb"))\ninformation = [("151.pdf",1,300)]\n  \nfor page in range(len(information)):\n    pdf_writer = PdfWriter()\n    start = information[page][1]\n    end = information[page][2]\n    while start<=end:\n        pdf_writer.add_page(pdfReader.pages[start-1])\n        start+=1\n    if not os.path.exists("./"):\n        os.makedirs(savepath)\n    output_filename = \'{}_{}_page_{}.pdf\'.format(information[page][0],information[page][1], information[page][2])\n    with open(output_filename,\'wb\') as out:\n        pdf_writer.write(out)\nprint("已經完成 pdf 切割與存檔") \n combine_pdf.py \n # pip install pypdf2 pycryptodome\nimport os\nfrom PyPDF2 import PdfWriter, PdfReader\n \npdf_write_object = PdfWriter()\n \npdfFileNames = ["1.pdf", "2.pdf", "3.pdf"]\nnewFileName = "Programming_Process_in_NX_CAM_en"\nfilenameString = ""\n \nfor filename in pdfFileNames:\n    pdf_read_object = PdfReader(open(filename, "rb"))\n    filenameString += filename + ", "\n    for page in range(len(pdf_read_object.pages)):\n        pdf_write_object.add_page(pdf_read_object.pages[page])\n  \nfinal_file_object = open(newFileName + ".pdf", \'wb\')\npdf_write_object.write(final_file_object)\nfinal_file_object.close()\n \nprint("已經將 " + filenameString+ " 合併為: "+ newFileName + ".pdf") \n gen_python_3.10.11.py for NX2312 \n import urllib.request\nimport os\n   \ndir_path = os.path.dirname(os.path.realpath(__file__))\n# basic files for Python installation\n# before 3.12.0\npy_list = ["core", "dev", "exe", "lib", "tcltk", "tools"]\n# 3.12.1 no tools.msi\n#py_list = ["core", "dev", "exe", "lib", "tcltk"]\n# Python version 3.10.11 for NX2312\nversion = "3.10.11"\n# Python msi download URL\nftp = "https://www.python.org/ftp/python/" + version + "/amd64/"\n# location for Portable Python\npath = "y:\\\\tmp\\\\Python310"\n# create directory\ntry:\n    os.mkdir(path)\nexcept:\n    # path exists\n    pass\n# get Python installation msi files and extract into target dir\nfor i in py_list:\n    filename = i + ".msi"\n    url = ftp + filename\n    # download basic python msi file\n    urllib.request.urlretrieve(url, filename)\n    os.system("msiexec.exe /a " + i + ".msi targetdir=" + path)\n    # delete msi file\n    os.remove(dir_path + "\\\\" + i + ".msi")\n    os.remove(path + "\\\\" + i + ".msi")\n \n', 'tags': '', 'url': 'Python.html'}, {'title': 'Brython', 'text': '從 1 累加到 100: \n 1 add to 100 \n  導入 brython 程式庫  \n \n \n \n \n  啟動 Brython  \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n \n \n \n  add 1 to 100 開始  \n \n \n  add 1 to 100 結束 \n  editor1 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor1 結束   ##########################################  \n 從 1 累加到 100 part2: \n 1 add to 100 cango_three_gears BSnake AI Tetris Rotating Block \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  add 1 to 100 part2 開始  \n \n \n  add 1 to 100 part2 結束 \n  editor2 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor2 結束  \n \n \n', 'tags': '', 'url': 'Brython.html'}]};