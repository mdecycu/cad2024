var tipuesearch = {"pages": [{'title': 'About', 'text': 'Repo:  https://github.com/mdecycu/cad2024 \n Site:  https://mde.tw/cad2024 \n 協同倉儲:\xa0 \n 2a:\xa0 https://github.com/mdecad2024/pj-2a \xa0 \n 2b:\xa0 https://github.com/mdecad2024/pj-2b \xa0 \n 課程目標: \n 學習如何利用\xa0CAD 套件與 Python 程式協助執行機電整合系統設計 \n 課程教材: \n Intro_to_Mechatronics.pdf  ( Source ,  ref1 ,  ref2 ,  ref3 ,  ref4 ) \n Programming with Python for Engineers \n Teams 線上教學: \n 以 "學號@nfu.edu.tw" 登入  https://login.microsoftonline.com/  Office 365 \n Teams 團隊代碼:\xa07pg9z7u \n USB 隨身碟: \n 下載  python_2025_lite.7z  (428 MB, 解開壓縮後約 1.5 GB) \n IPv6 網路設定參考 \n CAD 套件:  Solvespace \xa0and\xa0 Siemens NX \n 下載  NX2312 可攜 CAD 壓縮檔案 (1.85 GB, 解開後約 9 GB) \n nx2312_Drafting.7z \n nx2312_nxplot.7z \n Blender4.2.7z \n 機電模擬:  CoppeliaSim \n 課程評分: \n 出席 (10%) - 自行舉證評分 \n Github Classroom 作業與隨堂考試 (60%) - 以 Github 帳號領取作業倉儲後, 建立包含操作流程影片與檔案下載的網頁 \n 期末口頭與書面專題報告 (30%) - 利用網頁內容進行簡報並提交 pdf 格式書面報告 \n \n 行事曆 \n  全頁檢視  \n', 'tags': '', 'url': 'About.html'}, {'title': 'links', 'text': '以下為修課學員的作業倉儲與網站連結: \n 2a site and repo \n 2b site and repo \n \n weekly check \n \n 2a: \n w7  |  w10 \xa0|  w11_hw \n \n 2b: \n w7 \xa0|  w10  |  w11_hw \n \n \n 列出 2a 已經建立標題為 w7 頁面的學員 \n 列出 2b 已經建立標題為 w7 頁面的學員 \n w8 上課前的 2a 學員 w7 頁面連結: \n 41223118_w7   41223133_w7   41223134_w7   41223136_w7 \n w8 上課前的 2b 學員 w7 頁面連結: \n 41023137_w7   41023155_w7   41223201_w7   41223202_w7   41223205_w7   41223206_w7   41223208_w7   41223209_w7   41223211_w7   41223216_w7   41223217_w7   41223218_w7   41223221_w7   41223222_w7   41223223_w7   41223224_w7   41223225_w7   41223226_w7   41223227_w7   41223230_w7   41223234_w7   41223235_w7   41223236_w7   41223237_w7   41223240_w7   41223242_w7   41223243_w7   41223244_w7   41223245_w7   41223246_w7   41223247_w7   41223249_w7   41223250_w7   41223251_w7 \n \n 上列學員的作業網站與倉儲連結資料, 取自  https://github.com/mdecycu/list  倉儲中各班名單的 Github Pages, 若學員的 Github 帳號有異動, 必須重新領取作業倉儲並透過 Pull Requests 加入或修改與本身學號對應的 Github 帳號. \n 學號與 Github 帳號間的分隔符號為 Tab, 也就是 \\t, Pull Requests 是一種允許任何 Github 使用者透過軟性且間接的方式, 提出修改任何公開倉儲中的任何資料. \n 所謂軟性, 意即針對任何公開倉儲, 雖然任何 Github 使用者, 都可以透過 Pull Requests 提議修改內容, 但是否將修改的內容合併入目標倉儲的決定權, 並不在提出 Pull Requests 的用戶, 而是掌握在對目標倉儲有直接修改權的 Github 用戶. \n 所謂間接, 指的是 Pull Requests 並非直接對目標倉儲的內容進行修改, 而是必須先登入 Github 帳號後, 連線到目標倉儲的網址, 然後透過 Fork 功能, 將目標倉儲"插"一份到自己的帳號下, 由於"插"回來的倉儲是位於自己的帳號下, 因此可以對 Forked 倉儲內容進行修改. \n 但是修改 Forked 倉儲內容之後, 必須透過建立 Pull Requests, 將此 PR 通報到目標倉儲, 然後再由目標倉儲的管理者決定是否接受此"拉回"合併的"請求". \n 上面所說明的所謂 Pull Requests 是希望從 Forked 倉儲的版本資料, 合併至目標倉儲, 其決定權在目標倉儲的管理者. 但另外一種使用情境則是, 當目標倉儲被某一使用者 Fork 之後, 目標倉儲的內容因為改版而變更後, 若先前 Forked 倉儲希望取得目標倉儲所進行的修改內容, 需要在建立所謂 Pull Requests 流程時的 URL, 將目標倉儲的管理者帳號與 Forked 倉儲用戶帳號對調, 要求執行所謂的"逆向" Pull Requests. \n 由於"逆向" Pull Requests 的合併, 是希望將目標倉儲的修改內容, 合併至 Forked 倉儲, 其決定權自然屬於 Forked 倉儲的用戶, 因此該用戶可以自行同意該"逆向" Pull Requests 的合併請求, 讓 Forked 倉儲的內容與目標倉儲保持同步.', 'tags': '', 'url': 'links.html'}, {'title': 'Site', 'text': '所謂" 基於瀏覽器的分散式版次管理與整合程式開發環境": \n \n 基於瀏覽器 ( Web Browser ) \n 分散式版次管理 ( Distributed Version Control ) \n 整合程式開發環境 ( Integrated Development Environment ) \n \n 分散式版次管理: \n \n 使用者可以在 多個不同地方  (不同電腦、不同平台或同一電腦的不同目錄) 維護同一個倉儲內容 \n 多名具維護權限的使用者, 可以有條不紊 協同維護 同一個倉儲內容 \n 每次維護均紀錄細節內容, 使用者可以切換或回復至先前的任一版本, 各版本的 資料比較不容易丟失 \n \n 本課程維護作業網站的方法: \n \n 利用作業倉儲中的 Codespaces (登入 Github 後, 記得查驗 Codespaces\xa0 Usage hours ) 進行維護 \n 利用 USB 或電腦中的可攜程式系統進行維護 \n \n 與 Codespaces 類似的服務: \n \n https://www.gitpod.io/pricing \xa0 \n https://codesandbox.io/pricing \xa0 \n \n Codespaces 使用方法請參考 這裡 \n 利用 USB 或電腦中的 可攜程式系統進行維護: \n \n 直接執行 USB 中的程式檔案 \n USB 僅存倉儲、相關設定與必要的認證檔案 \n \n \n Flask 啟動 https 連線可以採 adhoc 與使用 key.pem, cert.pem 等兩種方式, 其中採 key.pem, cert.pem 的執行無需每次連線都生成數位簽章, 因此速度較快. \n cert.pem 與 key.pem 可以利用可攜程式中的 openssl.exe 建立: \n openssl req -newkey rsa:2048 -new -nodes -x509 -days 3650 -keyout key.pem -out cert.pem \n 放入倉儲根目錄, 並修改 cmsimde 目錄中的 wsgi.py: \n #!/usr/bin/python\n\n"""Flask startup script\n"""\n\nimport sys\nimport os\nsys.path.append(os.path.join(os.path.dirname(__file__)))\n# import flaskapp at the same directory\nimport flaskapp\n\n# get uwsgi, ip and port variable values of flaskapp.py\nuwsgi = flaskapp.uwsgi\nip = flaskapp.ip\nport = flaskapp.dynamic_port\n\nif uwsgi:\n    # run on remote site\n    application = flaskapp.app\nelse:\n    # on localhost, on Linux or Mac need to use python3 wsgi.py to execute\n    #flaskapp.app.run(host=ip, port=port, debug=True, ssl_context="adhoc")\n    flaskapp.app.run(host=ip, port=port, debug=True, ssl_context=(\'cert.pem\', \'key.pem\')) \n 此外, 為了加快 USB 中編輯動態網站與生成靜態網站的速度, 可以每次啟動電腦後下載 python_2025_lite.7z 後解開至 C:\\, 使用 batch file 執行如下: \n @echo off\n\nREM 下載 python_2025_lite.7z\n\ncurl --user kmolab:kmolab --output C:\\Users\\%USERNAME%\\Downloads\\python_2025_lite.7z "http://229.cycu.org/python_2025_lite.7z"\n\nREM 解開壓縮檔案至 C:\\\n\n"C:\\Program Files\\7-Zip\\7z" x C:\\Users\\%USERNAME%\\Downloads\\python_2025_lite.7z -oC:\\ -y \n 並僅將 SSH 認證檔案、額外安裝的 Python 模組與 Github 倉儲放在 USB 隨身碟, 其餘執行檔案則使用 C:\\ 固態硬碟中下載或既有的檔案, 以加快執行速度, 其對應的啟動批次檔案 start_ipv6_hybrid.bat 如下: \n @echo off\nset Disk=y\nsubst %Disk%: "data"\n\n%Disk%:\n\nREM 請先將 python_2025_lite 下載到 C:\\\nREM 除了個人作業倉儲與  ssh key 之外, 其他執行都使用 C:\\ 中的檔案\nset Local=C:\\python_2025_lite\\data\nREM for cadlab\nREM set NX_location="C:\\Program Files\\Siemens\\NX2312"\nset NX_location=E:\\NX2312_CAD\n\nREM python 執行將使用 C:\\, 但是額外的 Python 模組將存至隨身碟\nREM pip install <package> --target  Y:\\extra_python_modules, 但必須將此額外模組路徑納入 PYTHONPATH\n\nset HomePath=%Disk%:\\home_ipv6\nset HomeDrive=%Disk%:\\home_ipv6\nset Home=%Disk%:\\home_ipv6\nset USERPROFILE=%Disk%:\\home_ipv6\n\nREM 將系統 Python 程式的 io 設為 utf-8\nset PYTHONIOENCODING="utf-8"\n\nset PYTHONPATH=%Local%\\Python310\\DLLs;%Local%\\Python310\\Lib;%Local%\\Python310\\Lib\\site-packages;%NX_location%\\NXBIN\\python;%Disk%:\\extra_python_modules;\nset PYTHONHOME=%Local%\\Python310\n\nREM for putty\nset GIT_SSH=%Local%\\PuTTY\\plink.exe\n\nREM for Java and Android SDK\nset java_home=%Local%\\java\\jdk8u222-b10\nset ANDROID_SDK_home=%Local%\\home_ipv6\nset GRADLE_USER_home=%Local%\\home_ipv6\nset ANDROID_SDK_ROOT=%Local%\\android\\sdk\nset ANDROID_Home=%Local%\\android\\sdk\nset REPO_OS_OVERRIDE=windows\n\nREM 設定跟 Python 有關的命令搜尋路徑\nset path_python=%Local%\\Python310;%Local%\\Python310\\Scripts;\nREM 設定跟Git 有關的命令搜尋路徑\nset path_git=%Local%\\portablegit\\bin;\nREM 設定 msys2 64 位元的執行路徑\nset path_msys2=%Local%\\msys64\\ucrt64\\bin;\nREM set for LaTeX\nset path_miketex=%Local%\\miktex-portable\\texmfs\\install\\miktex\\bin\\x64;\nREM Flutter path\nset path_flutter=%Local%\\flutter\\bin;%java_home%\\bin;%Local%\\Android\\sdk;%Local%\\Android\\sdk\\tools;%Local%\\Android\\sdk\\tools\\bin;%Local%\\Android\\sdk\\emulator;%Local%\\Android\\sdk\\platform-tools;%Local%\\flutter\\bin\\cache\\dart-sdk\\bin;%Local%\\vscode;\nset path_node=%Local%\\node-v14.15.4-win-x64;\n\nset path_postgresql=%Local%\\postgresql13\\bin;\nset path_range=%Local%\\Range3_official\\bin;\nrem set path_range=%Local%\\range-3.2.5_kmol\\bin;\nset path_lua=%Local%\\lua-5.3.5\\;\nset path_core=%Local%\\coreutils-5.3.0\\bin;\nREM for gogs\nset path_putty=%Local%\\PuTTY;\nset path_vscode=%Local%\\vscode;\n\nREM for Rust\nset MINGW_PATH=%path_msys2%;\nset GIT_PATH=%path_git%;\nset VSCODE_PATH=%path_vscode%\nset RUSTUP_HOME=%Local%\\Rust\\rust\nset CARGO_HOME=%Local%\\Rust\\cargo\nset RUST_PATH=%CARGO_HOME%\\bin\n\nREM for Erlang and Elixir\nset path_erlang=%Local%\\elixir\\erl10.7\\bin\\;%Local%\\elixir\\erl10.7\\erts-10.7\\bin;%Local%\\elixir\\elixir\\bin;\nset ERTSPATH=%Local%\\elixir\\erl10.7\\erts-10.7\\bin\nset ERLINI=%Local%\\elixir\\erl10.7\\erts-10.7\\bin\\erl.ini\n\nREM for Haskell\nset path_haskell=%Local%\\ghc-9.0.1-x86_64-unknown-mingw32\\bin;\nREM for node.js\nset path_nodejs=%Local%\\node-v14.17.2-x64\\nodejs;%Local%\\node-v14.17.2-x64\\nodejs\\node_modules\\npm;\n\nREM 加入 PostgreSQL 所需的環境變數設定\n\n@SET PGDATA=%Local%\\postgresql13\\data\n@SET PGDATABASE=postgres\n@SET PGUSER=postgres\n@SET PGPORT=5432\n@SET PGLOCALEDIR=%Local%\\postgresql13\\share\\locale\n\nREM for Range3\nREM REG IMPORT %Local%\\range3.reg\n\nREM proxy needed for heroku login\nREM proxy can not use with fossil scm\nREM proxy can not use with Rust installation\nREM needed for node.js\nREM set HTTP_PROXY=http://[2001:288:6004:xx::42]:3128\nREM set HTTPS_PROXY=http://[2001:288:6004:xx::42]:3128\n\nREM for PyRep\nset VREP_PATH=%Local%\\CoppeliaSim\n\nREM BOOST_ROOT for compiling coppeliasim but maybe not for linking\nREM set BOOST_ROOT=%Local%\\boost_1_76_0\\;\nset path_copsim=%Local%\\boost_1_76_0\\;%Local%\\Strawberry\\perl\\bin;%Local%\\cmake-3.21.0-windows-x86_64\\bin;%Local%\\diffutils-2.8.7-1\\bin;%Local%\\patch-2.5.9-7\\bin;%D%:\\jom_1_1_2;%Local%\\LLVM\\bin;%Local%\\QtCreator\\bin;%Local%\\CoppeliaSimEdu;%Local%\\Python310\\tcl\\tcl8.6;\n\nREM for CMake\nset CMAKE_C_COMPILER=%Local%\\msys64\\ucrt64\\bin\\gcc;\nset CMAKE_CXX_COMPILER=%Local%\\msys64\\ucrt64\\bin\\g++;\n\nREM set QT_QPA_PLATFORM_PLUGIN_PATH=Y:\\msys64_20240507\\mingw64\\share\\qt5\\plugins\\platforms\nREM set QT_PLUGIN_PATH=Y:\\msys64_20240507\\mingw64\\share\\qt5\\plugins\n\nREM for execute scite directly\nset path_scite=%Local%\\wscite\\;\n\nREM for simExtZMQ\nset path_xsltproc=%Local%\\xsltproc;\n\nREM for OpenSSL\nSet OPENSSL_CONF=%Local%\\OpenSSL-Win64\\SSL\\openssl.cnf\nset path_openssl=%Local%\\OpenSSL-Win64\\bin;\n\npath=%Local%;%path_python%;%path_git%;%path_copsim%;%path_msys2%;%path_miketex%;%path_flutter%;%path_node%;%path_tcc%;%path_postgresql%;%path_range%;%path_lua%;%path_core%;%path_putty%;%path_vscode%;%RUST_PATH%;%path_erlang%;%path_nodejs%;%path_haskell%;%path_scite%;%path_xsltproc%;%path_gnuplot%;%path_openssl%;%path%;\n\nREM for NX2312, must after path setup \nset SPLM_LICENSE_SERVER=29000@192.168.56.3\nset UGII_LANG=english\nset UGS_LICENSE_BUNDLE=ACD11,ACD10\nset UGII_BASE_DIR=%NX_location%\nset UGII_TMP_DIR=%Local%\\tmp\nset UGII_LIB_PATH=%NX_location%\\NXBIN\\python\nset ugii=%NX_location%\\ugii;%NX_location%\\nxbin;\npath = %ugii%;%path%\nREM Xcopy %Local%\\home_ipv6\\AppData\\Local\\Siemens\\NX2312 C:\\users\\%USERNAME%\\AppData\\Local\\Siemens\\NX2312 /E /H /C /I /Y\n\nREM start ugraf -nx\n\nREM python %Local%\\tmp\\nx_ex\\new_part.py\n\nstart /MIN cmd.exe\nstart /MIN cmd.exe\nstart /MIN cmd.exe\nstart /MIN cmd.exe\n\nstart /MIN %Local%\\wscite\\SciTE.exe\nstart /MIN %Local%\\wscite\\SciTE.exe\n\n\nExit\n \n \n', 'tags': '', 'url': 'Site.html'}, {'title': 'Pages', 'text': '以下說明課程網頁各頁面的相關內容: \n About \n 課程網站的倉儲與連結, 課程目標與教材, Team code, 評分標準, 可攜下載 (Python and NX2312), Schedule 等. \n 機電整合教材, 主要介紹機電整合流程相關英文術語. \n links : \n 所有學員的作業倉儲與網頁連結 (利用  Brython  與  list  產生), Pull Requests 用法說明. \n Site : \n 說明如何啟動可攜程式環境, 如何在雲端與近端維護作業網站. \n', 'tags': '', 'url': 'Pages.html'}, {'title': 'Evaluate', 'text': '網頁內容評分: 用來評量受評者的作業網頁內容, 是否完整且充實 \n 操作影片評分: 用來評量受評者所提供的操作影片內容, 是否說明清楚, 提供字幕且完整呈現標的內容 \n 倉儲提交說明: 用來評量受評者所提供的倉儲提交說明是否清楚, 以及提交次數及頻率, 是否足以證明其用功程度 \n 下載檔案評分: 用來評量受評者在作業網頁上所提供的檔案下載內容, 是否完整且內容充實 \n 作業心得評分: 用來評量受評者的作業心得是否內容豐富, 且值得令人讚賞與學習 \n \n 以上各分項評分各佔 20%, 評分基準如下: \n 非常棒 - 得 20 分 (即一百分, 表現非常棒且完美的評分) \n 很棒 - 得 18 分 (即九十分, 表現很棒的的評分) \n 很好 - 得 16 分 (即八十分, 表現很好的評分) \n 還可以 - 得 14 分 (即七十分, 表現還可以的評分) \n 及格 - 得 12 分 (即六十分, 表現算是及格的評分) \n 需加強 - 得 10 分 (即五十分, 需要再加強的評分) \n', 'tags': '', 'url': 'Evaluate.html'}, {'title': 'Jupyter', 'text': "USB 隨身碟: \n 下載  python_2025_lite.7z  (428 MB, 解開壓縮後約 1.5 GB) \n 利用 Jupyter 建立 .ipynb 格式的 notebook 檔案: \n \n 以 start_ipv6.bat 開啟隨身碟中的可攜程式環境 \n 在命令列視窗中, 輸入 jupyter lab --collaborative 後可在瀏覽器中開啟 Jupyter lab \n 系統內定以執行 jupyter lab --collaborative 指令所在目錄作為根目錄 \n Jupyter lab 的伺服器 ip 設定位於 home_ipv6\\.jupyter\\jupyter_server_config.py 檔案中的 c.ServerApp.ip 變數, 內定為 localhost, 使用者可以自行修改為電腦連外 IPv4 或 IPv6 位址 \n home_ipv6\\.jupyter\\jupyter_server_config.py 檔案中的 c.ServerApp.port = 8888 為內定連線埠號 \n 系統內定使用 http 連線, 使用者可利用 openssl 建立 cert.pem 與 key.pem, 並與 c.ServerApp.certfile 及c.ServerApp.keyfile 等系統變數綁定後, 使用 https 連線 \n 若希望讓其他用戶透過網路進行協同編輯, 可從命令列視窗中, 輸入 jupyter server list 取得登入所需的 token, 或將設定修改為使用者自訂的密碼登入 \n 各 Jupyter lab 用戶可從左方的 Collaboration 頁面中檢視參與協同者的名單 \n 使用結束後, 以 File - Shutdown 關閉 Jupyterlab \n \n 利用 openssl 指令建立 cert.pem 與 key.pem: \n openssl req -newkey rsa:2048 -new -nodes -x509 -days 3650 -keyout key.pem -out cert.pem \n 使用 https 連線時, cert.pem 與 key.pem 設定: \n c.ServerApp.certfile = u'y:\\home_ipv6\\.jupyter\\cert.pem' \n c.ServerApp.keyfile = u'y:\\home_ipv6\\.jupyter\\key.pem' \n", 'tags': '', 'url': 'Jupyter.html'}, {'title': 'Mechatronics', 'text': '機電整合 (Mechatronics) 一詞將機械 (mecha) 和電子 (tronics) 結合在一起。意即在產品的設計與製造流程中，將機械工程、電子技術和智能計算機控制的相關技術加以結合。機電整合產品經常利用電子元件取代傳統的機械功能，從而 實現更大的靈活性、更簡單的重新設計與重新編程，並提升自動化數據收集與報告生成的能力 。 \n Mechatronics was created by Ko Kikuchi, the former president of the Yasakawa Electric Company ( 安川電機 ), who introduced the term in 1969 as a trademark for devices that combined mechanics and electronics. The term "mechatronics" was coined by Tetsuro Mori and was trademarked by Yasakawa Electric Corporation from 1971 to 1982. The discipline of mechatronics emerged as a new engineering discipline in the late twentieth century, combining mechanical engineering and electronics. The evolution of mechatronics can be traced back to the gradual addition of electronics, computer controls, and software to electromechanical products. Mechatronics is an interdisciplinary field that integrates mechanics, electronics, computing, control techniques, and artificial intelligence to create new value in equipment and systems. ( source ) \n https://github.com/s40723210/cd2020/tree/master/downloads \xa0 \n 40723210_2020.7z \n https://github.com/s40723221/cd2020/tree/master/downloads \xa0 \n 機電整合未來發展與挑戰 \xa0( version 2 ) \n 40723221_2020.7z \n https://www.20sim.com/downloads/files/20sim.exe \n https://openmodelica.org/download/download-windows/ \n', 'tags': '', 'url': 'Mechatronics.html'}, {'title': 'Servers', 'text': 's104.cycu.org 是一台可讓使用者存放零組件 STL 檔案的伺服器: \n 每一位學員都將透過"學號@nfu.edu.tw"收到 sftp 檔案至此一主機的帳號與密碼. \n 帳號為各學員的學號 \n 密碼則可從通知信中查詢 \n sftp 指令: \n 請在近端先將目錄切換至要上傳 STL 檔案的所在目錄, 例如: STL 零件檔案位於 C:\\tmp 目錄: \n 假設使用者的學號為 1234, 此學號代碼即為帳號 \n C: \n cd \\tmp \n C:\\tmp>sftp  1234@s104.cycu.org \n 1234@s104.cycu.org\'s password: \n 輸入對應密碼後: \n Connected to s104.cycu.org. sftp> pwd Remote working directory: /C:/Users/1234.DESKTOP-BAEUNSD sftp> cd .. sftp> cd 1234 sftp> pwd Remote working directory: /C:/Users/1234 sftp> cd public_html sftp> put 1234_lesson2_solvespace.stl Uploading 1234_lesson2_solvespace.stl to /C:/Users/1234/public_html/1234_lesson2_solvespace.stl 1234_lesson2_solvespace.stl \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 100%\xa0 32KB\xa0 45.1MB/s\xa0\xa0 00:00 sftp> \n 上傳結束後, 便可從 https://s104.cycu.org/~1234/1234_lesson2_solvespace.stl 擷取此一檔案. 假設學員學號為 1234 的 Github 帳號也是 1234, 則能夠直接在其作業網站上瀏覽此一 STL 零件檔案的連結將會是: \n https://mdecad2024.github.io/hw-1234/cmsimde/static/viewstl.html?src=https://s104.cycu.org/~1234/1234_lesson2_solvespace.stl \n \n', 'tags': '', 'url': 'Servers.html'}, {'title': 'Codespaces', 'text': '利用 Codespaces 維護課程網站的步驟: \n \n chmod u+x init_replit \n ./init_replit \n python main.py\xa0 \n 開啟轉址後的瀏覽器, 以內建密碼 admin 登入進行網站內容編輯 \n 動態網頁內容編輯告一段落後, 利用 Convert 功能將動態內容轉為靜態網站資料 \n 檢查轉靜態之後的網頁內容, python main2.py 執行後, 開啟瀏覽器觀看靜態網站內容 \n 利用 chmod u+x acp 讓 user 可以執行 acp script\xa0 \n 最後利用 Shell, 以  ./acp "輸入提交註記說明字串"  完成 git add, git commit -m 與 git push, 將動態與靜態網站內容送到對應的倉儲中 \n 由於目前 Codespaces 只允許免費帳號每月使用 120 core hours, 若採 2 cores 機器, 每月僅能使用 60 小時. \n 登入 Github 後, 可至\xa0 https://github.com/settings/billing/summary \xa0頁面中的 Codespaces 查核已經使用的 Usage hours. \n \n main.py: \n from cmsimde import flaskapp\nfrom gevent.pywsgi import WSGIServer\n\n#flaskapp.app.run(host="0.0.0.0", debug=True)\nhttp_server = WSGIServer((\'0.0.0.0\', 8080), flaskapp.app)\nhttp_server.serve_forever() \n main2.py: \n # Run static server\nimport static\nfrom gevent.pywsgi import WSGIServer\n\nhttp_server = WSGIServer((\'0.0.0.0\', 8081), static.app)\nhttp_server.serve_forever() \n 以及與 main2.py 結合使用的 static.py: \n from flask import Flask, send_from_directory\n\napp = Flask(__name__)\n\n# Route to serve the index.html file\n@app.route(\'/\')\ndef index():\n    return send_from_directory(\'.\', \'index.html\')\n\n# Route to serve static files from the ./cmsimde/static directory\n@app.route(\'/cmsimde/static/<path:filename>\')\ndef serve_static(filename):\n    return send_from_directory(\'cmsimde/static\', filename)\n\n# Route to serve other HTML files from the root directory\n@app.route(\'/<path:filename>\')\ndef serve_html(filename):\n    return send_from_directory(\'.\', filename)\n\nif __name__ == \'__main__\':\n    app.run(debug=True)\n \n', 'tags': '', 'url': 'Codespaces.html'}, {'title': 'Project', 'text': '已知: \n \n 修課學員經由 @nfu.edu.tw 網域, 可利用"學號@nfu.edu.tw"經由  https://login.microsoftonline.com/  登入 MS 365. \n 登入後, 使用者可以利用" 應用程式註冊 "建立應用程式 \n 所註冊的延伸應用程式則可以利用 Microsoft Online 主機所提供的 OAuth2 API 程式庫, 取得登入者的 profile \n 經由上列步驟取得登入者的 profile 後, 延伸應用程式可設法讀取課程學員的作業倉儲與網站連結 \n 當每一階段的學員作業網頁完成後, 若再經由亂數方法, 隨機分配給每一位學員 10 個除自己以外的學員作業網站進行評分, 即可根據既定的評分基準完成自評 \n 隨機分配的學員作業網址可利用 email 寄出, 而評分回報則可利用 MS 365 的 Forms 表單取回 \n \n 以下為上列流程的 step 1 測試程式 ( teams_oauth2_flask_py.txt ): \n from flask import Flask, redirect, request, session, url_for\nimport requests\nimport json\n\napp = Flask(__name__)\napp.secret_key = \'your_secret_key\'  # 用於 Flask session 的秘密金鑰\n\n# 替換成你的 Azure AD 應用程式資訊\n\'\'\'\nCLIENT_ID 為"應用程式 (用戶端) 識別碼"\nCLIENT_SECRET 則為"憑證及秘密"中"用戶端密碼"的"值"\n\'\'\'\nCLIENT_ID = \'id\'\nCLIENT_SECRET = \'secret\'\nTENANT_ID = \'id\'\nAUTHORITY = f\'https://login.microsoftonline.com/{TENANT_ID}\'\nREDIRECT_URI = \'http://localhost:8000/callback\'\nSCOPE = \'User.Read\'\n\n# 用於登錄和取得授權碼\n@app.route(\'/\')\ndef index():\n    auth_url = (f\'{AUTHORITY}/oauth2/v2.0/authorize\'\n                f\'?client_id={CLIENT_ID}\'\n                f\'&response_type=code\'\n                f\'&redirect_uri={REDIRECT_URI}\'\n                f\'&response_mode=query\'\n                f\'&scope={SCOPE}\')\n    return redirect(auth_url)\n\n# 處理回調和交換授權碼\n@app.route(\'/callback\')\ndef callback():\n    code = request.args.get(\'code\')\n    token_url = f\'{AUTHORITY}/oauth2/v2.0/token\'\n    token_data = {\n        \'grant_type\': \'authorization_code\',\n        \'code\': code,\n        \'redirect_uri\': REDIRECT_URI,\n        \'client_id\': CLIENT_ID,\n        \'client_secret\': CLIENT_SECRET,\n        \'scope\': SCOPE\n    }\n    token_r = requests.post(token_url, data=token_data)\n    token_r.raise_for_status()\n    tokens = token_r.json()\n    session[\'access_token\'] = tokens[\'access_token\']\n    return redirect(url_for(\'profile\'))\n\n# 使用訪問令牌呼叫 Microsoft Graph API 來獲取用戶資料\n@app.route(\'/profile\')\ndef profile():\n    access_token = session.get(\'access_token\')\n    if not access_token:\n        return redirect(url_for(\'index\'))\n\n    headers = {\n        \'Authorization\': f\'Bearer {access_token}\',\n        \'Content-Type\': \'application/json\'\n    }\n    graph_url = \'https://graph.microsoft.com/v1.0/me\'\n    graph_r = requests.get(graph_url, headers=headers)\n    graph_r.raise_for_status()\n    user_info = graph_r.json()\n    user_email = str(user_info["mail"])\n    user_id = user_email.split("@")[0]\n    session["user_id"] = user_id\n    # 登出 MS Online 並重定向回首頁\n    # 返回 HTML 及 JavaScript 以進行自動登出\n    return (f\'Hello, {user_id} <br>\'\n            f\'<script type="text/javascript">\'\n            f\'  window.location = "https://login.microsoftonline.com/common/oauth2/v2.0/logout";\'\n            f\'</script>\')\n\n@app.route(\'/userid\')\ndef userid():\n    return session["user_id"]\n    \n\n# 登出功能\n@app.route(\'/logout\')\ndef logout():\n    # 清除 session 中的訪問令牌\n    session.pop(\'access_token\', None)\n    # 重定向到 MS Online 登出 URL\n    return redirect(\'https://login.microsoftonline.com/common/oauth2/v2.0/logout\')\n\nif __name__ == \'__main__\':\n    app.run(debug=True, port=8000)\n \n 以下則為寄信範例: \n import requests\nimport json\n\n# 替換為你的應用程式資訊\nCLIENT_ID = \'your_client_id\'\nCLIENT_SECRET = \'your_client_secret\'\nTENANT_ID = \'your_tenant_id\'\nAUTHORITY = f\'https://login.microsoftonline.com/{TENANT_ID}\'\nTOKEN_URL = f\'{AUTHORITY}/oauth2/v2.0/token\'\nSCOPE = \'https://graph.microsoft.com/.default\'\n\n# 獲取 OAuth2 訪問令牌\ndef get_access_token():\n    token_data = {\n        \'grant_type\': \'client_credentials\',\n        \'client_id\': CLIENT_ID,\n        \'client_secret\': CLIENT_SECRET,\n        \'scope\': SCOPE\n    }\n    token_r = requests.post(TOKEN_URL, data=token_data)\n    token_r.raise_for_status()\n    tokens = token_r.json()\n    return tokens[\'access_token\']\n\n# 發送電子郵件\ndef send_email(access_token, to_address, subject, body):\n    headers = {\n        \'Authorization\': f\'Bearer {access_token}\',\n        \'Content-Type\': \'application/json\'\n    }\n    email_data = {\n        "message": {\n            "subject": subject,\n            "body": {\n                "contentType": "Text",\n                "content": body\n            },\n            "toRecipients": [\n                {\n                    "emailAddress": {\n                        "address": to_address\n                    }\n                }\n            ]\n        },\n        "saveToSentItems": "true"\n    }\n    email_url = \'https://graph.microsoft.com/v1.0/me/sendMail\'\n    response = requests.post(email_url, headers=headers, json=email_data)\n    response.raise_for_status()\n    print("Email sent successfully!")\n\nif __name__ == "__main__":\n    token = get_access_token()\n    send_email(token, \'recipient@example.com\', \'Test Subject\', \'This is the email body.\')\n \n \n 以下利用 ChatGPT 4omini 進行對話: \n 問: \n 使用 python + flask 開發一個簡單的資料庫程式, 並使用 SQLite, 目前表單有使用者學號以及其 github 帳號, 還有一個備註欄位, 只需要 add, query, update 與 delete 功能, 該如何進行? \n 答: \n 1. 安裝 Flask 和 SQLite 首先，確保你已經安裝了 Flask 和 SQLite。如果你還沒有安裝，請使用以下命令： \n pip install Flask\n \n SQLite 通常已經隨 Python 安裝，不需要額外安裝。如果你需要 SQLite 的 Python 模組，可以使用以下命令： \n pip install sqlite3\n \n 2. 建立 Flask 應用程式 \n 應用程式結構 \n flask_app/\n│\n├── app.py\n├── schema.sql\n└── templates/\n    ├── index.html\n    ├── add.html\n    ├── update.html\n    └── query.html\n \n schema.sql — 定義 SQLite 資料表 在 schema.sql 文件中，定義 SQLite 資料表結構： \n CREATE TABLE IF NOT EXISTS users (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    student_id TEXT NOT NULL UNIQUE,\n    github_account TEXT NOT NULL,\n    notes TEXT\n);\n \n app.py — Flask 應用程式 在 app.py 中，設置 Flask 應用程式並建立 CRUD 功能： \n from flask import Flask, request, redirect, url_for, render_template\nimport sqlite3\n\napp = Flask(__name__)\n\nDATABASE = \'database.db\'\n\ndef get_db():\n    conn = sqlite3.connect(DATABASE)\n    conn.row_factory = sqlite3.Row\n    return conn\n\ndef init_db():\n    with app.app_context():\n        db = get_db()\n        with open(\'schema.sql\', \'r\') as f:\n            db.executescript(f.read())\n        db.commit()\n\n@app.route(\'/\')\ndef index():\n    return render_template(\'index.html\')\n\n@app.route(\'/add\', methods=[\'GET\', \'POST\'])\ndef add_user():\n    if request.method == \'POST\':\n        student_id = request.form[\'student_id\']\n        github_account = request.form[\'github_account\']\n        notes = request.form.get(\'notes\', \'\')\n\n        db = get_db()\n        db.execute(\'INSERT INTO users (student_id, github_account, notes) VALUES (?, ?, ?)\',\n                   (student_id, github_account, notes))\n        db.commit()\n        return redirect(url_for(\'index\'))\n\n    return render_template(\'add.html\')\n\n@app.route(\'/update/<int:user_id>\', methods=[\'GET\', \'POST\'])\ndef update_user(user_id):\n    db = get_db()\n    if request.method == \'POST\':\n        student_id = request.form[\'student_id\']\n        github_account = request.form[\'github_account\']\n        notes = request.form.get(\'notes\', \'\')\n\n        db.execute(\'UPDATE users SET student_id = ?, github_account = ?, notes = ? WHERE id = ?\',\n                   (student_id, github_account, notes, user_id))\n        db.commit()\n        return redirect(url_for(\'index\'))\n\n    user = db.execute(\'SELECT * FROM users WHERE id = ?\', (user_id,)).fetchone()\n    return render_template(\'update.html\', user=user)\n\n@app.route(\'/delete/<int:user_id>\')\ndef delete_user(user_id):\n    db = get_db()\n    db.execute(\'DELETE FROM users WHERE id = ?\', (user_id,))\n    db.commit()\n    return redirect(url_for(\'index\'))\n\n@app.route(\'/query\')\ndef query_users():\n    db = get_db()\n    users = db.execute(\'SELECT * FROM users\').fetchall()\n    return render_template(\'query.html\', users=users)\n\nif __name__ == \'__main__\':\n    init_db()\n    app.run(debug=True)\n \n templates/index.html \n <!DOCTYPE html>\n<html>\n<head>\n    <title>Index</title>\n</head>\n<body>\n    <h1>Welcome to User Management</h1>\n    <a href="{{ url_for(\'add_user\') }}">Add User</a> |\n    <a href="{{ url_for(\'query_users\') }}">Query Users</a>\n</body>\n</html>\n \n templates/add.html \n <!DOCTYPE html>\n<html>\n<head>\n    <title>Add User</title>\n</head>\n<body>\n    <h1>Add User</h1>\n    <form action="{{ url_for(\'add_user\') }}" method="post">\n        <label for="student_id">Student ID:</label>\n        <input type="text" id="student_id" name="student_id" required><br>\n        <label for="github_account">GitHub Account:</label>\n        <input type="text" id="github_account" name="github_account" required><br>\n        <label for="notes">Notes:</label>\n        <textarea id="notes" name="notes"></textarea><br>\n        <input type="submit" value="Add">\n    </form>\n    <a href="{{ url_for(\'index\') }}">Back</a>\n</body>\n</html>\n \n templates/update.html \n <!DOCTYPE html>\n<html>\n<head>\n    <title>Update User</title>\n</head>\n<body>\n    <h1>Update User</h1>\n    <form action="{{ url_for(\'update_user\', user_id=user[\'id\']) }}" method="post">\n        <label for="student_id">Student ID:</label>\n        <input type="text" id="student_id" name="student_id" value="{{ user[\'student_id\'] }}" required><br>\n        <label for="github_account">GitHub Account:</label>\n        <input type="text" id="github_account" name="github_account" value="{{ user[\'github_account\'] }}" required><br>\n        <label for="notes">Notes:</label>\n        <textarea id="notes" name="notes">{{ user[\'notes\'] }}</textarea><br>\n        <input type="submit" value="Update">\n    </form>\n    <a href="{{ url_for(\'index\') }}">Back</a>\n</body>\n</html>\n \n templates/query.html \n <!DOCTYPE html>\n<html>\n<head>\n    <title>Query Users</title>\n</head>\n<body>\n    <h1>Users</h1>\n    <table>\n        <tr>\n            <th>ID</th>\n            <th>Student ID</th>\n            <th>GitHub Account</th>\n            <th>Notes</th>\n            <th>Actions</th>\n        </tr>\n        {% for user in users %}\n        <tr>\n            <td>{{ user[\'id\'] }}</td>\n            <td>{{ user[\'student_id\'] }}</td>\n            <td>{{ user[\'github_account\'] }}</td>\n            <td>{{ user[\'notes\'] }}</td>\n            <td>\n                <a href="{{ url_for(\'update_user\', user_id=user[\'id\']) }}">Update</a> |\n                <a href="{{ url_for(\'delete_user\', user_id=user[\'id\']) }}">Delete</a>\n            </td>\n        </tr>\n        {% endfor %}\n    </table>\n    <a href="{{ url_for(\'index\') }}">Back</a>\n</body>\n</html>\n \n 3. 啟動應用程式 確保你的 Flask 應用程式和模板文件已經正確配置，然後啟動應用程式： \n python app.py\n \n 接下來, 可以在瀏覽器中訪問  http://127.0.0.1:5000/  來查看和管理你的資料。 \n', 'tags': '', 'url': 'Project.html'}, {'title': 'Topics', 'text': "HW Template: \n https://github.com/mdecad2024/hw-mdecycu \n https://mdecad2024.github.io/hw-mdecycu \n \n Topic 1: \xa0 基於瀏覽器的分散式版次管理與整合程式開發環境 (複習) \n \n github_multi_site_version_control_dia.7z \n USB 隨身碟: \n 下載  python_2025_lite.7z  (428 MB, 解開壓縮後約 1.5 GB) \n 下載  NX2312 可攜 CAD 壓縮檔案 (1.85 GB, 解開後約 9 GB) \n nx2312_Drafting.7z \n nx2312_nxplot.7z \n What are Github and Codespace? \n 以下兩個影片說明如何利用 Codespaces 維護個人的作業倉儲: \n Codespaces 維護作業倉儲教學片一: \n \n Codespaces 維護作業倉儲教學影片二: \n \n 以下兩個影片說明如何利用可攜程式環境在近端電腦維護作業倉儲內容: \n Localhost 維護作業倉儲教學影片一: \n \n Localhost 維護作業倉儲教學影片二: \n \n Hello World - GitHub Docs \n 利用包含學號的字串作為帳號, 申請免費使用 Github. \n Topic 2: \xa0 計算機程式課程作業與學員網頁 (複習) \n What is Github Classroom? \n GitHub Classroom \n 2020.04 轉為封閉源之前的  Github Classroom 原始碼 \n Your repository and Web site \n Topic 3: 利用 CAD 套件建立零組件 ( 零件 ,  組立件 ) \n 利用  Solvespace  建立機械系統的零組件 \n Solvespace Tutorial \n Document  ( link ) \n 2D Sketch ,  constraints ,  assembly \n mini Tutorial \n Learning Guide \n Drawing Tutorial \n 如何從 Solvespace 繪製零件轉入 CoppeliaSim: \n \n 利用  Solvespace \xa0進行單一輸入的平面機構模擬 \n 利用  Siemens NX  建立機械系統的零組件 ( NX CAD Buyer's Guide ,\xa0 2024\xa0 Siemens 推出 NX X ,  Fact Sheet , Why?) \n “NX X enables our customers to move to a cloud-based, collaborative engineering environment. Our solution allows them to retain their intellectual property and continue their innovative work, without disruption; no need to reinvent their working practices,” said  Bob Haubrock , senior vice president, Product Engineering Software, Siemens Digital Industries Software. \n https://www.swooshtech.com/2023/01/05/nx-x-a-cloud-based-3d-cad-saas-solution/ \n NX Tutorial \n cd2023_pj3ag4_zmq_football_4.7.7z \n cd2024_2b_g6_steel_ball_platform_nxopen_copsim.7z \n \n \n Homework 1 (10%): \n 利用 Solvespace 與 NX2312 建立  Parts  頁面中的零件 \n 其他 零件模擬練習 \n Homework 2 (10%): \n 利用 Solvespace 與 NX2312 建立  Balance on Wheels  組立件 \n Topic 4: 機電整合系統模擬與控制 \n 利用 \xa0 CoppeliaSim \xa0 建立機電模擬系統 \n 利用 \xa0 Python \xa0 跨網路控制瀏覽器上的機電模擬系統 \n Homework 3 (20%): \n 建立  Balance on Wheels  控制系統設計模擬場景 \n https://github.com/mdecycu/Balance_On_Wheels \n \n \n Balance_on_wheels_nx2312.7z \n Balance_on_Wheel_scene.7z \n cd2023_pj3ag4_zmq_football_4.7.7z \n 2019_Control_and_balancing_of_a_small_vehicle_with_two_wheels_for_autonomous_driving.pdf  ( source ) \n 其他參考資料 \n Homework 4 (20%): \n 建立  Dingo 機器狗 控制系統設計模擬場景 \n https://github.com/mdecycu/DingoQuadruped \n DINGO_QUADRUPED_CAD.7z \n \n", 'tags': '', 'url': 'Topics.html'}, {'title': 'Topic 1', 'text': '主題:\xa0 基於瀏覽器的分散式版次管理與整合程式開發環境 (複習) \n 主題摘要: \n USB 隨身碟 (可配置在自己的電腦): \n 下載  python_2025_lite.7z  (428 MB, 解開壓縮後約 1.5 GB) \n 下載  NX2312 可攜 CAD 壓縮檔案 (1.85 GB, 解開後約 9 GB) \n nx2312_Drafting.7z \n nx2312_nxplot.7z \n 使用電腦教室中的電腦: \n 下載  python_2025_lite.7z  (428 MB, 解開壓縮後約 1.5 GB) \n 使用電腦所安裝的 NX2312 \n \n python_2025_lite.7z  與 可攜 NX2312 CAD  可以直接放在 USB 3.0 格式以上的 USB 隨身碟中, 並在任何 Windows 64 位元以上電腦中使用. \n 解開  python_2025_lite.7z  壓縮檔案後, 可將 可攜 NX2312 CAD  檔案放入 data 目錄中的 nx 子目錄中, 以 start_ipv6.bat 啟動可攜程式系統後, 若在 IPv4 環境, 可在命令提示字元視窗中執行: \n set SPLM_LICENSE_SERVER=29000@認證主機_IPv4_位址, 然後執行 ugraf -nx 開啟 NX2312 \n 若在 IPv6 環境, 可在命令提示字元視窗中執行: \n set SPLM_LICENSE_SERVER=29000@[認證主機_IPv6_位址], 然後執行 ugraf -nx 開啟 NX2312 \n 若要使用 Jupyterlab 協同執行環境, 可在命令提示字元視窗中執行: \n jupyter lab --collaborative \n 之後便可在瀏覽器中開啟 localhost 中的 jupyterlab 執行環境. \n 若要讓其他用戶透過瀏覽器連接至 jupyterlab 協同環境, 可修改 home_ipv6\\.jupyter\\jupyter_server_config.py 檔案中的 c.ServerApp.ip 變數, 改為電腦網路 IPv4 或 IPv6 位址後, 重新執行: \n jupyter lab --collaborative \n \n What are Github and Codespaces? \n Hello World - GitHub Docs \n 利用包含學號的字串作為帳號, 申請免費使用 Github. \n Demo: \n 在 stud.cycu (Linux) 伺服器安裝 Jupyter Notebook: \n pip3 install jupyter\nsudo apt install jupyter-notebook\n# 建立 ./jupyter/jupyter_notebook_config.py\njupyter notebook --generate-config\n# 設法修改 .jupyter/jupyter_notebook_config.py 中的 c.ServerApp.ip 與 c.ServerApp.port\n# 若使用 IPv6, 設定 c.ServerApp.ip = \'2001:288:6004:XX::1\'\n# 以 jupyter notebook list 取得登入 token, 並據以改變登入密碼\n# 啟動 jupyter notebook\njupyter-notebook\n \n 在 Windows 安裝 Jupyter Notebook: \n pip install jupyter\n# 建立 home_ipv4/.jupyter/jupyter_notebook_config.py\njupyter notebook --generate-config\n# 設法修改 .jupyter/jupyter_notebook_config.py 中的 c.ServerApp.ip 與 c.ServerApp.port\n# 若使用 IPv6, 設定 c.ServerApp.ip = \'2001:288:6004:XX::1\'\n# 以 jupyter server list 取得登入 token, 並據以改變登入密碼\n# 啟動 jupyter notebook\njupyter notebook \n 完成設定後, 多名系統設計者可以利用瀏覽器連接 Jupyter Notebook, 編寫 ZMQ Remote API Python 程式, 控制位於 CoppeliaSim server 上的機電系統, 並透過瀏覽器觀測控制結果. \n Jupyter server: \n pip install jupyter-server \n jupyter server --generate-config \n pip install jupyter-collaboration \n jupyter lab --collaborative \n 針對 cp2024.ipynb 進行  realtime 協同編輯 \n http://[2001:288:6004:xx::1]:8888/lab/workspaces/auto-v/tree/RTC%3Acp2024.ipynb \n https://colab.research.google.com/ \xa0 \n https://deepnote.com/pricing \xa0 \n https://jupyterhub.readthedocs.io \xa0 \n Use  Stunnel  to serve jupyter notebook or jupyter lab under https or just setup under  Jupyter : \n Use openssl.exe to generate self-signed key.pem and cert.pem: \n openssl req -newkey rsa:2048 -new -nodes -x509 -days 3650 -keyout key.pem -out cert.pem \n stunnel.conf: \n [https]\naccept = [2001:288:6004:XX::1]:443\nconnect = [2001:288:6004:XX::1]:8888\ncert = cert.pem\nkey = key.pem\nTIMEOUTclose = 0 \n 利用系統管理員身分執行批次檔案指令, 設定防火牆允許 TCP 封包對 CoppeliaSim zmq server 連線 (in 權限開啟 23000-23050): \n allow_23000-23050_tcp_in_firewall_setting.7z \n echo off\nREM netsh advfirewall firewall add rule name="RULENAME" dir=[in/out] action=[allow/block/bypass] protocol=[tcp/udp] localip=[any] remoteip=[any]\nREM allow tcp in for port 23000-23050\nnetsh advfirewall firewall add rule name="allow_23000-23050" dir=in action=allow protocol=TCP localport=23000-23050\nnetsh advfirewall firewall add rule name="allow_23000-23050" dir=out action=allow protocol=TCP localport=23000-23050 \n', 'tags': '', 'url': 'Topic 1.html'}, {'title': '上課內容', 'text': '利用靜態認證檔案, 加快作業網站編輯流程: \n 第一步: 使用可攜程式環境在cmd 中執行下列指令: \n openssl req -newkey rsa:2048 -new -nodes -x509 -days 3650 -keyout key.pem -out cert.pem \n 第二步: 將 key.pem 與 cert.pem 放入作業倉儲根目錄 \n 第三步: 修改作業倉儲中的 cmsimde/wsgi.py \n if uwsgi:\n    # run on remote site\n    application = flaskapp.app\nelse:\n    # on localhost, on Linux or Mac need to use python3 wsgi.py to execute\n    #flaskapp.app.run(host=ip, port=port, debug=True, ssl_context="adhoc")\n    flaskapp.app.run(host=ip, port=port, debug=True, ssl_context=(\'cert.pem\', \'key.pem\')) \n 結果: 當啟動作業網站編輯時, 可以直接取用 key.pem 與 cert.pem, 而不需要每次連至各頁面時動態產生 https 所需的認證檔案. \n \n 2a w1 有關 Codespaces 應用: \n demo 倉儲:  https://github.com/mdecad2024/hw-mdecycu \n 維護作業倉儲的兩種方法: \n 1. 使用 Codespaces, 開啟、關閉或刪除虛擬程式環境:\xa0 https://github.com/codespaces \xa0 \n \n 2. 使用可攜程式環境:\xa0 下載\xa0 python_2025_lite.7z \xa0(428 MB, 解開壓縮後約 1.5 GB) \n w2 採 hybrid (複合式, 只將必要的倉儲與設定檔案放在 USB, 執行時使用 C:\\ 中的檔案) 自動下載可攜並解開到固態硬碟的兩個批次檔案:\xa0 cad2024_w2_hybrid_download_and_start_batch.7z \n \n 請下週記得帶來: \n 耳機 \n 隨身碟 (USB 3.0, 32 GB 以上) \n 下載  python_2025_lite.7z  (428 MB, 解開壓縮後約 1.5 GB) \n 下載  NX2312 可攜 CAD 壓縮檔案 (1.85 GB, 解開後約 9 GB) \n nx2312_Drafting.7z \n nx2312_nxplot.7z \n NX2312 解開壓縮後, 將 NX2312_CAD 目錄名稱改為 nx 後, 放入可攜程式系統的 data 目錄中 \n \n 利用 Codespaces 維護作業網站: \n 2b w1 1-1 影片: \n \n 利用可攜程式環境維護作業網站: \n \n 2B W2 \n \n NX2312 啟動設定: \n REM for NX2312, must after path setup \nset SPLM_LICENSE_SERVER=29000@認證主機\nset UGII_LANG=english\nset UGS_LICENSE_BUNDLE=ACD11,ACD10\nset UGII_BASE_DIR=%Disk%:\\NX\\\nset UGII_TMP_DIR=%Disk%:\\NX\\temp\nset UGII_LIB_PATH=%Disk%:\\NX\\NXBIN\\python\nset ugii=%Disk%:\\NX\\ugii;%Disk%:\\NX\\nxbin;\npath = %ugii%;%path%\nXcopy %Disk%:\\home_ipv6\\AppData\\Local\\Siemens\\NX2312 C:\\users\\%USERNAME%\\AppData\\Local\\Siemens\\NX2312 /E /H /C /I /Y\n\nREM 決定是否開啟 nx GUI 介面\nREM start ugraf -nx\n\nREM 以下指令可以直接呼叫 NXOpen Python 程式進行繪圖組立與其他相關流程\npython %Disk%:\\tmp\\nx_ex\\new_part.py \n', 'tags': '', 'url': '上課內容.html'}, {'title': 'Seat', 'text': '2a  座位表1 ,  分組座位表 \n 電腦輔助設計與實習 2a 座位表: \n \n 2b  座位表1 ,  分組座位表 \n 電腦輔助設計與實習 2b 座位表: \n \n \n 上述程式透過與 claude.ai 進行以下對話後產生： \n 問題:  https://mde.tw/2024/1a.txt 為一行學員的學號資料, 請用 Brython open().read() 讀取後, 利用 Canvas 在 id 為 brython_div 的超文件位置上, 採由上而下, 由右而左的次序, 用每一個學員除畫出學號外, 還加上外方框線, 且每一列共列出 9 位學員, 畫完後,以print() 印出 "done" 問: 怎麼只列出一位學員? (因為 AI 沒有用跳行隔開學員學號, 而是用 "," 隔開資料) 說明: 因為 AI 沒能正確解讀資料, 因此提供資料格式供其參考: 問:  40831154 40932134 41023249 41031136 41036112 這是前面五行資料, 請修改程式 說明: 接下來 AI 已經能夠正確解讀資料, 但因為提供錯誤的 html id 字串因此產生下列錯誤, File "<string>", line 8, in draw_students KeyError: brython_div 問: id 為 brython_div1, x 方向的框寬可以小一點, 否則最左邊顯示不出來 說明: 這時 AI 已經正確完成任務 (也就是修正各學員外框寬度後, 存為 group1), 但因所選的外框太寬, 因此最左邊的學號沒有完全顯示出來, 要求針對這個問題進行處理 問: 可不可以從最右邊開始, 第一列前三個與第二列前三個學員為同一組, 其框內背景請塗上同一個淡顏色辨識, 若至最後一列, 並沒有前三與後三作為同一組, 請就剩下的組員若少於 6 名則設為同一組, 若大於 6 則儘量平均方為兩組. 問: 是原則上同一列三位與下一列對齊的三位為同一組 問: 每一列不是有 9 位學員, 第二列也是有 9 位學員, 第一列的前三個學員與第二列的前三位為同一組, 接下來則是第一列的第 4, 5,6 位學員與第二列的第 4,5,6 位學員則也是同一組, 然後剩下的學員依照這個次序分組, 同一組的塗上相同的背景顏色. 最後因為可能剩下一個列的組員, 因此沒有辦法與下一列的組員進行分組, 因此只能就同一列每六位學員一組, 但若只剩下假設 9 位, 則一組 5 位同學,另一組 4 位, 表示一組至少要有 4 位學員的意思. 問: 原先的學員位置弄亂了, 目前第一列至第六列,只有從右邊算來前 6 位學員進行分組塗色, 各列 7,8,9 並沒有進行分組塗色 說明: 結果 AI 完成 group2 Brython 程式的編寫 \n', 'tags': '', 'url': 'Seat.html'}, {'title': 'Vocabulary', 'text': '這裡將要利用 Python 程式, 從電子書:  Intro_to_Mechatronics.pdf  與  Programming with Python for Engineers , 擷取出英文單字, 並建立查詢中英文字典的網頁. \n 所使用的 Python 模組為  textract  結合  poppler  中的 pdftotext.exe 工具, 先利用  extract_text_from_pdf.txt  將電子書的內容取出後, 再利用  check_vocabulary_from_cdit_net.txt  建立單字查詢超文件: \n Intro_to_Mechatronics.pdf : 英文單字查詢  words_Intro_to_Mechatronics.html \n Programming with Python for Engineers : 英文單字查詢  words_programming_with_python_for_engineers.html \n ref1 : 英文單字查詢  words_mech_what.html \n 由於可攜程式套件  python_2025_lite.7z  中的 pip 版本高於 24.1, 導致無法正常安裝  textract  模組, 因此利用: \xa0 \n python get-pip.py pip==21.1.2 \n 將 pip 版本退至 21.1.2 後, 利用 pip install textract, 然後下載  poppler  工具, 讓 pdftotext.exe 可以在可攜程式c環境的 path 中執行. \n \n', 'tags': '', 'url': 'Vocabulary.html'}, {'title': 'Computer', 'text': 'Vmware  最近宣布 適用於 Windows 及 Linux 的 Vmware Workstation Pro ( 17.6 ), 與適用於 MacOS 的 Vmware Fusion Pro 全面免費. \n 下載 Vmware Workstation Pro  (For Windows and Linux) - 註冊帳號後下載 VMware-workstation-full-17.6.2.exe \n 下載 Vmware Fusion Pro  (For Mac) - 註冊帳號後下載 \n \n 本頁將提供本系與電腦軟硬體有關的資訊, 其中包括 個人電腦 、 筆電 、 操作系統 、 軟體套件 與 網路連線 相關的內容. \n 基本概念: \n 要對個人使用的電腦軟硬體與網路連線 有清楚的認識 , 碰到問題時才能 迅速排除. \n 學習使用電腦軟硬體, 要從 最基本的安裝 作為起點, 並不斷學習如何 延伸既有套件的功能 , 且嘗試動手 建立或配置合用的電腦軟硬體. \n 英文單字: \n 認識這  5000_words.txt  英文單字, 將有助於碰到與電腦軟硬體相關的英文資訊時的理解與應用. \n 2016 年出版的   Programming with Python       書中收集 2244 個英文   單字出現次數   , 以及各單字的   查詢頁面 . \n 操作系統: \n 使用 VPN 或位於校網, 下載  Windows 1809 ISO 、 Win10_1909 、 Win10_21H2.9 、 Win_10_22H2.4  或  Win_11_22H2.6 , 然後利用  Virtualbox  以虛擬主機安裝 Windows 64 位元操作系統. 安裝後每半年必須在校網或使用 VPN, 透過  Windows KMS  以管理者身分進行認證.  Windows 操作系統安裝啟動教學 . \n 說明如何安裝與配置虛擬主機的影片: \n \n 其他教育版軟體下載:\xa0 https://software.nfu.edu.tw/  ( Windows 操作系統下載頁面 ) \n 安裝完成後, 可以直接利用  win10_2024.vdi \xa0建立一個虛擬的 Windows 10 操作系統環境. 或者下載  win10_2024_vdi.7z , 使用已經配置 Firefox, 7zip, 以及\xa0 python_2025_lite.7z \xa0的虛擬主機檔案. \n 接下來就可以利用虛擬主機自行配置計算機程式所需的網路與 Python 可攜套件. \n 建立使用者: \n 利用指令建立 Windows 10 下的使用者帳號: \n 先利用管理者身分啟動一個 cmd (命令提示字元視窗) \n 利用 net user 帳號名稱 密碼 /add 指令, 建立使用者登入名稱為: 帳號名稱, 其登入密碼為: 密碼 \n 修改  uuid : \n 利用\xa0 VBoxManage.exe 修改 win10_2024.vdi 的 uuid, 因為在同一套 Virtualbox 上的各個虛擬主機檔案, 必須要有不同的 uuid. \n D:\\VirtualBox\\VBoxManage internalcommands sethduuid "c:\\tmp\\win10_2024.vdi" \n 下載安裝 SolidWorks 2023 教育版: \n 請參考電腦輔助設計實習課程中的  SolidWorks 頁面 說明. \n 虛擬主機上的網路卡設定: \n 希望虛擬主機可以上網, 但無需做為伺服器 -  採 NAT 設定 , 可以利用宿主 (實體 Windows 或 Linux 操作系統) 的網路連外, 但是外網電腦無法直接對此虛擬主機連線. \n 希望虛擬主機可以上網, 並且充當伺服器 -  採 Bridge Adaptor 設定 , 虛擬主機的網路卡位階與宿主的網路卡連線相當, 若宿主有兩片實體網路卡, 則虛擬主機可以將 Bridge Adaptor 轉接到第宿主的第二片實體網路卡, 可以取得與宿主相同的網路連線頻寬. \n 希望虛擬主機僅能與宿主網路連線, 不會受到外部網路干擾 -  採 Host-Only Adaptor 設定 , 虛擬主機僅能與宿主透過內部的網路設定連線, 虛擬主機無法對外連線. \n \n 由於  Virtualbox  虛擬機屬於 Type 2 Hypervisor, 因此與原生機的效能差別較大, 有同學建議使用  Proxmox Virtual Environment  (PVE) , 但 PVE 屬於 Type 1 Hypervisor, 是一套分別整合 KVM hypervisor、Linux Container (LXC)、軟體定義儲存與網路功能的虛擬機器管理平台, 本身就是一套基於  Debian  的完整操作系統, 因此必須要下載 .iso 檔案放入 USB, 然後對實體電腦開機後使用. 以下將介紹其使用方法: \n proxmox-ve_8.2-2.iso  容量為 1.39GB,  使用說明 . \n 上述採用  Virtualbox  所建立的 .vdi 虛擬機器檔案, 可以經過轉換後用來建立 Proxmox VE 的虛擬機器, 其步驟如下: \n \n 將 .vdi 檔案上傳到 PVE 主機 \n 使用 qemu-img 轉換成 PVE 支援的格式: qemu-img convert -f vdi -O qcow2 source.vdi destination.qcow2 \n 在 PVE 中創建新的虛擬機 \n 選擇使用轉換後的磁碟映像檔 \n \n 由於利用 PVE 建立 Windows 10 或 11 虛擬機器, 需要對電腦輔助設計室中的電腦設定為可以接受 USB 開機, 且所建立的 Windows 操作系統, 將失去目前 Windows 11 中所安裝的套件使用, 因此比較不適合目前計算機程式課程的使用. \n \n Ubuntu \n ubuntu24041_vdi_mde.7z \n \n', 'tags': '', 'url': 'Computer.html'}, {'title': 'Ref', 'text': 'peer_review_project.7z \n 已知: \n \n 修課學員經由 @nfu.edu.tw 網域, 可利用"學號@nfu.edu.tw"經由  https://login.microsoftonline.com/  登入 MS 365. \n 登入後, 使用者可以利用" 應用程式註冊 "建立應用程式 \n 所註冊的延伸應用程式則可以利用 Microsoft Online 主機所提供的 OAuth2 API 程式庫, 取得登入者的 profile \n 經由上列步驟取得登入者的 profile 後, 延伸應用程式可設法讀取課程學員的作業倉儲與網站連結 \n 當每一階段的學員作業網頁完成後, 若再經由亂數方法, 隨機分配給每一位學員 10 個除自己以外的學員作業網站進行評分, 即可根據既定的評分基準完成自評 \n 隨機分配的學員作業網址可利用 email 寄出, 而評分回報則可利用 MS 365 的 Forms 表單取回 \n \n 以下為上列流程的 step 1 測試程式 ( teams_oauth2_flask_py.txt ): \n from flask import Flask, redirect, request, session, url_for\nimport requests\nimport json\n\napp = Flask(__name__)\napp.secret_key = \'your_secret_key\'  # 用於 Flask session 的秘密金鑰\n\n# 替換成你的 Azure AD 應用程式資訊\n\'\'\'\nCLIENT_ID 為"應用程式 (用戶端) 識別碼"\nCLIENT_SECRET 則為"憑證及秘密"中"用戶端密碼"的"值"\n\'\'\'\nCLIENT_ID = \'id\'\nCLIENT_SECRET = \'secret\'\nTENANT_ID = \'id\'\nAUTHORITY = f\'https://login.microsoftonline.com/{TENANT_ID}\'\nREDIRECT_URI = \'http://localhost:8000/callback\'\nSCOPE = \'User.Read\'\n\n# 用於登錄和取得授權碼\n@app.route(\'/\')\ndef index():\n    auth_url = (f\'{AUTHORITY}/oauth2/v2.0/authorize\'\n                f\'?client_id={CLIENT_ID}\'\n                f\'&response_type=code\'\n                f\'&redirect_uri={REDIRECT_URI}\'\n                f\'&response_mode=query\'\n                f\'&scope={SCOPE}\')\n    return redirect(auth_url)\n\n# 處理回調和交換授權碼\n@app.route(\'/callback\')\ndef callback():\n    code = request.args.get(\'code\')\n    token_url = f\'{AUTHORITY}/oauth2/v2.0/token\'\n    token_data = {\n        \'grant_type\': \'authorization_code\',\n        \'code\': code,\n        \'redirect_uri\': REDIRECT_URI,\n        \'client_id\': CLIENT_ID,\n        \'client_secret\': CLIENT_SECRET,\n        \'scope\': SCOPE\n    }\n    token_r = requests.post(token_url, data=token_data)\n    token_r.raise_for_status()\n    tokens = token_r.json()\n    session[\'access_token\'] = tokens[\'access_token\']\n    return redirect(url_for(\'profile\'))\n\n# 使用訪問令牌呼叫 Microsoft Graph API 來獲取用戶資料\n@app.route(\'/profile\')\ndef profile():\n    access_token = session.get(\'access_token\')\n    if not access_token:\n        return redirect(url_for(\'index\'))\n\n    headers = {\n        \'Authorization\': f\'Bearer {access_token}\',\n        \'Content-Type\': \'application/json\'\n    }\n    graph_url = \'https://graph.microsoft.com/v1.0/me\'\n    graph_r = requests.get(graph_url, headers=headers)\n    graph_r.raise_for_status()\n    user_info = graph_r.json()\n    user_email = str(user_info["mail"])\n    user_id = user_email.split("@")[0]\n    session["user_id"] = user_id\n    # 登出 MS Online 並重定向回首頁\n    # 返回 HTML 及 JavaScript 以進行自動登出\n    return (f\'Hello, {user_id} <br>\'\n            f\'<script type="text/javascript">\'\n            f\'  window.location = "https://login.microsoftonline.com/common/oauth2/v2.0/logout";\'\n            f\'</script>\')\n\n@app.route(\'/userid\')\ndef userid():\n    return session["user_id"]\n    \n\n# 登出功能\n@app.route(\'/logout\')\ndef logout():\n    # 清除 session 中的訪問令牌\n    session.pop(\'access_token\', None)\n    # 重定向到 MS Online 登出 URL\n    return redirect(\'https://login.microsoftonline.com/common/oauth2/v2.0/logout\')\n\nif __name__ == \'__main__\':\n    app.run(debug=True, port=8000)\n \n 以下則為寄信範例: \n import requests\nimport json\n\n# 替換為你的應用程式資訊\nCLIENT_ID = \'your_client_id\'\nCLIENT_SECRET = \'your_client_secret\'\nTENANT_ID = \'your_tenant_id\'\nAUTHORITY = f\'https://login.microsoftonline.com/{TENANT_ID}\'\nTOKEN_URL = f\'{AUTHORITY}/oauth2/v2.0/token\'\nSCOPE = \'https://graph.microsoft.com/.default\'\n\n# 獲取 OAuth2 訪問令牌\ndef get_access_token():\n    token_data = {\n        \'grant_type\': \'client_credentials\',\n        \'client_id\': CLIENT_ID,\n        \'client_secret\': CLIENT_SECRET,\n        \'scope\': SCOPE\n    }\n    token_r = requests.post(TOKEN_URL, data=token_data)\n    token_r.raise_for_status()\n    tokens = token_r.json()\n    return tokens[\'access_token\']\n\n# 發送電子郵件\ndef send_email(access_token, to_address, subject, body):\n    headers = {\n        \'Authorization\': f\'Bearer {access_token}\',\n        \'Content-Type\': \'application/json\'\n    }\n    email_data = {\n        "message": {\n            "subject": subject,\n            "body": {\n                "contentType": "Text",\n                "content": body\n            },\n            "toRecipients": [\n                {\n                    "emailAddress": {\n                        "address": to_address\n                    }\n                }\n            ]\n        },\n        "saveToSentItems": "true"\n    }\n    email_url = \'https://graph.microsoft.com/v1.0/me/sendMail\'\n    response = requests.post(email_url, headers=headers, json=email_data)\n    response.raise_for_status()\n    print("Email sent successfully!")\n\nif __name__ == "__main__":\n    token = get_access_token()\n    send_email(token, \'recipient@example.com\', \'Test Subject\', \'This is the email body.\')\n \n \n 以下利用 ChatGPT 4omini 進行對話: \n 問: \n 使用 python + flask 開發一個簡單的資料庫程式, 並使用 SQLite, 目前表單有使用者學號以及其 github 帳號, 還有一個備註欄位, 只需要 add, query, update 與 delete 功能, 該如何進行? \n 答: \n 1. 安裝 Flask 和 SQLite 首先，確保你已經安裝了 Flask 和 SQLite。如果你還沒有安裝，請使用以下命令： \n pip install Flask\n \n SQLite 通常已經隨 Python 安裝，不需要額外安裝。如果你需要 SQLite 的 Python 模組，可以使用以下命令： \n pip install sqlite3\n \n 2. 建立 Flask 應用程式 \n 應用程式結構 \n flask_app/\n│\n├── app.py\n├── schema.sql\n└── templates/\n    ├── index.html\n    ├── add.html\n    ├── update.html\n    └── query.html\n \n schema.sql — 定義 SQLite 資料表 在 schema.sql 文件中，定義 SQLite 資料表結構： \n CREATE TABLE IF NOT EXISTS users (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    student_id TEXT NOT NULL UNIQUE,\n    github_account TEXT NOT NULL,\n    notes TEXT\n);\n \n app.py — Flask 應用程式 在 app.py 中，設置 Flask 應用程式並建立 CRUD 功能： \n from flask import Flask, request, redirect, url_for, render_template\nimport sqlite3\n\napp = Flask(__name__)\n\nDATABASE = \'database.db\'\n\ndef get_db():\n    conn = sqlite3.connect(DATABASE)\n    conn.row_factory = sqlite3.Row\n    return conn\n\ndef init_db():\n    with app.app_context():\n        db = get_db()\n        with open(\'schema.sql\', \'r\') as f:\n            db.executescript(f.read())\n        db.commit()\n\n@app.route(\'/\')\ndef index():\n    return render_template(\'index.html\')\n\n@app.route(\'/add\', methods=[\'GET\', \'POST\'])\ndef add_user():\n    if request.method == \'POST\':\n        student_id = request.form[\'student_id\']\n        github_account = request.form[\'github_account\']\n        notes = request.form.get(\'notes\', \'\')\n\n        db = get_db()\n        db.execute(\'INSERT INTO users (student_id, github_account, notes) VALUES (?, ?, ?)\',\n                   (student_id, github_account, notes))\n        db.commit()\n        return redirect(url_for(\'index\'))\n\n    return render_template(\'add.html\')\n\n@app.route(\'/update/<int:user_id>\', methods=[\'GET\', \'POST\'])\ndef update_user(user_id):\n    db = get_db()\n    if request.method == \'POST\':\n        student_id = request.form[\'student_id\']\n        github_account = request.form[\'github_account\']\n        notes = request.form.get(\'notes\', \'\')\n\n        db.execute(\'UPDATE users SET student_id = ?, github_account = ?, notes = ? WHERE id = ?\',\n                   (student_id, github_account, notes, user_id))\n        db.commit()\n        return redirect(url_for(\'index\'))\n\n    user = db.execute(\'SELECT * FROM users WHERE id = ?\', (user_id,)).fetchone()\n    return render_template(\'update.html\', user=user)\n\n@app.route(\'/delete/<int:user_id>\')\ndef delete_user(user_id):\n    db = get_db()\n    db.execute(\'DELETE FROM users WHERE id = ?\', (user_id,))\n    db.commit()\n    return redirect(url_for(\'index\'))\n\n@app.route(\'/query\')\ndef query_users():\n    db = get_db()\n    users = db.execute(\'SELECT * FROM users\').fetchall()\n    return render_template(\'query.html\', users=users)\n\nif __name__ == \'__main__\':\n    init_db()\n    app.run(debug=True)\n \n templates/index.html \n <!DOCTYPE html>\n<html>\n<head>\n    <title>Index</title>\n</head>\n<body>\n    <h1>Welcome to User Management</h1>\n    <a href="{{ url_for(\'add_user\') }}">Add User</a> |\n    <a href="{{ url_for(\'query_users\') }}">Query Users</a>\n</body>\n</html>\n \n templates/add.html \n <!DOCTYPE html>\n<html>\n<head>\n    <title>Add User</title>\n</head>\n<body>\n    <h1>Add User</h1>\n    <form action="{{ url_for(\'add_user\') }}" method="post">\n        <label for="student_id">Student ID:</label>\n        <input type="text" id="student_id" name="student_id" required><br>\n        <label for="github_account">GitHub Account:</label>\n        <input type="text" id="github_account" name="github_account" required><br>\n        <label for="notes">Notes:</label>\n        <textarea id="notes" name="notes"></textarea><br>\n        <input type="submit" value="Add">\n    </form>\n    <a href="{{ url_for(\'index\') }}">Back</a>\n</body>\n</html>\n \n templates/update.html \n <!DOCTYPE html>\n<html>\n<head>\n    <title>Update User</title>\n</head>\n<body>\n    <h1>Update User</h1>\n    <form action="{{ url_for(\'update_user\', user_id=user[\'id\']) }}" method="post">\n        <label for="student_id">Student ID:</label>\n        <input type="text" id="student_id" name="student_id" value="{{ user[\'student_id\'] }}" required><br>\n        <label for="github_account">GitHub Account:</label>\n        <input type="text" id="github_account" name="github_account" value="{{ user[\'github_account\'] }}" required><br>\n        <label for="notes">Notes:</label>\n        <textarea id="notes" name="notes">{{ user[\'notes\'] }}</textarea><br>\n        <input type="submit" value="Update">\n    </form>\n    <a href="{{ url_for(\'index\') }}">Back</a>\n</body>\n</html>\n \n templates/query.html \n <!DOCTYPE html>\n<html>\n<head>\n    <title>Query Users</title>\n</head>\n<body>\n    <h1>Users</h1>\n    <table>\n        <tr>\n            <th>ID</th>\n            <th>Student ID</th>\n            <th>GitHub Account</th>\n            <th>Notes</th>\n            <th>Actions</th>\n        </tr>\n        {% for user in users %}\n        <tr>\n            <td>{{ user[\'id\'] }}</td>\n            <td>{{ user[\'student_id\'] }}</td>\n            <td>{{ user[\'github_account\'] }}</td>\n            <td>{{ user[\'notes\'] }}</td>\n            <td>\n                <a href="{{ url_for(\'update_user\', user_id=user[\'id\']) }}">Update</a> |\n                <a href="{{ url_for(\'delete_user\', user_id=user[\'id\']) }}">Delete</a>\n            </td>\n        </tr>\n        {% endfor %}\n    </table>\n    <a href="{{ url_for(\'index\') }}">Back</a>\n</body>\n</html>\n \n 3. 啟動應用程式 確保你的 Flask 應用程式和模板文件已經正確配置，然後啟動應用程式： \n python app.py\n \n 接下來, 可以在瀏覽器中訪問  http://127.0.0.1:5000/  來查看和管理你的資料。 \n \n Video: \n https://vimeo.com/user24079973 \n https://www.youtube.com/@-kmolab9376 \n References: \n Fundamental_Design_Principles \n Q&A \n https://github.com/jax-ml/jax  ( About JAX ,  AI 2.0 ) \n RL-X: A Deep Reinforcement Learning Library (Not Only) for RoboCup  ( RL-X ) \n https://github.com/n2cholas/awesome-jax \n https://github.com/deepmodeling/jax-fem', 'tags': '', 'url': 'Ref.html'}, {'title': 'Topic 2', 'text': '主題: \xa0 計算機程式課程作業與學員網頁 (複習) \n What is Github Classroom? \n GitHub Classroom \n Your repository and Web site \n Demo: 指定 Github Classroom cad2024 上的個人專案作業倉儲 \n 作業倉儲與作業網站連結: \n 2a site and repo', 'tags': '', 'url': 'Topic 2.html'}, {'title': 'Topic 3', 'text': '主題: 利用 CAD 套件建立零組件 ( 零件 ,  組立件 ) \n 利用  Solvespace  建立機械系統的零組件 \n https://support.industrysoftware.automation.siemens.com/training/se/en/ST3/pdf/spse01550.pdf \xa0 (零件繪圖練習只要畫到 page 32) \n cad2024_practice_9_page_32.pdf \n Solvespace Tutorial \n Document  ( link ) \n 2D Sketch ,  constraints ,  assembly \n mini Tutorial \n Learning Guide \n Drawing Tutorial \n 說明如何利用 Solvespace 建立零件後 import 進入 CoppeliaSim 場景: \n \n Demo 如何利用 ShareX 與 Zoomit 進行操作畫面錄影: \n \n 利用  Solvespace \xa0進行單一輸入的平面機構模擬 \n \n 利用 Siemens NX2312 繪製零組件: \n NX2312 官方文件  ( 英文 ) \n https://community.sw.siemens.com/s/question/0D54O00006VLlp9SAD/where-can-i-find-i-find-more-details-on-the-nx-student-license-and-its-restrictions  ( NX CAD/CAM Student Edition ) \n https://learnnx.com/ \n https://support.industrysoftware.automation.siemens.com/training/se/en/ST3/pdf/spse01550.pdf \xa0 (零件繪圖練習只要畫到 page 32) \n 下載  NX2312 可攜 CAD 壓縮檔案 (1.85 GB, 解開後約 9 GB) \n nx2312_Drafting.7z \n nx2312_nxplot.7z \n NX_user.dpv  位於可攜程式系統中的 home_ipv6\\AppData\\Local\\Siemens\\NX2312 目錄. \n dpv - default preferences values (預設偏好設定) \n 啟動 NX2312 環境變數設置: \n UGII_LOCAL_USER_DEFAULTS="Y:\\home_ipv6\\AppData\\Local\\Siemens\\NX2312\\NX_user.dpv" \n \n 利用  Siemens NX  建立機械系統的零組件 ( NX CAD Buyer\'s Guide ,\xa0 2024\xa0 Siemens 推出 NX X ,  Fact Sheet , Why?) \n “NX X enables our customers to move to a cloud-based, collaborative engineering environment. Our solution allows them to retain their intellectual property and continue their innovative work, without disruption; no need to reinvent their working practices,” said  Bob Haubrock , senior vice president, Product Engineering Software, Siemens Digital Industries Software. \n NX Tutorial \n cd2023_pj3ag4_zmq_football_4.7.7z \n cd2024_2b_g6_steel_ball_platform_nxopen_copsim.7z \n Homework 1: \n 利用 Solvespace 與 NX2312 建立  Parts  頁面中的零件 \n 其他 零件模擬練習 \n Homework 2: \n 利用 Solvespace 與 NX2312 建立  Balance on Wheels  組立件 \n 2019_Control_and_balancing_of_a_small_vehicle_with_two_wheels_for_autonomous_driving.pdf  ( source ) \n 其他參考資料', 'tags': '', 'url': 'Topic 3.html'}, {'title': 'lessons', 'text': 'https://support.industrysoftware.automation.siemens.com/training/se/en/ST3/pdf/spse01550.pdf \xa0 (零件繪圖練習只要畫到 page 32) \n lesson 2:\xa0 \n 直接將 STL 零件嵌入頁面: \n embed_stl_into_page_html.txt \n embed_multiple_stl_into_page_html.txt \n solvespace:  cad2024_part_ex1_solvespace.slvs \n \n \n \n \n solvespace:  lesson2.slvs \n \n page_27_solvespace.7z \n \n page16.7z \n \n Model Color:  Back Color1:  Back Color2:  Render Mode: \n Flat \n Point \n Wireframe \n Smooth \n Definition: \n Standard \n low \n high \n \n \n \n \n', 'tags': '', 'url': 'lessons.html'}, {'title': 'STL', 'text': 'STL 檔案格式 : \n STL 檔案格式（STL：StereoLithography）是一種用於描述 三維物體表面幾何形狀 的電腦檔案格式. 它最早用於快速原型 ( Rapid Prototyping ) 製造, 但現在也被廣泛應用於 3D 列印、3D 掃描和 CAD 軟體中. \n STL 檔案的特性: \n \n 三角網格表示法: STL 檔案將物體表面表示為一系列三角形的小平面. 每個三角形由三個頂點的座標定義, 這些三角形共同組成物體的外殼. \n 簡潔輕量: STL 檔案的結構相對簡單,  只包含三角面的法向量和三個頂點的座標 , 因此檔案大小較小. \n 小平面資訊: STL 檔案主要用於描述物體的表面, 並不包含關於物體內部結構、材質或尺寸單位等資訊. \n ASCII 或二進位格式: STL 檔案有 ASCII 和二進位兩種格式. ASCII 格式可讀性較好, 但檔案較大; 而二進位格式檔案較小, 但無法直接用一般文字編輯器查看內容. \n 局限性: STL 檔案僅描述物體的幾何形狀, 不包含顏色、紋理、拓撲資訊等. 對於複雜的模型, STL 檔案可能產生較大的檔案, 並且在編輯和修改時容易出現問題. \n \n multiple stl files shown on one page: \n embed_multiple_stl_into_page_html.txt \n \n \n \n \n    可以添加更多的 canvas  \n Model Color:  Back Color1:  Back Color2:  Render Mode: \n Flat \n Point \n Wireframe \n Smooth \n Definition: \n Standard \n low \n high \n \n \n \n \n', 'tags': '', 'url': 'STL.html'}, {'title': 'NX_python', 'text': 'nxopen_python_block_ex.7z \n', 'tags': '', 'url': 'NX_python.html'}, {'title': 'Topic 4', 'text': '以下影片說明如何配置 NX2312: \n \n \n Solvespace 零件組立功能: \n solvespace_one_link_assembly_ttt.7z \n \n one_link_nx_copsim.7z \n \n http://wcm.cycu.org:88/github/cad2023/content/Virtual%20pinball.html  (使用代理主機連結) \n https://alula.github.io/SpaceCadetPinball/ \n http://mjrnet.org/pinscape/BuildGuideV2/BuildGuide.php \n nx2312_Drafting.7z  (NX2312 工程圖模組) \n nx2312_nxplot.7z  (NX2312 Export PDF) \n \n 主題: 機電整合系統模擬與控制 \n 利用 \xa0 CoppeliaSim \xa0 建立機電模擬系統 \n CoppeliaSim 使用者設定檔案位於 C:\\Users\\%USERNAME%\\AppData\\Roaming\\CoppeliaSim\\usrset.txt, 因此若要使用可攜模式, 必須在啟動系統時將先前設定複製至內件位置. \n Xcopy %Disk%:\\home_ipv6\\AppData\\Roaming\\CoppeliaSim C:\\users\\%USERNAME%\\AppData\\Roaming\\CoppeliaSim /E /H /C /I /Y \n 其中包括 defaultPython 與 preferredSandboxLang 變數設定 \n CoppeliaSim 4.7 Scenes  巡禮 (所有場景位於 CoppeliaSim/scenes 目錄中) \n Lua 簡介 \n Kinematics: \n scenes\\controlTypeExamples\\controlledViaZmq.ttt \n scenes\\kinematics\\simpleExamples\\1-singleIkGroupWithSingleIkElement-undamped.ttt \n scenes\\kinematics\\simpleExamples\\8-computingJointAnglesForRandomPoses.ttt \n scenes\\kinematics\\abbFantaCanChallenge.ttt \n scenes\\kinematics\\smoothMovementsInFkAndIk.ttt \n scenes\\kinematics\\twoRobotsIK.ttt \n scenes\\trajectoryAndMotion\\trajectoryGenerationDemo.ttt \n scenes\\pickAndPlaceDemo.ttt \n Dynamics: \n scenes\\otherScenes\\dynamic4BarLinkage.ttt \n scenes\\otherScenes\\simpleMagnetDemo.ttt \n scenes\\otherScenes\\visionSensorOverTerrain.ttt \n scenes\\gears.ttt \n scenes\\proximitySensorDemo.ttt \n UI: \n scenes\\customUI-python.ttt \n CoppeliaSim 4.7 Tutorial \xa0 \n 原始碼:  https://github.com/CoppeliaRobotics \n 利用 \xa0 Python \xa0 跨網路控制瀏覽器上的機電模擬系統 \n cd2023_pj3ag4_zmq_football_4.7.7z \n Homework 3: \n 建立  Balance on Wheels  控制系統設計模擬場景 \n https://github.com/mdecycu/Balance_On_Wheels \n \n \n Balance_on_wheels_nx2312.7z \n Balance_on_Wheel_scene.7z \n Balance_on_Wheel_w_GPS_sensor_ttt_lua.7z  (使用 GPS 感測器取出輪車移動時, 平台的特定點座標) \n Homework 4: \n 建立  Dingo 機器狗 控制系統設計模擬場景 \n https://github.com/mdecycu/DingoQuadruped \n DINGO_QUADRUPED_CAD.7z \n \n', 'tags': '', 'url': 'Topic 4.html'}, {'title': 'Pinball', 'text': 'flipper_nx2312.7z  (請各組利用 Solvespace 與 NX2312 繪製零組件並轉入 CoppeliaSim 進行動態模擬) \n flipper_in_solvespace.7z \n flipper_in_solvespace_final.7z \n flipper_in_solvespace_cw_and_ccw.7z \n flipper_in_solvespace_cw_and_ccw_w14.7z \n pinball_cad2024.7z \n \n pinball_cad2024_poc.7z \n \n \n \n pinball_plunger.ttt \n copsim_graph_vel_acc_python.txt \n double_crank_slider.ttt  ( Onshape example ) ( Old data ) \n \n ( source ) \n \n \n ( source ) \n \n ( source ) \n Playfield \n \n ( source ) \n \n big_old_pinball.ttt \n big_old_pinball_rot.ttt \n Pinball 遊戲台上各種裝置的正式英文名稱: \n Playfield (遊戲場) \n 整個遊戲台的主要活動區域. \n Spinner (旋轉器) \n 可以旋轉的特殊目標, 球經過時會旋轉並加分. \n Ball drain (球洞) \n 球掉落遊戲台底部的區域, 通常意味著失去一顆球. \n Score display (得分顯示) \n 顯示當前分數的電子螢幕. \n Multiball (多球模式) \n 同時在遊戲台上有多顆球的遊戲狀態. \n Kickback (反彈) \n 可以將即將掉落的球彈回遊戲台的機制. \n Flippers  (控制撥桿)\xa0 \n 位於遊戲台底部的兩個可以控制的撥桿, 用於擊球和控制球的方向. \n Bumpers (跳珠器) \n 分佈在遊戲台上的圓形突起裝置, 當球碰到時會彈開球並加分. \n Slingshots  (彈射器) \n 位於flipper兩側的斜面彈射裝置, 當球觸碰時會快速彈開球. \n Targets (目標) \n 遊戲台上的固定打擊目標, 可分為:  Drop targets  (下降目標), Pop-up targets (彈出目標), Standing targets (靜態目標) 等. \n Lanes (軌道) \n 遊戲台上的特定路徑, 如：Roll-over lanes, Return lanes 等. \n Ramps (斜坡) \n 遊戲台上的傾斜軌道, 球可以滾過並加分. \n Outlanes (外側軌道) \n 位於flipper兩側的軌道, 通常會導致球掉落. \n Plunger ( Shooter ) (發射器) -  pinball_plunger.ttt \xa0 \n 用於初始發射球的裝置. \n Eject 機構 \n Popbumper 機構 \n \n References: \n https://en.wikipedia.org/wiki/Pinball \n https://cdn.aaai.org/ocs/1191/1191-5911-1-PB.pdf \n https://www.researchgate.net/publication/360722315_Toward_a_Study_of_Pinball \n https://www.clevelandsoftwaredesign.com/pinball-parts \n https://www.kineticist.com/post/a-beginners-guide-to-pinball-designers \n https://technologystudent.com/pdf22/pinball-full1B.pdf \n https://www.sciencedirect.com/science/article/pii/S1474667017307358 \n slider_cad2024_nx2312.7z \n CNN-based Game State Detection for a Foosball Table \n Towards Reinforcement Learning Control of an Electromechanical Pinball Machine \n https://pinballdesign.com \n Space Cadet Pinball Neural Network \n https://github.com/kimmobrunfeldt/football-score-detector \n \n Flipper ( Source ): \n \n \n Bumper: \n \n Model Color:  Back Color1:  Back Color2:  Render Mode: \n Flat \n Point \n Wireframe \n Smooth \n Definition: \n Standard \n low \n high \n \n', 'tags': '', 'url': 'Pinball.html'}, {'title': 'HW 3', 'text': '建立  Balance on Wheels  控制系統設計模擬場景 \n https://github.com/mdecycu/Balance_On_Wheels \n 上列倉儲中有兩個採 Solidworks 繪製的系統模型, 可以直接以 NX2312 開啟後存為 .prt 檔案. 只是各零組件並沒有詳細的零組件繪製流程. 學員可以自行利用 Solvespace 與 NX2312 建立相同尺寸的零組件. \n \n 以下為取自簡化過的  Balance_on_wheels_nx2312.7z  系統組立件, 從 NX2312 以 Export 功能轉為 .stl 後, 再轉入 CoppeliaSim, 過程中自行利用 Cuboid 建立上平台, 並增大厚度以便讓連桿可以直接接在兩側. \n 由於原始系統模型在部分軸接孔並沒有圓柱件可以讓 Revolute Joint 定位, 必須透過圓孔的 Shape Editor 設法建立. 且原始 Wheel 形狀較為複雜, 在 CoppeliaSim 建立運動模擬場景時, 必須設法簡化, 以下直接採用單一圓柱體作為輪子的動態模擬物件. \n 另外由於連接平台與輪軸的機構為封閉式, 在 CoppeliaSim 場景中進行組裝時, 必須透過兩個 Dummy 物件, 以 Dynamic, overlap constraint 的 Dummy Type 進行連接. 而且各連桿在 CoppeliaSim Shape Editor 後, 可能因碰撞檢測設定而產生的干涉, 可以利用  Respondable Mask  的設定避開. \n 最後, 因為此雙輪車的機構設計目的, 是希望透過輪軸上方致動器的運動控制, 讓輪車透過平台瞬間運動所產生的慣性上下跳躍運動. 但初步階段在雙輪車能夠穩定平衡控制之前, 除輪軸馬達外, 其餘連接軸上的馬達 Control Mode 設為 Position, 均施以 250 N.m 的扭力, 並令其 Target angle 為 0 度. \n 根據以上流程建立的 CoppeliaSim 系統場景畫面與檔案如下: \n \n Balance_on_Wheel_scene.7z \n Balance_on_Wheel_w_GPS_sensor_zero_vel_ttt.7z \n 有關雙輪車平衡控制方法可以參考: \n invertedPendulum_ttt_for_4.7.0_rev4.7z \n Inverted Pendulum: System Modeling \n https://github.com/mdecycu/VREP-Coppeliasim-Linear-first-order-inverted-pendulum \n https://github.com/mdecycu/vrep_inverted_pendulum \n Project-Based Teaching in Control Theory Education Based on V-REP: A Cart Inverted Pendulum Case \n Balance Control of an Inverted Pendulum on a Quadruped Robot by Reinforcement Learning \n Control strategies for inverted pendulum: A comparative analysis of linear, nonlinear, and artificial intelligence approaches \n Design of nonlinear controller for bi-axial inverted pendulum system \n \n', 'tags': '', 'url': 'HW 3.html'}, {'title': 'Exam', 'text': '出席 (10%) - 自行舉證評分 \n Github Classroom 作業與隨堂考試 (60%) - 以 Github 帳號領取作業倉儲後, 建立包含操作流程影片與檔案下載的網頁 \n Topic 1: \xa0 基於瀏覽器的分散式版次管理與整合程式開發環境 \n 瀏覽器 \n 分散式 \n 版次管理 \n Local 有三種方式: HTTPS, SSH 與 Github CLI \n Codespace \n Topic 2:\xa0計算機程式課程作業與學員網頁 \n https://wokwi.com/ \xa0(利用 C +\xa0 機電控制卡, 模擬 步進馬達 、 伺服馬達 與  LED 面板 的控制) \n Topic 3: 利用 CAD 套件建立零組件 ( 零件 ,\xa0 組立件 ) \n Homework 1 (10%): \n 利用 Solvespace 與 NX2312 建立 \xa0 Parts \xa0 頁面中的零件 \n 其他 零件模擬練習 \xa0 \n Pinball  零件繪製 \n Homework 2 (10%): \n Pinball  組立件繪製 \n 利用 Solvespace 與 NX2312 建立 \xa0 Balance on Wheels \xa0 組立件 \n Topic 4: 機電整合系統模擬與控制 \n Homework 3 (20%): \n 建立 \xa0 Balance on Wheels \xa0 控制系統設計模擬場景 \n https://github.com/mdecycu/Balance_On_Wheels \n Homework 4 (20%): \n 建立 \xa0 Dingo 機器狗 控制系統設計模擬場景 \n https://github.com/mdecycu/DingoQuadruped \n DINGO_QUADRUPED_CAD.7z \n 期末口頭與書面專題報告 (30%) - 利用網頁內容進行簡報並提交 pdf 格式書面報告 \n 口頭簡報: Powerpoint vs Reveal.js ( ref ) \n 書面報告: Word vs LaTeX ( ref )', 'tags': '', 'url': 'Exam.html'}, {'title': 'Exam1', 'text': '請在個人網頁標題為 "HW1_Exam" 頁面之後, 加上一個第三階的頁面, 標題為 "w10". \n 並在 "w10" 頁面中完成下列隨堂考試的要求: \n 每一項任務都要拍攝過程操作影片, 且 片頭要先切換到個人的課程網頁 "About" 頁面, 顯示操作者的學號與個人網頁連結 . \n 題目一 : 請利用 Solvespace 繪製 圖面 所示零件, 並將過程錄製為操作影片,\xa0 請以"國立虎尾科技大學機械設計工程系 - 電腦輔助設計與實習 - 題目一: 學號" 作為影片標題, 並在影片說明欄位中敘述此一影片的繪製流程與心得, 完成後請將影片上傳至個人 Youtube 帳號中, 並嵌入個人網站中的 "w10" 頁面. \n 題目一: \n \n   \n w10_part1.slvs \n w10_part1.prt \n \n 題目二 : 請嘗試利用 NX2312 繪製題目一中的零件,  並將過程錄製為操作影片 . 影片命名及嵌入網頁要求與題目一相同, 但必須使用"題目二"標示. \n 題目二: \n   \n w10_part2.slvs \n Model Color:  Back Color1:  Back Color2:  Render Mode: \n Flat \n Point \n Wireframe \n Smooth \n Definition: \n Standard \n low \n high \n \n \n \n \n  ends model  \n 題目三 : \xa0請嘗試利用可攜系統中的  Wink  拍攝 Solvespace 繪製 圖面 所示零件的過程, 並使用 Textbox 中的文字說明繪圖流程 ,  影片命名及嵌入網頁要求與題目一相同,\xa0 但必須使用"題目三"標示. \n 上列題目完成後, 請登入課程 Teams 一般頻道中, 將對應資料填入各班的 Exam1 考試回報表中. \n wink_video_html_format.txt \n', 'tags': '', 'url': 'Exam1.html'}, {'title': 'Problem_set', 'text': '\n \n', 'tags': '', 'url': 'Problem_set.html'}, {'title': 'Exam234', 'text': 'w16_exam1 \n w16_exam2 \n w16_exam3 \n', 'tags': '', 'url': 'Exam234.html'}, {'title': 'w11_hw', 'text': '1. 請各分組根據\xa0 flipper_nx2312.7z \xa0中的零件尺寸, 分別採 Solvespace 與 NX2312 繪製以下零件: \n Plongeur Batteur_sldprt.prt \n Piece composite_sldprt.prt \n Piece métalique gauche_sldprt.prt \n Plastique Flipper_sldprt.prt \n Support Bobine_sldprt.prt \n Platine Batteur_sldprt.prt \n Flipper_sldprt.prt \n 2. 請各組利用 Solvespace 與 NX2312 完成上列零件的組立. \n 3. 請擇一將所完成的 Solvespace 或 NX2312 組立檔案轉入 CoppeliaSim, 並嘗試讓\xa0 Flipper_sldprt.prt 以每秒 10 度的速度旋轉. \n 完成後, 請將操作過程影片與檔案放入個人作業網站中的 w11頁面中. \n 參考資料: \n pinball_plunger.ttt \n copsim_graph_vel_acc_python.txt \n double_crank_slider.ttt \n \n flipper_in_solvespace.7z', 'tags': '', 'url': 'w11_hw.html'}, {'title': 'w14', 'text': '下載\xa0 pinball_cad2024.7z \xa0後, 在可攜系統 ( python_2025_lite.7z ) 安裝 pyzmq、cbor 與 keyboard 模組後, 可以利用 Python 程式控制 Flipper 的旋轉角度. 操作過程如下: \n \n 利用 Solvespace 所繪製的 Flipper 進行組立的過程: \n 過程中所使用的檔案:  w14_solvespace_assembly.7z \n \n 完成其他零件組立的過程如下: \n \n 利用 STL 檔案建立 CoppeliaSim 4.7.0 rev 模擬場景的過程: \n \n Python ZMQ remote API 控制程式如下: \n # pip install pyzmq cbor keyboard\nfrom coppeliasim_zmqremoteapi_client import RemoteAPIClient\nimport keyboard\n\n# Connecting to the CoppeliaSim server\nclient = RemoteAPIClient(\'localhost\', 23000)\n\nprint(\'Program started\')\nsim = client.getObject(\'sim\')\n\n# Get the handle for the slider (prismatic joint)\nslider = sim.getObject(\'/Prismatic_joint\')\n\n# Starting the simulation\nsim.startSimulation()\nprint(\'Simulation started\')\n\n# Main control loop\ndef main():\n    # Keep running until simulation is stopped\n    while True:\n        if keyboard.is_pressed(\'w\'):  # Move slider to -0.15 position\n            print("w is pressed")\n            sim.setJointTargetPosition(slider, -0.15)\n        \n        if keyboard.is_pressed(\'s\'):  # Reset slider to the original position\n            print("s is pressed")\n            sim.setJointTargetPosition(slider, 0.0)  # Reset to the initial position\n\n        if keyboard.is_pressed(\'q\'):  # Stop the simulation when \'q\' is pressed\n            print("q is pressed - stopping simulation")\n            sim.stopSimulation()\n            break\n\n# Start the main control loop\nmain()\n \n', 'tags': '', 'url': 'w14.html'}, {'title': 'w15', 'text': '請各學員連結到  https://mde.tw/cad2024/content/w14.html , 透過教學影片了解如何將 Solvespace 或 NX2312 所建立的 Flipper 機構零組件轉入 CoppeliaSim 建立機電模擬系統. \n 各組完成 Flipper 系統模擬之後, 著手將  http://229.cycu.org/cd2023_pj3ag4_zmq_football_4.7.7z  中的記分板 (先嘗試導入數位版, 之後再設法導入類比版), 開始建立各組的 CoppeliaSim 模擬彈珠檯. \n W16 開始各組員準備就 CoppeliaSim 模擬彈珠檯專案進行報告. \n \n flipper_in_solvespace_cw_and_ccw_w14.7z \xa0中的 flipper 零件從 62mm 轉入 CoppeliaSim 場景後成為 62cm, 尺寸計放大 10 倍, 因此整體彈珠台也將從 56cm x 130cm 放大到 560cm x 130cm, 也就是 CoppeliaSim 中檯體面板的尺寸設為 5.6m x 13m, 使得原先的地板 5m x 5m 過小, 因此選擇刪除原先的內建 Floor, 改用 infrastructure - floor 中的 infiniteFloor 模型. \n 彈珠檯面板 - 560cm x 130cm 厚度 15cm, 在 Solvespace 中以 560mm x 130mm x 15mm 繪圖, 轉入模擬場景時採 z 軸向上, Scaling 為 0.01, 表示尺寸放大 10 倍. \n 請各組接續  w15.7z  中的相關檔案完成期末彈珠台系統模擬. \n', 'tags': '', 'url': 'w15.html'}, {'title': 'w16', 'text': '接續\xa0 flipper_in_solvespace_cw_and_ccw_w14.7z \xa0中的 Solvespace 零組件繪圖, 配置與彈珠台面板連接的固定板後的組立, 如下圖: \n \n flipper_in_solvespace_cw_and_ccw_w16.7z \n', 'tags': '', 'url': 'w16.html'}, {'title': 'References', 'text': 'What do I do as a mechanical design engineer? \n Overview of mechanical design engineering \n What does a mechanical design engineer do? \n Guide to mechanical design engineering course \n References \xa0 \n CAD: \n 2010\xa0THE FUTURE AND THE EVOLUTION OF CAD \n cadbook.pdf  (from cadp2018 course) \n cad_history.pdf   (from cadp2018 course) \n NX-12-for-Engineering-Design.pdf  (from\xa0 https://me5763.github.io/lab/assets/books/NX-12-for-Engineering-Design.pdf ) \n Git: \n Git for Electronic Circuit Design - CAD and Version Control for Electrical Engineers.pdf \xa0(from\xa0 Springer ) \n ODOO: \n https://github.com/odoo/odoo \xa0 \n https://mde.tw/pj4101 \xa0 \n Video: \n https://vimeo.com/user24079973 \n https://www.youtube.com/@-kmolab9376', 'tags': '', 'url': 'References.html'}, {'title': 'Parts', 'text': 'https://support.industrysoftware.automation.siemens.com/training/se/en/ST3/pdf/spse01550.pdf \xa0 (零件繪圖練習只要畫到 page 32) \n cad2024_practice_9_page_32.pdf \n \n \n cad2024_part_ex1_solvespace.7z \n \n \n \n    可以添加更多的 canvas  \n Model Color:  Back Color1:  Back Color2:  Render Mode: \n Flat \n Point \n Wireframe \n Smooth \n Definition: \n Standard \n low \n high \n \n \n \n \n \n 上述 iframe 的標註 src 為: \n https://mde.tw/cad2024/cmsimde/static/viewstl.html?src=https://s104.cycu.org/~pj2023/cad2024_part_ex1_solvespace.stl \xa0 \n 以上 STL 除了放在倉儲 downloads 目錄之外, 也可上傳到可以接受\xa0Cross-Origin Resource Sharing (CORS) 的 WWW server, 目前已經設定一台 s104.cycu.org 可以讓使用者透過 sftp 將零組件轉出的 STL 上傳到使用者的 public_html 目錄, 並透過 "~用戶名稱/STL 檔案名稱"進行連結. 以下為該 server 的必要設置: \n 1. 必須與作業網站的 https 連結相同 - 可透過\xa0 Let\'s Encrypt (letsencrypt.org) \xa0設置, 其中  Windows 套件為 v2.9.0 . \n 2. 有關 s104.cycu.org 中 nginx 的用戶 public_html 設置必須允許跨網站連結: \n # 處理 /~username/ 格式的請求\nlocation ~ ^/~(.+?)(/.*)?$ {\n    alias C:/Users/$1/public_html$2;\n    index index.html;\n    autoindex on;\n    # try to resolve the COR\'s issue\n    add_header \'Access-Control-Allow-Origin\' \'*\' always;\n    add_header \'Access-Control-Allow-Methods\' \'GET, OPTIONS\' always;\n    add_header \'Access-Control-Allow-Headers\' \'Content-Type\' always;\n\n    if ($request_method = \'OPTIONS\') {\n        add_header \'Access-Control-Allow-Origin\' \'*\' always;\n        add_header \'Access-Control-Allow-Methods\' \'GET, OPTIONS\' always;\n        add_header \'Access-Control-Allow-Headers\' \'Content-Type\' always;\n        return 204;\n    }\n} \n 3. 使用者必須設定其帳號下的 public_html 具有寫入檔案的權利, 以 scrum1 帳號為例, ssh 進入後, 利用 mkdir 建立 public_html 目錄後, 可以利用下列指令讓 public_html 可以寫入. \n icacls "C:\\Users\\scrum1\\public_html" /grant scrum1:(OI)(CI)F\n\nREM OI (Object Inherit) allows files in the folder to inherit these permissions.\nREM CI (Container Inherit) allows subfolders to inherit these permissions.\nREM F grants full control.\n \n \n Solvespace 零件繪圖: \n Sketch Rectangle (R) \n Tangle Arc at Point (Shift + A) \n Sketch Circle (C) \n Constraint distance / diameter / length (D) \n New group extruding active sketch (X) \n Sketch line segment (S) \n Sketch In Workplane (2) \n Toggle construction (G) \n Sketch in new workplane (Shift + W) - one point and specific orientation, origin and two lines \n NX 零件繪圖: \n Shift + mouse middle button pressed and move = Pane \n Ctrl + f key = Fit \n Sketch \n Rectangle From Center \n Fillet \n Circle \n Line \n Arc \n Center mouse click = Finish \n Include - Includes and projects external objects into the sketch \n Dimension - Display as PMI \n Datum Plane \n Two Lines \n Extrude \n Width - Value, Symmetric Value \n \n cad2024_part_ex1_nx2312.7z \n cad2024_part_ex1_nx1872.7z \n \n', 'tags': '', 'url': 'Parts.html'}, {'title': 'Solv_parts', 'text': '說明如何利用 Solvespace 繪製下列零件: \n \n \n 採用 Solvespace 作圖: \n page16.7z \n page16_core.slvs 為零件的核心物件, page16_material.slvs 則為其外圍物件, page16_final.slvs 為 page_material.slvs 作為基材, 利用組立導入後, 再以 page16_core.slvs 進行除料, 之後再補上下兩個物件. \n \n \n \n page2-24_one_piece_slvs.7z \n \n Model Color:  Back Color1:  Back Color2:  Render Mode: \n Flat \n Point \n Wireframe \n Smooth \n Definition: \n Standard \n low \n high \n \n \n \n \n', 'tags': '', 'url': 'Solv_parts.html'}, {'title': 'NX_parts', 'text': '以下影片說明如何配置 NX2312: \n \n \n 採 NX2312 繪製: \n 新增 Model, 選擇以 inches 作為繪圖單位 \n 選擇 Sketch 繪製草圖 \n 選擇在 Top 工作面上繪製底部正方形 (尺寸透過計算為 4.25x4.25) \n 選擇 Datum Plane 建立工作面 \n 選擇 At Distance, 從 Top 工作面 (距離底部2.375) 往上建立上部較小的正方形 (1.875x1.875) \n 從 Toolbar Options 帶出 Menu \n 從 Menu - Insert - Mesh Surface - Through Curves 利用上下兩個正方形建立 loft 實體 (Alignment 必須選擇 Preserve Shape) \n 根據 .375 厚度, 對 loft 實體轉為薄殼 (選擇上下底部挖空), 之後再補上下兩個實體 \n 上部實體可以使用 Include 取得外圍 1.875x1.875 的正方形, 內部則為 1.125x1.125 正方形, 長出實體高度則為 0.75 \n 接著因為 Shell 頂部正方形開口小於 1.125x1.125, 因此需要在 Shell 頂部繪製一個 1.125x1.125 的正方形往下進行除料 \n 最後再底部長出一個 5.25x5.25 且四邊倒圓角半徑 0.5 的外圍正方形, 內部正方形為 3.411x3.411, 完成後向上長出 0.5 實體即完成 \n 利用上述流程建立的零件:  page16_w9.prt \n \n \n page16_nx2312.prt \n \n    可以添加更多的 canvas  \n \n 作圖流程: 依據上述尺寸分別長出實體之後, 使用 Unite 將各長出的實體合併後, 使用 Edge Blend 在各相接的 Edge 進行倒圓 \n page2-24_nx2312.7z \n    可以添加更多的 canvas  \n \n Model Color:  Back Color1:  Back Color2:  Render Mode: \n Flat \n Point \n Wireframe \n Smooth \n Definition: \n Standard \n low \n high \n \n \n 參考: \n page16_nx_loft.prt  (NX2312) \n https://www.youtube.com/watch?v=hvAf9XESqmQ \n', 'tags': '', 'url': 'NX_parts.html'}, {'title': 'Exercises', 'text': 'https://www.solidworks.com/sw/docs/mountainboard_student_wb_2011_eng.pdf \n https://www.solidworks.com/sw/docs/cswasampleexam2007.pdf \n https://www.solidworks.com/sw/docs/Student_WB_2011_CHT.pdf  ( ENG ) \n', 'tags': '', 'url': 'Exercises.html'}, {'title': 'BonW', 'text': 'Balance on Wheels \n https://github.com/mdecycu/Balance_On_Wheels \n \n 專案第一階段執行過程: \n \n 利用 Solvespace 建立零組件 \n 將零組件轉入 CoppeliaSim \n 根據系統零組件從屬關係進行零件組立 \n 針對系統動態運動模型運算簡化零件 \n 進行初步開放系統的運動模擬 \n 加入所需致動器與感測器 \n 針對系統運動設定零件起始位置與機構運動範圍 \n 利用 ZMQ Remote API 程式進行回授控制系統設計 \n \n 專案第二階段執行過程: \n \n 利用 NX2312 建立零組件 \n 將零組件轉入 CoppeliaSim \n 根據系統零組件從屬關係進行零件組立 \n 針對系統動態運動模型運算簡化零件 \n 進行初步開放系統的運動模擬 \n 加入所需致動器與感測器 \n 針對系統運動設定零件起始位置與機構運動範圍 \n 利用 ZMQ Remote API 程式進行回授控制系統設計 \n \n 專案第三階段執行過程: \n \n 利用 NXOpen 評估能否採二次程式開發流程建立系統零組件 \n 利用 CoppeliaSim 的 Simple XML 模型檔案格式, 評估能否直接利用 NX2312 轉出的零件 STL 檔案建立模擬場景 \n 結合 Jupyterlab 的 collaborative 模式 (或 Linux 上的 Jupyterhub server), 評估將潛在客戶導入協同產品設計的可行性 \n \n \n \n', 'tags': '', 'url': 'BonW.html'}, {'title': 'Quadruped', 'text': 'pj40922_downloads.7z \n \n \n \n Actuator module: \n \n \n quadruped_8dof_v2_sw_nx.7z \xa0(built with Solidworks and open\xa0under NX2312) ( File source ,  site ) \n 2020 An Open Torque-Controlled Modular Robot Architecture for Legged Locomotion Research \xa0( Journal ) \n 2024 Learning-based legged locomotion state of the art and future perspectives \n 2024 Planar Motion Control of a Quadruped Robot \xa0( Github ) \n https://github.com/mdecycu/quadruped \xa0 \n https://github.com/mdecycu/Eklavya-QuadrupedMotionSimulation \xa0 \n https://github.com/mdecycu/jelly_mechanical \n \n https://pupper-independent-study.readthedocs.io/en/latest/ \n \n https://github.com/dagor-dev \n https://github.com/mdecycu/DingoQuadruped \n DINGO_QUADRUPED_CAD.7z \n \n \n', 'tags': '', 'url': 'Quadruped.html'}, {'title': 'Rover', 'text': 'https://github.com/Roger-random/Sawppy_Rover \xa0( in Onshape ) \n \n 40723221_2019_rover.7z \n 40723221_2019_curiosity.7z \n 1996  Rocky_Mars_Rover_Prototyp.pdf \xa0( Source ) \n https://science.nasa.gov/mars/ \xa0 \n https://science.nasa.gov/mission/msl-curiosity/ \xa0 \n Curiosity mars rover 3D model \n Design and terramechanics analysis of a Mars rover utilising active suspension \n 2004_Design_of_a_Mars_Rover_Suspension_Mechanism.pdf \n \n', 'tags': '', 'url': 'Rover.html'}, {'title': 'meArm', 'text': 'Foundation of Robotics  (Course document) \n Elements of Robotics  (Open ebook) \n uArm_manipulator_en.pdf  ( uArm_manipulator_es.pdf ) \n \n \n Forward Kinematics and Inverse Kinematics of uArm robot: \n Inverse Kinematics: \n 利用  sympy  根據  meArm Pi Technical Overview  中的說明 (修正錯誤後), 解出 Inverse Kinematics 如下: \n 當已知 manimpulator 端點的座標為 (x, y ,z) 時, 求 theta, ltheta (low arm link theta) 與 utheta (upper arm link theta). 利用  sympy  之前必須先以 pip install sympy 安裝模組. \n import sympy as sp\n   \n# Define symbols\ntheta, ltheta, utheta, r, x, y, z = sp.symbols("theta ltheta utheta r x y z")\n   \n# Define equations, rearranged so expressions equal 0\neq1 = 15 + 50 + 80*sp.sin(ltheta) + 80*sp.sin(utheta) - r\neq2 = 53 + 80*sp.cos(ltheta) - 80*sp.cos(utheta) - z\n# 從 eq3 與 eq4 可以得到 eq5 與 eq6, 將 r 及 theta 表示成 x, y 輸入的函式\n# 因此 r 與 theta 在得知 x, y, z 時就可視為已知\neq3 = r*sp.cos(theta) - x\neq4 = r*sp.sin(theta) - y\neq5 = sp.sqrt(x*x + y*y) - r\neq6 = sp.atan(y/x) - theta\n   \n# Solve for theta1 & theta3\nsolution = sp.solve([eq1, eq2], [ltheta, utheta], dict=True)\nprint(solution)\n   \n\'\'\'\n[{ltheta: pi - asin(r/80 + sin(2*atan((-160*r + sqrt(-r**4 + 260*r**3 - 2*r**2*z**2 + 212*r**2*z - 5368*r**2 + 260*r*z**2 - 27560*r*z - 1499160*r - z**4 + 212*z**3 + 296*z**2 - 1222392*z + 130593244) + 10400)/(r**2 - 130*r + z**2 - 266*z + 15514))) - 13/16), \n   \nutheta: -2*atan((-160*r + sqrt(-r**4 + 260*r**3 - 2*r**2*z**2 + 212*r**2*z - 5368*r**2 + 260*r*z**2 - 27560*r*z - 1499160*r - z**4 + 212*z**3 + 296*z**2 - 1222392*z + 130593244) + 10400)/(r**2 - 130*r + z**2 - 266*z + 15514))}, \n   \n{ltheta: asin(-r/80 + sin(2*atan((160*r + sqrt(-r**4 + 260*r**3 - 2*r**2*z**2 + 212*r**2*z - 5368*r**2 + 260*r*z**2 - 27560*r*z - 1499160*r - z**4 + 212*z**3 + 296*z**2 - 1222392*z + 130593244) - 10400)/(r**2 - 130*r + z**2 - 266*z + 15514))) + 13/16) + pi, \n   \nutheta: 2*atan((160*r + sqrt(-r**4 + 260*r**3 - 2*r**2*z**2 + 212*r**2*z - 5368*r**2 + 260*r*z**2 - 27560*r*z - 1499160*r - z**4 + 212*z**3 + 296*z**2 - 1222392*z + 130593244) - 10400)/(r**2 - 130*r + z**2 - 266*z + 15514))}, \n   \n{ltheta: -asin(-r/80 + sin(2*atan((160*r + sqrt(-r**4 + 260*r**3 - 2*r**2*z**2 + 212*r**2*z - 5368*r**2 + 260*r*z**2 - 27560*r*z - 1499160*r - z**4 + 212*z**3 + 296*z**2 - 1222392*z + 130593244) - 10400)/(r**2 - 130*r + z**2 - 266*z + 15514))) + 13/16), \n   \nutheta: 2*atan((160*r + sqrt(-r**4 + 260*r**3 - 2*r**2*z**2 + 212*r**2*z - 5368*r**2 + 260*r*z**2 - 27560*r*z - 1499160*r - z**4 + 212*z**3 + 296*z**2 - 1222392*z + 130593244) - 10400)/(r**2 - 130*r + z**2 - 266*z + 15514))}, \n   \n{ltheta: asin(r/80 + sin(2*atan((-160*r + sqrt(-r**4 + 260*r**3 - 2*r**2*z**2 + 212*r**2*z - 5368*r**2 + 260*r*z**2 - 27560*r*z - 1499160*r - z**4 + 212*z**3 + 296*z**2 - 1222392*z + 130593244) + 10400)/(r**2 - 130*r + z**2 - 266*z + 15514))) - 13/16), \n   \nutheta: -2*atan((-160*r + sqrt(-r**4 + 260*r**3 - 2*r**2*z**2 + 212*r**2*z - 5368*r**2 + 260*r*z**2 - 27560*r*z - 1499160*r - z**4 + 212*z**3 + 296*z**2 - 1222392*z + 130593244) + 10400)/(r**2 - 130*r + z**2 - 266*z + 15514))}] \n \n', 'tags': '', 'url': 'meArm.html'}, {'title': 'CAD', 'text': 'Engineers Edge:  https://www.engineersedge.com/ \n Computer Aided Design: \n https://en.wikipedia.org/wiki/Polygon_mesh \n https://en.wikipedia.org/wiki/Constructive_solid_geometry \n https://fr.wikipedia.org/wiki/B-Rep \n 2015 Space Modeling with SolidWorks and NX \n Pymadcad (執行的電腦需要配置獨立顯卡): \n https://madcad.netlify.app/ \n https://pymadcad.readthedocs.io/en/latest/reference/index.html \n https://github.com/jimy-byerley/pymadcad  ( https://github.com/mdecycu/pymadcad ) \n Modification:  Render Text  using UTF-8 encoding \n https://pymadcad.readthedocs.io/en/latest/algorithms/gearprofile.html \n https://github.com/jimy-byerley/uimadcad  ( https://github.com/mdecycu/uimadcad ) \n .ply io.read and io.write -  https://github.com/dranjan/python-plyfile  ( https://github.com/mdecycu/python-plyfile ) \n .stl io.read and io.write -  https://github.com/WoLpH/numpy-stl  ( https://github.com/mdecycu/numpy-stl ) \n .obj io.read and io.write -  https://github.com/pywavefront/PyWavefront  ( https://github.com/mdecycu/PyWavefront ) \n 系統先安裝  https://visualstudio.microsoft.com/zh-hant/visual-cpp-build-tools/ \n 重新開機後, 啟動可攜程式系統, 利用 pip install pymadcad numpy numpy-stl plyfile pywavefront uimadcad \n git clone  https://github.com/mdecycu/pymadcad.git \n 利用可攜系統中的 SciTE 開啟 examples 目錄中的 axis-holder.py 修改 write() 如下後, 利用 Tools - Go 執行. \n 啟動 uimadcad: python -m uimadcad \n from madcad import *\n\n# define a base of vectors: origin and directions\nO = vec3(0,0,0)\nX = vec3(1,0,0)\nY = vec3(0,1,0)\nZ = vec3(0,0,1)\n\n# part parameters\ndint = 20\ndext = 100\nh = 30\nrvis = dext/3\ndvis = 3\nhvis = 3\n\n\n# create the revolution profile, called \'cone\'\n# --------------------------------------------\n\nB = vec3(dint/2, 0, 0)\nS = vec3(dint/2, 0, h)\nE = vec3(dext/2, 0, 0)\nEh = E+2*Z\nSe = S+5*X\n# sketch a profile\nline = [\n\tSegment(B,S),\n\tArcCentered(((Se+S)/2, Y), S, Se),\n\tSegment(Se, Eh),\n\tSegment(Eh, E),\n\tSegment(E, B),\n\t]\n# mutate the profile to fit some geometrical constraints\nsolve([\n\t\tTangent(line[0], line[1], S),\n\t\tTangent(line[1], line[2], Se),\n\t\tRadius(line[1], 5),\n\t\tDistance(E, Eh, 10),\n\t\tOnPlane((O,Y), [B,S,E,Eh,Se]),\n\t\t],\n\tfixed=[O,X,Y,Z,B,S,E],\n\tprecision=1e-12\n\t)\n# generate the cone\ncone = revolution(\n\t\t\tradians(360), \n\t\t\t(O,Z), \n\t\t\tweb(line))\n# merge the start and end sections of the revolution (because its a 360° revolution)\ncone.mergeclose()\n# chamfer the lower edge: this is a chamfer over a circular edge\nchamfer(cone, cone.frontiers((0,4)), (\'depth\', 3))\n\n\n\n# create the slots for screws\n# ---------------------------\n# we remove a partially defined volume\n\nrplace = dvis*3+2\nC = vec3(rvis,0,hvis)\nA = vec3(rvis, rplace,hvis)\nB = vec3(rvis,-rplace,hvis)\nAe = A+vec3(dext/2, 60,0)\nBe = B+vec3(dext/2,-60,0)\n# sketch its line\nline = [\n\tSegment(Ae, A),\n\tArcCentered((C,Z), A, B),\n\tSegment(B, Be),\n\t]\nsolve([\n\t\tTangent(line[0], line[1], A),\n\t\tTangent(line[2], line[1], B),\n\t\tRadius(line[1], 3*dvis),\n\t\tDistance(Ae, O, dext),\n\t\tDistance(Be, O, dext),\n\t\tAngle(Segment(Ae,A), Segment(Be,B), radians(60)),\n\t\tOnPlane((C,Z), [A,B,Ae,Be]),\n\t\t],\n\tfixed=[O,X,Y,Z,C],\n\tprecision=1e-12,\n\t)\n# extrude that base line and add a bottom face\nplace = (\textrusion(vec3(0,0,h), line) \n\t\t+\tflatsurface(wire(line).flip())\n\t\t)\n# merge outlines of both generated faces\nplace.mergeclose()\n# round the cutting edge to have smooth transition\nbevel(\n\tplace, \t\n\t(   place.frontiers(0,3) \t# this is the frontier line between group 0 and group 3\n\t  + place.frontiers(1,3) \t# this is the frontier line between group 1 and group 3\n\t  + place.frontiers(2,3) ), \n\t(\'depth\', 2))\n\n# make the screw holes:\n# a cylinder (not necessarily closed on its ends as we don\'t care of that surfaces)\nvis = extrusion(vec3(0,0,-2*h), web(Circle((C+vec3(0,0,h),-Z), dvis)))\n\n\n# assemble everything\n# -------------------\n# get 6 shapes with the slot and the hole for the scren\nbig = repeat(\n\t\tunion(place, vis), \t# this union cuts the slot to add the hole\n\t\t6, rotatearound(radians(60), (O,Z)))\n# cut the cone to put the slots and holes\npart = difference(cone, big)\n# this is the final touch for parts: optimize the buffers and check mesh validity\npart.finish()\n\n\n\n\n# if we want we can at any moment place some fancy notes\nnotes = [\n\tnote_leading(part.group(2), text="conic surface"),\n\tnote_leading(part.group(11), vec3(-5,0,-10), text=\'ø\'+str(dvis)),\n\t]\n\n# write the part to a ply file\n#write(part, \'tests/axis-holder.ply\')\nwith open(\'tests/axis-holder.ply\', \'w\') as f:\n    f.write(str(part))\n\n# display what we want\nshow([part, notes])\n \n pymatcad solid read and write to stl, obj and ply: \n from madcad import *\ns = screw(10, 20) # s is a `Solid`\n# Write\nio.write(s["part"], "screw.stl")\n# Read\nread_mesh = io.read("screw.stl")\nread_mesh.mergeclose()\nshow([read_mesh]) \n Solvespace \n SolveSpace 所提供的主要功能: \n 1. 2D 草圖設計:  - 繪製基本 2D 形狀(線、矩形、圓等)  - 添加約束(長度、距離、角度等)  - 完全參數化設計 \n 2. 3D 實體建模:  - 通過擠出、旋轉等方式從 2D 草圖生成 3D 實體  - 支持 3D 實體的布林運算(並集、差集、交集)  - 提供渲染和陰影視覺效果 \n 3. 參數化和約束求解:  - 可添加各種幾何和代數約束  - 支持尺寸驅動設計  - 自動求解過約束或過約定系統 \n 4. 分析工具:  - 質量屬性分析(體積、表面積、質心等)  - 公差分析  - 運動學模擬(僅限簡單機構) \n 5. 輔助建模工具:  - 添加工程參考幾何(平面、軸線等)  - 支持配置不同的草圖視圖和投影視圖 \n 6. 開發者擴展性:  - 開源代碼,支持定製化擴展  - 可通過 C++、Python 等語言擴充功能 \n 7. 操作界面:  - 傳統的圖形用戶界面  - 支持鍵盤快捷鍵和命令行輸入 \n 8. 導入導出格式:  - 支持導入/導出 STEP、STL、DXF 等 CAD 文件格式  - 可嵌入網頁或其他應用程序 \n Onshape \n Onshape 是一款基於雲端的3D CAD軟體,它提供了許多功能來協助設計和工程工作。Onshape 作為全功能的雲端CAD工具,提供了建模、協作、分析、數據管理等全面的功能,適合用於產品設計、工程項目等領域。 \n 以下是 Onshape 提供的主要功能: \n 1. 全功能3D參數式建模工具: \n - 實體和曲面建模  - 參數化和約束幾何體  - 自動生成製造製圖  - 直覺式草圖工具 \n 2. 直接編輯功能: \n - 不需要返回設計樹狀結構  - 可以直接編輯和修改現有幾何體 \n 3. 版本控制和分支: \n - 類似 Git 的版本控制系統  - 可以創建分支和合併分支  - 方便協作和跟踪修改歷史 \n 4. 數據管理和整合: \n - 整合PDM/PLM系統  - 材料庫和標準件庫  - Onshape App Store 提供各種插件 \n 5. 實時協作和評註: \n - 多人同時編輯同一個文件  - 添加評註和討論設計細節 \n 6. 模擬和分析工具: \n - 有限元分析(FEA)  - 運動學模擬  - 碰撞檢測 \n 7. 雲端計算和存儲: \n - 無需安裝軟體  - 所有設計都存儲在雲端  - 可隨時隨地訪問 \n 8. 開放API和集成: \n - 可與其他軟體系統集成  - 提供API進行自動化和定製 \n', 'tags': '', 'url': 'CAD.html'}, {'title': 'Q_AI', 'text': 'Questions for AI \n 請問 Solvespace 程式的編寫用到那些理論? \n From Claude.ai: \n SolveSpace 主要運用以下幾個理論領域: 1. 幾何約束求解理論: - 使用符號代數方法處理幾何約束系統 - 應用數值優化方法求解非線性方程組 - 採用 DOF (自由度)分析來判斷約束是否充分 2. 計算幾何學: - 向量和矩陣運算 - 三維空間中的線段、曲線、曲面表示 - 布林運算(Boolean operations)的實現 - NURBS 曲線和曲面的數學表示 3. 圖形學理論: - OpenGL 渲染管線 - 光照模型 - 視圖變換 - 深度測試 4. 數值計算方法: - Newton-Raphson 迭代法求解非線性方程 - QR 分解等矩陣運算 - 數值積分和微分 5. 參數化建模理論: - 特徵建模(Feature-based modeling) - 歷史樹(History tree)結構 - 參數關聯性管理 \n 能分別列出幾本重要的參考書嗎? 1. 幾何約束求解理論: - " Geometric Constraint Solving and Applications " by Beat Brüderlin & Dieter Roller - " Geometric Constraint Solving " by Glenn A. Kramer ( Solving Geometric Constraints ) - "Engineering Design with SolidWorks" by David C. Planchard (包含約束系統的實務應用) 2. 計算幾何學: - " Computational Geometry: Algorithms and Applications " by Mark de Berg et al. - "NURBS: From Projective Geometry to Practical Use" by Gerald Farin ( The NURBS Book ) - " Geometric Tools for Computer Graphics " by Philip Schneider & David H. Eberly 3. 圖形學理論: - "Computer Graphics: Principles and Practice" by John F. Hughes et al. - "OpenGL Programming Guide" (俗稱紅皮書) - "Real-Time Rendering" by Tomas Akenine-Möller et al. 4. 數值計算方法: - "Numerical Recipes: The Art of Scientific Computing" by William H. Press et al. - "Matrix Computations" by Gene H. Golub & Charles F. Van Loan - "Applied Numerical Linear Algebra" by James W. Demmel 5. 參數化建模理論: - "Parametric and Feature-Based CAD/CAM" by Jami J. Shah & Martti Mäntylä - "Product Design Modeling using CAD/CAE" by Kuang-Hua Chang - "Feature-Based Product Life-Cycle Modelling" by Jos van den Berg et al. \n Beginning C \n Beginning C++23 \n', 'tags': '', 'url': 'Q_AI.html'}, {'title': 'NX', 'text': 'NX2312 設定: \n Journal 程式語言選定: File - Preferences - User Interface - Tools - Journal \n 可選擇的程式語言, 包括 C#、C++、Java、Python 與 Visual Basic 等. \n Journal 程式執行或錄製選擇: Menu - Tools - Automation - Journal \n 可選擇: Play、Record、Edit 與 Insert 等. \n \n NX Tutorial \n 西門子NX的發展歷程可以追溯至 1969 年, 當時麥道公司成立了自動化部門 McAuto, 開始發展內部 CAD/CAM系統CADD。CADD 最初運行於 IBM 360/40 電腦上,並使用 IBM 2250 圖形顯示終端機。 \n 1976年, McAuto 收購了 United Computing, 獲得該公司開發的互動式 CAD 系統 Unigraphics。Unigraphics 最初運行於通用自動化 SPC-16 小型機上, 並使用 Tektronix 顯示終端機。 \n 1982年, McAuto 開始開發新一代 Unigraphics II, 目標是打造更強大的三維設計、繪圖和 NC 加工系統。Unigraphics II 1.0 版於 1983 年發布,首次支援圖形著色。 \n 1985年, 麥道公司將 McAuto 重組為 McDonnell Douglas Information Systems Company, Unigraphics 歸入其中。 \n 1988年, 麥道公司收購 Shape Data, 獲得其開發的 Parasolid 幾何造型核心。 \n 1989年, Unigraphics 7.0 版發布, 首次支援 Parasolid 造型核心。 \n 1991年, 電子資料系統公司收購 MISCO, Unigraphics 成為 EDS 的一部門, 更名為 EDS Unigraphics。 \n 1992年, Unigraphics 10.0 版發布, 強調參數化設計和三維造型。 \n 1996年, Unigraphics 12.0 版發布, 首次支援 Windows NT 平台, 並加入 UG Scenario 分析軟體。 \n 1997年, Unigraphics 13.0 版發布, 引入 WAVE 技術, 提高設計效率。 \n 1998年, EDS 成立 Unigraphics Solutions, 完成對 Intergraph 機械部門的收購, 合併 Solid Edge 產品線。 \n 1999年, UGS 發布 Unigraphics 16.0 版, 強調基於網路的協同設計。 \n 2000年, EDS 將 UGS 拆分為獨立公司並上市。UGS 發布 Unigraphics 17.0 版, 首次支援 JT 數據交換格式。 \n 2001年, EDS 收購 SDRC, UGS 成為 EDS PLM Solutions 的一部分, 更名為 EDS PLM Solutions。 \n 2002年, UGS PLM Solutions 發布 NX 1.0 版, 旨在整合 Unigraphics 和 I-DEAS。 \n 2003年, UGS PLM Solutions 發布 NX 2.0 版, 改進使用者介面和知識庫設計。 \n 2004年, UGS 被 Bain Capital、Silver Lake Partners 和 Warburg Pincus 等三家私募股權公司收購,更名為 UGS Corporation。同年發布 NX 3.0 版, 實現 Unigraphics 和 I-DEAS 的整合。 \n 2007年, 西門子公司收購 UGS Corporation, 更名為 Siemens PLM Software, NX 成為其旗艦產品。同年發布NX 5.0 版, 進一步最佳化使用者介面和模型編輯功能。 \n 2007年之後的版本請參考:\xa0 https://en.wikipedia.org/wiki/Siemens_NX \xa0 \n https://github.com/mdecycu/nxlab \xa0 \n https://github.com/me5763 \xa0 \n \n NX2312 需要 Windows 操作系統帶有\xa0Windows Desktop Runtime 6.0.16. \n NX2312 client 連線到認證主機設定採 29000 時, client 端需要讓防火牆可以對 29000 與 29001 port 連外, 至於 server 端則需要讓防火牆可以對 29000 與 29001 port 連入. \n NX2312 與 NX2406 已經不再使用 VENDOR ugslmg 執行認證, 也就是不再需要 ugslmg.exe, 而是採用 Siemens Advanced Licensing Technology Daemon ( SALTD ), 並且透過 Mentor Standard Licensing (MSL) - (mgcld) utility 進行使用授權認證, license file 設定更動如下: \n SERVER 伺服器名稱 COMPOSITE=對應的編碼 29000\nVENDOR saltd saltd PORT=29001 \n 完整的 NX2312 總共有超過 11 萬個檔案, 總容量超過 33 GB. \n 開啟 NX - NX2312\\NXBIN\\ugraf.exe -nx \n 開啟 NX 2D Edit - NX2312\\NXBIN\\nx2dedit.exe \n 開啟 NX Layout - NX2312\\NXBIN\\ugraf.exe -layout \n 開啟 NX Viewer - NX2312\\NXBIN\\ugraf.exe -view \n 開啟 Simcenter 3D - NX2312\\NXBIN\\simcenter3d.exe \n 開啟 Sincenter 3D Results ㄒiewer - NX2312\\NXBIN\\simcenter3d.exe -simviewer \n 開啟 Simens Mechatronics Concept Designer - NX2312\\NXBIN\\ugraf.exe -mechatronics \n 開啟 NX Manufacturing - NX CAM - NX2312\\NXBIN\\ugraf.exe -nxcam \n NX3 Help Library  (for internal IPv6 users only) \n NX2312 DOC  (英文) \n MenuScript \n NX2312 DOC  (中文) \n 草圖  (Sketch) \n 建模  (Modeling) \n 創意塑型  (Realize Shape) \n 組立  (Assembly) \n 效能預測器  (Performance Predictor) \n Design Simulation \n Simcenter 3D  ( Simulation with NX / Simcenter 3D  or  local download ) \n', 'tags': '', 'url': 'NX.html'}, {'title': 'NX_DOC', 'text': 'NX2312 官方文件 \xa0中文語系為 zh-TW, 英文為 en-US \n 探索 NX2312 \n 使用 NX2312 \n 草圖 \xa0(Sketch) \n 零件建模 \xa0(Modeling) \n 製圖簡介 \xa0(Drafting) \n 組立  (Assembly) \n \n 快速選取  (Quick Pick) \n 旋轉 - 滑鼠中鍵 \n 平移 -  中右鍵同時按 或 Shft + 中鍵 \n 縮放 - 中鍵滾輪 \n \n 如果可能， 較好的做法是在基準平面上繪製草圖，而不是在零件面上繪製草圖 。如果您需要模型中有其他基準座標系或基準平面，首先建立它們，並相對於模型中的第一個基準座標系來定位它們。 \n \n 在零件導覽器中以藍色列出的特徵是選定特徵的子特徵。以紅色列出的特徵是父特徵。 \n Features listed in blue in the Part Navigator are children of the selected feature. Features listed in red are parents.', 'tags': '', 'url': 'NX_DOC.html'}, {'title': 'Ebooks', 'text': "Mechanical Design  or  local download \n Mechanical Design Engineering Handbook  or  local download \n Mechanical Engineer's Handbook  or  local download \n Product Design Modeling using CAD/CAE  or  local download \n Advanced Engineering Dynamics  or  local download \n Advanced Vehicle Technology  or  local download \n Vehicle Collision Dynamics  or  local download \n Linear Feedback Controls  or  local download \n Mechatronics  or  local download \n Sensors for Mechatronics  or  local download \n Analog Circuits Design  or  local download \n Op Amps for Everyone  or  local download \n NX CAD Tutorial \n NX Surface Tutorial", 'tags': '', 'url': 'Ebooks.html'}, {'title': 'NX3', 'text': "下載 \xa0NX3 可攜 CAD/CAE 壓縮檔案 (196 MB, 解開壓縮後約 761 MB) \n NX3 尚無 NXOpen Python 延伸程式開發架構, 僅能以 Visual Basic、C 或 C++ 執行開發. \n NX3 Help Library \xa0(for internal IPv6 users only) \n UGOpen C 程式架構請參考 \xa0 UG_Open-API_Programming.pdf \n UGOpen 技術文件請參考: \n Open C Programmer's Guide \xa0 (for internal IPv6 users only) \n Open C Reference Manual \xa0 (for internal IPv6 users only) \n", 'tags': '', 'url': 'NX3.html'}, {'title': 'NX12', 'text': 'File - Utilities - Customer Defaults - General - Miscellaneous \n Product Excellence Program -\xa0 turn off the Participate and Display initial Message \n \n NX12 NXOpen Python 動態連結程式庫採用 Python\xa03.6.5 版本編譯. \n 下載  NX12_CAD_portable.7z (947 MB, 解開壓縮後約 4.7 GB) \n', 'tags': '', 'url': 'NX12.html'}, {'title': 'NX1872', 'text': '可攜 NX1872 製作: \n nx1872_from_installed_to_portable_batch_setup.7z  中的檔案可以說明如何將 NX1872 安裝版轉為可攜啟動的設定過程. 從安裝版啟動後的 Menu - Help - Log File 可以取得系統系統過程的所有細節, 其中包括各對應 .bat 執行過程所設定的環境變數, 以及所啟動的 .dll 檔案. \n 上列 .7z 檔案即包括從此 Log File 中的環境變數註記, 經過 Python 程式轉為 .bat 設定外, 還利用 %cd% 取代原先安裝版本的 C:\\NX1872, 並且以 %USERNAME% 取代安裝時的使用者 pj2022, 之後只要再納入 NX1872 的認證伺服器與所購買的 bundles, 就可以將安裝版 NX1872 轉為可存入 USB 隨身碟的可攜版本. \n NX1872 NXOpen Python 動態連結程式庫採用 Python \xa03.7.1 版本編譯 . \n 下載  NX1872_CAD_portable.7z \xa0(1151 MB, 解開壓縮後約 5.2 GB) \n To edit the settings of the active sketch, use Settings in the Edit menu: 例如要關閉 Continuous Auto Dimensioning 則需在 Sketch 編輯中的 Settings 中進行設定. \n', 'tags': '', 'url': 'NX1872.html'}, {'title': 'NX1980', 'text': 'NX1980 NXOpen Python 動態連結程式庫採用 Python\xa03.8.8 版本編譯. \n 下載 可攜 NX1980 CAD 壓縮檔案 (解開壓縮後約 6457 MB) \n', 'tags': '', 'url': 'NX1980.html'}, {'title': 'NX2008', 'text': 'NX2008 NXOpen Python 動態連結程式庫採用 Python\xa03.8.12 版本編譯. \n 下載 可攜 NX2008 CAD 壓縮檔案 (1410 MB, 解開壓縮後約 6457 MB) \n', 'tags': '', 'url': 'NX2008.html'}, {'title': 'NX2312', 'text': 'NX2312 NXOpen Python 動態連結程式庫採用 Python \xa03.10.12 版本編譯 . \n NXOpen Programmer\'s Guide \n NXOpen Python Reference Guide 2312 \n 下載 \xa0NX2312 可攜 CAD 壓縮檔案 (1.85 GB, 解開後約 9 GB) \n nx2312_Drafting.7z \n nx2312_nxplot.7z \n Download  SiemensNX-2312.4001_wntx64.zip  (14GB) \n NX2312 安裝後, 透過 Local_Machine - Software - Siemens 登錄檔案儲存下列資料, 其中包括認證主機的埠號與 IP: \n Windows Registry Editor Version 5.00\n\n[HKEY_LOCAL_MACHINE\\SOFTWARE\\Siemens]\n\n[HKEY_LOCAL_MACHINE\\SOFTWARE\\Siemens\\Installed Products]\n"NX 2312"="[{\\"ProductCode\\":\\"{BC25F476-AA6E-41ED-BBA3-F7CA7DE8EB92}\\",\\"ChannelType\\":\\"Main\\"}]"\n\n[HKEY_LOCAL_MACHINE\\SOFTWARE\\Siemens\\NX 2312]\n@="D:\\\\NX2312\\\\"\n"NXOPEN_EXTENSIONS"=""\n"NXOPEN_INSTALL"="YES"\n"INSTALLDIR"="D:\\\\NX2312\\\\"\n"LANGUAGE"="english"\n"LICENSESERVER"="29000@your_license_server"\n"UGII_BASE_DIR"="D:\\\\NX2312" \n \n 透過  get_dir_size.py  可以取得 Siemens NX 各子目錄與總容量. \n 各目錄的功能: \n AUTOMATION_DESIGNER: 自動化設計工具, 用於創建和管理自動化系統。\nCAPITALINTEGRATION: 與 Siemens Capital 軟件集成,用於電氣系統設計。\nCATIAV5: CATIA V5 文件的轉換器和介面。\nCMM_INSPECTION: 座標測量機(CMM)檢測功能。\nDESIGN_TOOLS: 各種輔助設計工具和功能。\nDIAGRAMCORE: 圖表和示意圖的核心功能。\nDIAGRAMMING: 用於創建各種工程和系統圖表。\nDRAFTING: 2D製圖和文檔創建工具。\nIGES: 初始圖形交換規範(IGES)文件的導入/導出。\nINSTALL: 安裝相關文件和腳本。\nLOCALIZATION: 多語言支持和本地化文件。\nMACH: 工具機加工和 CNC 編程功能。\nMANUFACTURING_PLANNING: 製造規劃和工藝設計工具。\nMECH: 機械設計和工程功能。\nMECHATRONICS: 機電整合設計工具。\nMOLDWIZARD: 模具設計和分析工具。\nMPA: 運動模擬和分析功能。\nNXASSEMBLY: 零件裝配和管理工具。\nNXBIN: NX 的核心檔案和執行檔。\nNXCAE_EXTRAS: 額外的電腦輔助工程(CAE)工具和功能。\nNXHUMAN: 人體工程學和人因工程設計工具。\nNXJOIN: 零件連接和焊接功能。\nNXNASTRAN: 有限元素分析(FEA)求解器。\nNXPARTS: 零件設計和模擬工具。\nNXPLOT: 繪圖和可視化工具。\nNXPROE: Pro/ENGINEER 文件的轉換器和介面。\nNXREPORTS: 報告生成和管理工具。\nNXSHIP: 船舶設計專用工具。\nPOSTBUILD: 後處理和結果分析工具。\nPSTUDIO: 產品工作室, 用於產品設計和管理。\nPVTRANS: 產品視覺化轉換工具。\nREL_INFO: 發布資訊和檔案。\nSIMULATION: 各種模擬和分析工具。\nSTAMPING_TOOLS: 沖壓工具設計功能。\nSTEP203UG 和 STEP214UG: STEP 文件格式的導入/導出。\nTDP: Technical Data Package 創建和管理工具。\nTemp 和 temp_module: 臨時文件存儲目錄。\nTOOLING_BASE: 工具設計的基礎功能。\nTRANSLATORS: 各種文件格式轉換器。\nUGALLIANCE: 與其他 CAD 系統的集成工具。\nUGAUTOMOTIVE: 汽車行業專用設計工具。\nUGCATIA: CATIA文件的轉換器和介面。\nUGFLEXLM: FlexLM許可證管理系統。\nUGFPCD: 印刷電路板(PCB)設計工具。\nUGII: NX 用戶界面和基礎功能。\nUGIMW: 整合材料管理工作台。\nUGMANAGER: 文件和專案管理工具。\nUGOPEN: 開發模組和API。\nUGOPENPP: C++ 開發模組。\nUGPCBXCHANGE: PCB數據交換工具。\nUGPHOTO: 高級著色和視覺工具。\nUGSTRUCTURES: 結構分析和設計工具。\nUGSTUDIO: 產品設計工作室。\nUGTIPS: 用戶提示和幫助文件。\nUGTO2D: 3D到2D轉換工具。\nUGWEB: Web 整合和協同工具。\nUGWELD: 焊接設計和分析工具。\nUNFOLD: 鈑金展開工具。 \n NX2312 完整版各目錄容量: \n ACOUSTICS : 1.28 GB\nAM_SIMULATION : 67.7 MB\nAUTOMATED_TESTING : 3.19 MB\nAUTOMATIC_UPDATE : 541.0 B\nAUTOMATION_DESIGNER : 336.83 MB\nCAPITALINTEGRATION : 2.04 MB\nCATIAV5 : 901.76 KB\nCLOUDDM : 13.18 KB\nCMM_INSPECTION : 319.18 MB\nCOMPOSITES : 54.18 KB\nDESIGNSPACEEXPLORER : 8.04 KB\nDESIGN_TOOLS : 135.75 MB\nDIAGRAMCORE : 5.81 MB\nDIAGRAMMING : 118.67 MB\nDOCUMENT : 666.71 KB\nDRAFTING : 115.44 MB\nDXFDWG : 197.04 MB\nFABRICMODELER : 5.03 KB\nGCTOOLKIT : 230.19 MB\nIGES : 5.47 MB\nIMMERSIVEEXPERIENCE : 1016.81 MB\nINSTALL : 55.39 KB\nLOCALIZATION : 94.3 KB\nMACH : 2.41 GB\nMANUFACTURING_PLANNING : 160.74 MB\nMBD : 67.83 MB\nMECH : 871.99 MB\nMECHATRONICS : 278.23 MB\nMENDIXREPORTING : 1.05 MB\nMOLDCOOLING : 12.37 KB\nMOLDWIZARD : 236.79 MB\nMPA : 1.48 MB\nNX2DEDIT : 1.25 MB\nNXAECDESIGN : 70.86 MB\nNXASSEMBLY : 91.5 MB\nNXBIN : 6.47 GB\nNXCABLEROUTER : 29.51 KB\nNXCAE_EXTRAS : 4.55 GB\nNXCOATINGS : 632.24 KB\nNXCREO : 5.71 MB\nNXHUMAN : 247.74 MB\nNXJOIN : 24.34 MB\nNXNASTRAN : 3.23 GB\nNXPARTS : 64.96 MB\nNXPLOT : 246.92 MB\nNXREPORTS : 3.66 MB\nNXSHIP : 339.88 MB\nNXSTRUCTUREDESIGN : 119.29 MB\nNXVR : 534.04 MB\nNX_VSA : 12.73 MB\nPARTMFG : 32.08 MB\nPLASTIC_DESIGNER : 6.49 MB\nPOSTBUILD : 35.08 MB\nPSTUDIO : 35.5 MB\nPVTRANS : 106.92 KB\nREL_INFO : 36.92 KB\nROUTING : 433.54 MB\nRULE : 306.25 KB\nSAFETY : 24.39 KB\nSIMULATION : 2.68 GB\nSTAGE_MODEL : 4.06 MB\nSTAMPING_TOOLS : 163.08 MB\nSTEP203UG : 1.44 MB\nSTEP214UG : 1.44 MB\nTDP : 219.56 MB\nTOOLING_BASE : 254.04 KB\nTRANSLATORS : 150.1 MB\nUGALLIANCE : 89.19 KB\nUGAUTOMOTIVE : 147.22 MB\nUGCATIA : 6.04 MB\nUGFLEXLM : 30.28 MB\nUGFPCD : 31.89 KB\nUGII : 550.7 MB\nUGIMW : 8.45 MB\nUGMANAGER : 127.12 MB\nUGOPEN : 530.1 MB\nUGOPENPP : 692.91 KB\nUGPCBX : 342.48 KB\nUGPCBXCHANGE : 102.96 MB\nUGPHOTO : 3.94 GB\nUGSTRUCTURES : 346.62 MB\nUGSTUDIO : 14.03 MB\nUGTIPS : 56.22 MB\nUGTO2D : 886.88 KB\nUGWEB : 9.08 MB\nUGWELD : 2.07 MB\nUNFOLD : 71.92 KB\nVDA : 26.31 KB\nVDV : 5.34 MB\ntotal: 33.32 GB \n NX2312 各功能對應目錄: \n Simcenter Nastran - NXNASTRAN\nSimcenter 3D Acoustics - ACOUSTICS\nProgramming Tools - UGALIANCE UGOPEN UGOPENPP\nModel Based Part Manufacturing - PARTMFG DOCUMENT DIAGRAMMING\nShip Building - NXSHIP NXCABLEROUTER\nGreater China Tools - GCTOOLKIT\nAutomated Testing Studio - AUTOMATED_TESTING\nAutomotive - UGAUTOMOTIVE DESIGN_TOOLS STAMPING_TOOLS TOOLING_BASE UGWELD VDV VDA\nComposites - COMPOSITES\nDiagramming - DIAGRAMMING\nDrafting - DRAFTING NX2DEDIT\nFabric Modeler - FABRICMODELER\nImmersive - IMMERSIVEEXPERIENCE\nInductrial Electrical Design - AUTOMATION_DESIGNER\nManufacturing - MACH CMM_INSPECTION MBD NX_VSA POSTBUILD PSTUDIO STAGE_MODEL UNFOLD\nManufacturing Planning - MANUFACTURING_PLANNING\nMechatronics Concept Designer - MECHATRONICS\nNX Reporting - MENDIXREPORTING\nOptimization Tools - DESIGNSPACEEXPLORER\nMolded Part Design - PLASTIC_DESIGNER\nRouting - ROUTING CAPITALINTEGRATION\nSimcenter 3D - COMPOSITES MECH MOLDCOOLING NXCAE_EXTRAS SAFETY SIMULATION UGSTRUCTURE UGPCBEXCHANGE UGPCBX UGFPCD\nStudio Render - UGSTUDIO UGPHOTO\nTooling Design & NX Joint - DESIGN_TOOLS MOLDWIZARD NXAECDESIGN NXCOATINGS NXJOIN NXREPORTS NXSTRUCTUREDESIGN STAMPING_TOOLS TOOLING_BASE UGAUTOMOTIVE UGWELD\nTranslators - CATIAV5 DXFDWG IGES NXCREO STEP203UG STEP214UG UGCATIA UGMW UGTO2D TRANSLATORS\nValidation - DESIGN_TOOLS NXREPORTS MPA\nNX VR - NXVR \n \n', 'tags': '', 'url': 'NX2312.html'}, {'title': 'NX2406', 'text': 'NX2406 NXOpen Python 動態連結程式庫採用 Python \xa03.10.12 版本編譯 . \n 下載  NX2406 可攜 CAD 壓縮檔案 (1.76 GB, 解開後約 9 GB) \n 有關 NX on 2024.June: \n NX2406 在 Windows 安裝需要 MS Windows Desktop Runtime 6.0.16 以上版本. \n NX2406 安裝目錄與容量: \n \n NX Platform: 必要檔案容量 6953 MB, 若加上 Simcenter NASTRAN (4265 MB), Programming Tools (562 MB), Drafting (119MB), Optimization Tools (11 MB) and Translators (140 MB), Ugstructures (353 MB),\xa0 Ncae_extras (4120 MB), Simulation (2690 MB) 將是具備可攜基本 CAD/CAE 與延伸程式開發功能的 NX 套件, 容量約 20 GB. \n Localizations: 若選擇 Traditional Chinese 介面, 目錄名稱 Localizations, 增加 107 MB, 但一般建議直接使用英文介面即可. \n Simcenter Nastran: FE solver for simulation products, Mach stress and vibration wizards. 目錄名稱為 NASTRAN, 增加 4265 MB. \n Simcenter 3D Acoustics: Acoustics BEM 與 Ray solvers, 目錄名稱 ACOUSTICS, 增加 1418 MB. \n Programming Tools: Programming Interfaces, 目錄名稱 UGALLIANCE, UGOPEN, UGOPENPP, 增加 562 MB. \n Model Based Part Manufacturing: 目錄名稱 PARTMFG, DOCUMENT, DIAGRAMMING, 增加 176 MB. \n Additive Manufacturing Simulation: 目錄名稱 AM_SIMULATION, COMPOSITE, MACH, NXCAE_EXTRAS, SIMULATION, UGSSTRUCTURES, 增加 10 GB. \n Ship Building: 目錄名稱 NXSHIP, NXCABLEROUTER, 增加 353 MB. \n Greater China Tools: 目錄名稱 GCTOOLKIT, 增加 233 MB. \n Automated Testing Studio: 目錄名稱 AUTOMATED_TESTING, 增加 4848 KB. \n Automotive: 目錄名稱 UGAUTOMOTIVE, DESIGN_TOOLS, MOLDWIZARD, NXREPORTS, STAMPING_TOOLS, TOOLING_BASE, UGWELD, VDV, VDA, 增加 842 MB. \n Composites: 目錄名稱 COMPOSITES, 增加 208 MB. \n Digramming: 目錄名稱 DIAGRAMMING, 增加 135 MB. \n Drafting: Extends 2D and 3D drawing tools, 目錄名稱 DRAFTING, NX2EDIT, 增加 119 MB. \n Fabric Modeler: 目錄名稱 FABRICMODELER, 增加 2744 KB. \n Immersive: 目錄名稱 IMMERSIVEEXPERIENCE, 增加 1056 MB. \n Industrial Electrical Design: 目錄名稱 AUTOMATION_DESIGNER,\xa0 增加 404 MB. \n Manufacturing: 目錄名稱 MACH, CMM_INSPECTION, MBD, NX_VSA, POSTBUILD, PSTUDIO, STAGE_MODEL, UNFOLD, 增加 3565 MB. \n Manufacturing Planning: 目錄名稱 MANUFACTURING_PLANNING, 增加 449 MB. \n Mechatronics Concept Designer: 目錄名稱 MECHATRONICS, 增加 332 MB. \n NX Reporting: 目錄名稱 MENDIXREPORTING, 增加 1312 KB. \n Optimization Tools: 目錄名稱 DESIGNSPACEEXPLORER, 增加 11 MB. \n Molded Part Design: 目錄名稱 PLASTIC_DESIGNER, 增加 13 MB. \n Routing: 目錄名稱 ROUTING, CAPITALINTEGRATION, 增加 467 MB. \n Simcenter 3D: 目錄名稱 COMPOSITES, MECH, MOLDCOOLING, NXCAE_EXTRAS, SAFETY, SIMULATION, UGSTRUCTURES, UGPCBXCHANGE, UGPCBX, UGFPCB, 增加 9007 MB. \n Studio Render: 目錄名稱 UGSTUDIO, UGPHOTO, 增加 4085 MB. \n Tooling Desing and NX Join: 目錄名稱 DESIGN_TOOLS, MOLDWIZARD, NXAECDESIGN, NXCAATINGS, NXJOIN, NXREPORT, NXSTRUCTUREDESIGN, STAMPING_TOOLS, TOOLING_BASE, UGAUTOMOTIVE, UGWELD, 增加 1079 MB. \n Translators: 目錄名稱\xa0CATIAV5, DXFDWG, IGES, NXCREO, STEP203UG\xa0STEP214UG, UGCATIA, UGIMW, UGTO2D, TRANSLATORS, 增加 815 MB. \n Validation: 目錄名稱 DESIGN_TOOLS, TOOLS_NXREPORTS, MPA, 增加 182 MB. \n \n \n https://plm.sw.siemens.com/en-US/nx/best-cad-cam-software-industry-awards/ \xa0 \n NX X: \n 2024\xa0 Siemens 推出 NX X . \n https://resources.sw.siemens.com/en-US/video-introducing-nx-x-nx-as-a-saas-solution \xa0 \n https://plm.sw.siemens.com/en-US/nx/products/compare-nx-x-cad-bundles/ \xa0 \n https://blogs.sw.siemens.com/nx-manufacturing/whats-new-in-nx-for-manufacturing-june-2024/ \n \n NX2406  新增功能 \n NX2406  文件瀏覽 \n NX2406  草圖文件 \n NX2406  建模文件 \n NX2406  組立文件 \n', 'tags': '', 'url': 'NX2406.html'}, {'title': 'NXOpen', 'text': "cad2024 最新整理的  gear_c_NX2312.txt \n 1_block_only_short_py.txt \n \n https://github.com/mdecycu/nxopen \n Browse Programming Tools Help \n Overview of Programmer's Guide \n Open C Programmer's Guide \n Open C Reference Guide \n msys64_20240507.7z  (183MB) \n NXOpen Python Reference Guide \n 若使用 NX2312, 其中需要設計並繪製減速機中的正齒輪組 (Spur Gear Train), 若採 UGOPEN C 編寫延伸程式, 可以利用 MSYS2 中的 gcc 進行編譯與連結: \n mkdir build\n \nmkdir dist\n \nREM compile gear.c\ngcc.exe -c -g -IC:\\nx2312_portable\\data\\nx2312\\UGOPEN -MMD -MP -MF build/gear.o.d -o build/gear.o gear.c\n \nREM link with libufun.lib and libugopenint.lib\ngcc.exe -shared -o dist/gear.dll build/gear.o C:\\nx2312_portable\\data\\nx2312\\UGOPEN\\libufun.lib C:\\nx2312_portable\\data\\nx2312\\UGOPEN\\libugopenint.lib \n 取得 gear.dll 後, 可開啟 new Model file 後, 以 File -> Execute -> NX Open 執行 gear.dll. \n UGOpen C 程式架構請參考  UG_Open-API_Programming.pdf \n UGOpen 技術文件請參考: \n Open C Programmer's Guide  (for internal IPv6 users only) \n Open C Reference Manual  (for internal IPv6 users only) \n \n  接下來將 mp4 檔案從 downloads 目錄取出  \n \n \n gear_model2.c.txt \n uarm_gear_design_for_NX.zip \n using MSYS2 compile gear.c:  spur_gear_NXOpen_C_NX2312.7z \n NXOpen_ref.7z \n", 'tags': '', 'url': 'NXOpen.html'}, {'title': 'NXOpen_Python', 'text': 'generate_cylinder_nx2312_py.txt \n NXOpen Programmer\'s Guide \n NXOpen Python Reference Guide 2312 \n NX2312 與 NX2406 必須配合 Python 3.10 使用 (以 Python 3.10.12 編譯 .pyd), 這裡利用 gen_python_for_nx2312.py 如下, 建立 Python310 備用 (由於 Python 3.10.12 可攜目錄無法使用下列程式建立, 因此退至 Python 3.10.11): \n import urllib.request\nimport os\n    \ndir_path = os.path.dirname(os.path.realpath(__file__))\n# basic files for Python installation\n# before 3.12.0\npy_list = ["core", "dev", "exe", "lib", "tcltk", "tools"]\n# 3.12.1 no tools.msi\n#py_list = ["core", "dev", "exe", "lib", "tcltk"]\n# Python version 3.10.11 for NX2312\nversion = "3.10.11"\n# Python msi download URL\nftp = "https://www.python.org/ftp/python/" + version + "/amd64/"\n# location for Portable Python\npath = "y:\\\\tmp\\\\Python310"\n# create directory\ntry:\n    os.mkdir(path)\nexcept:\n    # path exists\n    pass\n# get Python installation msi files and extract into target dir\nfor i in py_list:\n    filename = i + ".msi"\n    url = ftp + filename\n    # download basic python msi file\n    urllib.request.urlretrieve(url, filename)\n    os.system("msiexec.exe /a " + i + ".msi targetdir=" + path)\n    # delete msi file\n    os.remove(dir_path + "\\\\" + i + ".msi")\n    os.remove(path + "\\\\" + i + ".msi") \n 其中可攜程式系統啟動批次檔, 必須將 NX\\NXbin\\python 納入 PYTHONPATH 設定, 因為 NXOptn 相關的動態連結程式庫 *.pyd 都放在這個目錄. \n set PYTHONPATH=%Disk%:\\Python310\\DLLs;%Disk%:\\Python310\\Lib;%Disk%:\\Python310\\Lib\\site-packages;%Disk%:\\NX\\NXBIN\\python; \n 在可攜啟動批次檔案中的 path 指令搜尋路徑之後, 讓 NX2312 取得使用授權後啟動: \n REM for NX2312, must after path setup \nset SPLM_LICENSE_SERVER=29000@192.168.56.3\nset UGII_LANG=english\nset UGS_LICENSE_BUNDLE=ACD11,ACD10\nset UGII_BASE_DIR=%Disk%:\\NX\\\nset UGII_TMP_DIR=%Disk%:\\NX\\temp\nset UGII_LIB_PATH=%Disk%:\\NX\\NXBIN\\python\nset ugii=%Disk%:\\NX\\ugii;%Disk%:\\NX\\nxbin;\npath = %ugii%;%path%\nXcopy %Disk%:\\home_ipv6\\AppData\\Local\\Siemens\\NX2312 C:\\users\\%USERNAME%\\AppData\\Local\\Siemens\\NX2312 /E /H /C /I /Y \n AppData\\Local\\Siemens\\NX2312\\NX_user.dpv 內容設定: \n <?xml version="1.0" encoding="UTF-8"?>\n\n<?xml-stylesheet type="text/xsl" href="NX_user.xsl"?>\n<PrefValues defaultLockStatus="unlocked">\n<Pref Application="Gateway" Category="General" Tab="Data Privacy" displayValue="No" modified="2024-08-09T08:48:09" name="NX_ProductExcellenceProgram" title="Product Excellence Program - Participate" value="false"/>\n<Pref Application="Gateway" Category="General" Tab="Miscellaneous" displayValue="No" modified="2024-08-09T08:25:55" name="NX_ProductExcellenceProgramMessage" title="Product Excellence Program - Display Initial Startup Message" value="false"/>\n<Pref Application="Gateway" Category="User Interface" Tab="Journal" displayValue="Python" modified="2024-08-09T08:26:17" name="UG_journalLanguage" title="Journal Language" value="4"/>\n</PrefValues> \n nxopen_ex.7z \n 可攜啟動之後, 若從命令列中啟動 NX, 則系統內定設定將讀取 home_ipv6\\AppData\\Local\\Siemens\\NX2312 目錄中的相關設定, 其中與 Menu 下拉式功能表有關的設定位於 user.mtx, 決定顯示 Menu 的設定內容為: \n <ActionList name="QuickAccessBar" type="popupbar">\n    <ActionItems>\n        <ActionItem name="MenuBar" type="cascade" visibility="1"/>\n    </ActionItems>\n</ActionList> \n NX2312_user_mtx_and_NX_user_dpv.7z \n', 'tags': '', 'url': 'NXOpen_Python.html'}, {'title': 'Open C', 'text': "NXOpen Programmer's Guide \n NXOpen Python Reference Guide 2312 \n The following table lists the Open C functions that have been wrapped for use in NXOpen.NET. The list provides the Open C function name and the corresponding C# method. \n \n \n \n \n Open C Function \n \n \n C# Wrapper Method \n \n \n \n \n \n \n uc4577 \n \n \n UFCFI::GetUniqueFilename \n \n \n \n \n uc5822 \n \n \n UFPATT::AskData \n \n \n \n \n uc5823 \n \n \n UFPATT::Import \n \n \n \n \n uc5824 \n \n \n UFPATT::CycleErrors \n \n \n \n \n uf5940 \n \n \n UFTrns::CreateCsysMappingMatrix \n \n \n \n \n uf5941 \n \n \n UFTrns::MapPosition \n \n \n \n \n uf5942 \n \n \n UFTrns::MultiplyMatrices \n \n \n \n \n uf5943 \n \n \n UFTrns::CreateTranslationMatrix \n \n \n \n \n uf5944 \n \n \n UFTrns::CreateScalingMatrix \n \n \n \n \n uf5945 \n \n \n UFTrns::CreateRotationMatrix \n \n \n \n \n uf5946 \n \n \n UFTrns::CreateReflectionMatrix \n \n \n \n \n uf5947 \n \n \n UFTrns::TransformObjects \n \n \n \n \n uc6409 \n \n \n UFView::AskViewDependentStatus \n \n \n \n \n uc6434 \n \n \n UFView::SetViewMatrix \n \n \n \n \n uc1615 \n \n \n UFUi::PickPoint \n \n \n \n \n uc1616 \n \n \n UFUi::PointSubfunction \n \n \n \n \n uc1630 \n \n \n UFUi::PickCsys \n \n \n \n \n uc1652 \n \n \n UFUi::PickView \n \n \n \n \n uc1653 \n \n \n UFUi::AskLastPickedView \n \n \n \n \n uc1600 \n \n \n UFUi::AskStringInput \n \n \n \n \n uc1601 \n \n \n UFUi::DisplayMessage \n \n \n \n \n uc1603 \n \n \n UFUi::DisplayMenu \n \n \n \n \n uc1605 \n \n \n UFUi::DisplayMultiSelectMenu \n \n \n \n \n \n \n \n Non-wrapped NX Open C functions \n \n \n The Non-wrapped NX Open C functions are Open C functions that do not have .NET, Java, or Python bindings provided. This is mainly due to the following reasons: \n \n \n Corresponding functions have no use in .NET, Java, or Python \n \n \n Functions in C are so complex that we cannot map them to .NET, Java, or Python \n \n \n The following are the non-wrapped NX Open C functions: \n UF_ASSEM_free_deform_warnings_data UF_ASSEM_free_prev16_aligns UF_CLONE_free_validation_options UF_CUT_LEVELS_free UF_DRF_free_comp_data UF_FAM_free_class_data UF_FBM_GEOM_free_classified_set_list UF_GDT_free UF_KF_free_list_object_contents UF_KF_free_rule_value UF_LIB_free_rset_map UF_MODL_free_bsurf_data UF_MODL_free_compare_data UF_MODL_free_compare_data_3 UF_MODL_free_law UF_MODL_free_law_extension UF_MODL_free_refit_face_feature_data UF_MODL_free_rough_offset_data UF_MODL_free_silhouette_flange UF_MODL_free_snip_surface_feature_data UF_MODL_free_string_list UF_MODL_shape_pattern_free_client_data UF_MODL_SWEEP_free_trim_data UF_MODL_udf_free_exp_data UF_NXSM_free_closed_corner_data UF_NXSM_free_flange_data UF_NXSM_free_flange_sketch_data UF_NXSM_free_rebend_data UF_NXSM_free_unbend_data UF_PART_free_load_status UF_PD_free_business_modifier_data UF_PD_free_product_attribute_data UF_PD_free_product_attribute_data_2 UF_PD_free_product_attribute_value_data UF_ROUTE_free_places UF_SF_free_defeature_parms UF_SF_free_idealize_parms UF_SF_free_idealize_region UF_SF_free_midsrf_user_parms UF_SF_LEGEND_free_attr UF_SUBDIV_free UF_WAVE_free_linked_feature_info UF_WEIGHT_free_exceptions \n \n \n \n \n \n", 'tags': '', 'url': 'Open C.html'}, {'title': 'MSYS2', 'text': 'msys64_20240507.7z  (183MB) \n', 'tags': '', 'url': 'MSYS2.html'}, {'title': 'Solvespace', 'text': 'Web-based Solvespace:  https://cad.apps.dgramop.xyz/  ( source  and  PR ) \n Python related PR \n 在\xa0 python_2025_lite.7z \xa0加入以下說明的 msys2 與 cmake 後, 可用來編譯 Solvespace v3.1 版原始碼的可攜套件  python_2025_lite_w_msys_cmake_solvespace.7z \xa0(Download 1.96GB, After extracted 3.7GB) \n \n Solvespace 採 C++ 編寫, 原始碼位於\xa0 https://github.com/solvespace/solvespace , 以下將採用可攜程式系統 python_2025 中的 msys2 ( msys64_20240507.7z ) 以及 cmake 3.20.1 進行編譯 (若採用目前最新版的 cmake 3.30.2, 必須對 Solvespace v3.1 中的 CMakeLists.txt 進行修改). \n 舊版的 cmake 3.21.0 可以利用下列連結取得: \n https://github.com/Kitware/CMake/releases/download/v3.21.0/cmake-3.21.0-windows-x86_64.zip \xa0 \n msys64_20240507.7z  (下載到 data 目錄下後, 目錄名稱必須改為 msys64) 則必須安裝 mingw32-make: \n (安裝以下 make 套件前, 必須先執行 msys64 中的 mingw64.exe) \n pacman -S mingw-w64-ucrt-x86_64-make \n 最新版的 python_2025 可攜程式環境架構位於:  https://github.com/mdecycu/pyhton_2025 , 各目錄套件可自行根據  https://mde.tw/cad2024/content/Python.html  中的說明下載, 或者自行配置. \n 機械設計工程師採用可攜程式套件的原因, 是希望能彈性配置 Python 版本, 因為大多數主流 CAD/E/M 套件都非開源軟體, 各版本的 API 相關的動態連結程式庫, 都採用特定的 Python 版本程式碼編譯而成. 例如: Siemens NX12 採用 Python 3.6.5, NX1872 採用 Python 3.7.1, NX1980 採用 Python 3.8.8, NX2312 使用 Python 3.10.12. 假如採用可攜程式套件, 除了可以如虛擬 Python 環境一樣, 將能配合 NXOpen 程式開發, 將所需的 Python 版本與相關模組放在同一目錄, 且能夠在不同的 64 位元 Windows 操作系統中執行. \n 接著取得 Solvespace v3.1 的原始碼, 可以直接從\xa0 https://github.com/solvespace/solvespace/releases \xa0取得, 或以\xa0以 git clone --recurse-submodules  https://github.com/solvespace/solvespace.git \xa0之後, \n cd solvespace \n git checkout v3.1 \n 接下來則必須修改\xa0solvespace\\extlib\\angle\\src\\libANGLE\\HandleAllocator.cpp 加入標頭檔案: \n #include <limits> \n 接著就可以進行程式碼的編譯與連結: \n mkdir build \n cd build \n cmake .. -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=Release \n mingw32-make \n 完成編譯後, solvespace.exe 即位於 build\\bin 目錄中, 執行時則需要\xa0libwinpthread-1.dll 動態連結程式庫. \n 進行上述流程編譯的原始碼\xa0 solvespace_v3.1_src.7z , 以及編譯完成的  solvespace_v3.1_msys2.7z .', 'tags': '', 'url': 'Solvespace.html'}, {'title': 'Slv_export', 'text': 'Solvespace 內建 Export 轉檔的比例 (Scale), 設為 1:1, 也就是無論繪圖時採用哪一種尺寸單位進行繪圖, 轉出來的模型尺寸單位都會自動轉為 mm. 換言之, 即便使用者採 m 為作圖尺寸單位, 轉出 STL 時, 根據 Export Scale Factor 內建值為 1:1 mm, Solvespace 會將 m 自動轉為 mm 之後, 再使用該尺寸的對應數字轉出 (因為 STL 並不標示零件所使用的尺寸單位, 而只有尺寸數字). \n 因此若在不修改 Solvespace - Configuration - Export Scale Factor (內建 1:1 mm) 時轉出的零組件 STL 檔案, 轉入以 m 為內定尺寸單位的 CoppeliaSim, 必須縮小 1000 倍, 也就是將 Import Mesh 時的 Scaling 設為 0.001 \n 另外一種設定法, 也可將 Solvespace 中的 Export Scale Factor 改為 1:1000 m, 此時轉出的零組件 STL 檔案, 就會取繪圖尺寸為公尺對應的數字轉出, 之後轉入 CoppeliaSim 時, 就可以使用 Scaling 為 1 的方式轉入. \n NX2312 Export 零組件時, 則會根據零組件所使用的尺寸對應數字輸出, 換言之, 若使用者採 inch 作為繪圖尺寸單位, 則零件轉出 STL 時, 只會使用該零件的尺寸數字進行輸出, 不會像 Solvespace 將繪圖尺寸在內建 Export Scale Factor 為 1:1 mm 時, 自動將繪圖尺寸的單位轉換為 mm 之後再輸出. \n', 'tags': '', 'url': 'Slv_export.html'}, {'title': 'CoppeliaSim', 'text': '下載相容於 IPv6 的 CoppeliaSim 4.7.0 rev4:  CoppeliaSim_Edu_4.7.0_rev4_for_2024Fall.7z \n cd2023_pj3ag4_zmq_football_4.7.7z \n ZMQ Remote API Python Examples:  https://github.com/benzr/cdfrob2024-coppeliasim-zeromq-remote-api  (修改為 4.7.0 相容範例:  cdfrob2024-coppeliasim-zeromq-remote-api.7z ) \n 官方 4.7.0 Visualization Stream 瀏覽器前端允許使用者變動場景中的物件位置與方位, 若要移除此一功能, 必須修改 threejsFrontend.html 與 threejsFrontend.js. (下載已經修改後的 超文件與 js 檔案 ) \n 模擬場景範例:  tricycle_ttt.7z ,  GPSsensor_ttt.7z \n CoppeliaSim Tutorial Videos \n Get started with CoppeliaSim \n https://hades.mech.northwestern.edu/index.php/CoppeliaSim_Introduction \n \n CoppeliaSim 在 2024.06.14 推出  4.7.0 版 , 其中沿用至 4.6.0 版的 zmqRemoteApi 模組已經改名為 coppeliasim_zmqremoteapi_client, 部分模組的內容也進行些微更動, 導致先前所編寫的 ZMQ Rempte API Python 程式都必須因應修改, 否則無法執行. \n KMOLab 在 4.5.1 版為了讓 CoppeliaSim 的 ZMQ Remote API Python 遠端控制程式能夠在 IPv6 網路協定中執行, 修改了 Server 與 Client 模組中的 ZMQ 程式設定, 若要讓 4.7.0 版也能相容於 IPv6, 則必須修改下列程式碼: \n lua\\pythonWrapperV2.lua \n function initPython(prog)\n    local pyth = sim.getStringParam(sim.stringparam_defaultpython)\n    local pyth2 = sim.getNamedStringParam("python")\n    if pyth2 then pyth = pyth2 end\n    if pyth == nil or #pyth == 0 then\n        local p = sim.getInt32Param(sim.intparam_platform)\n        if p == 0 then\n            pyth = \'py\'\n        else\n            pyth = \'python3\'\n        end\n    end\n    local errMsg\n    if pythonExecutable then\n        pyth = pythonExecutable\n    end\n    if pyth and #pyth > 0 then\n        subprocess, controlPort = startPythonClientSubprocess(pyth)\n        if controlPort then\n            pyContext = simZMQ.ctx_new()\n            pySocket = simZMQ.socket(pyContext, simZMQ.REQ)\n            -- enable IPv6 for ZMQ, default is false to IPv6 from KMOLab\n            simZMQ.setsockopt(pySocket,simZMQ.IPV6,sim.packUInt32Table{1})\n            simZMQ.setsockopt(pySocket,simZMQ.IPV4ONLY,sim.packUInt32Table{0})\n            -- end for enabling IPv6 for ZMQ\n            simZMQ.setsockopt(pySocket, simZMQ.LINGER, sim.packUInt32Table {0})\n            simZMQ.connect(pySocket, controlPort)\n            virtualPythonFilename = sim.getStringParam(sim.stringparam_scene_path_and_name) \n 另外必須注意的是 4.7.0 在 Windows 中使用虛擬硬碟代號 z:, 若控制程式的開發是在可攜程式系統中進行, 必須避開使用 z:. \n 另外在 lua\\motion.lua 中將封包傳送綁定在 localhost, 嘗試修改如下: \n function sim.generateTimeOptimalTrajectory(...)\n    simZMQ = require \'simZMQ\'\n    local path, pathLengths, minMaxVel, minMaxAccel, trajPtSamples, boundaryCondition, timeout =\n        checkargs({\n            {type = \'table\', item_type = \'float\', size = \'2..*\'},\n            {type = \'table\', item_type = \'float\', size = \'2..*\'},\n            {type = \'table\', item_type = \'float\', size = \'2..*\'},\n            {type = \'table\', item_type = \'float\', size = \'2..*\'},\n            {type = \'int\', default = 1000},\n            {type = \'string\', default = \'not-a-knot\'},\n            {type = \'float\', default = 5},\n    }, ...)\n\n    local confCnt = #pathLengths\n    local dof = math.floor(#path / confCnt)\n\n    if (dof * confCnt ~= #path) or dof < 1 or confCnt < 2 or dof ~= #minMaxVel / 2 or\n        dof ~= #minMaxAccel / 2 then error("Bad table size.") end\n    local lb = sim.setStepping(true)\n\n    local pM = Matrix(confCnt, dof, path)\n    local mmvM = Matrix(2, dof, minMaxVel)\n    local mmaM = Matrix(2, dof, minMaxAccel)\n\n    sim.addLog(sim.verbosity_scriptinfos,\n        "Trying to connect via ZeroMQ to the \'toppra\' service... " ..\n        "make sure the \'docker-image-zmq-toppra\' container is running. " ..\n        "Details can be found at https://github.com/CoppeliaRobotics/docker-image-zmq-toppra"\n    )\n    local context = simZMQ.ctx_new()\n    local socket = simZMQ.socket(context, simZMQ.REQ)\n    simZMQ.setsockopt(socket, simZMQ.RCVTIMEO, sim.packInt32Table {1000 * timeout})\n    simZMQ.setsockopt(socket, simZMQ.LINGER, sim.packInt32Table {500})\n    -- local result = simZMQ.connect(socket, \'tcp://localhost:22505\')\n    -- try to make it IPv6 compatable\n    local result = simZMQ.connect(socket, \'tcp://*:22505\')\n    if result == -1 then\n        local err = simZMQ.errnum()\n        error(\'connect failed: \' .. err .. \': \' .. simZMQ.strerror(err))\n    end \n 另外, 在 coppeliasim_zmqremoteapi_client 模組,\xa0 __init__.py 中, 也必須納入 IPv6 相容設定: \n class RemoteAPIClient:\n    """Client to connect to CoppeliaSim\'s ZMQ Remote API."""\n\n    def __init__(self, host=\'localhost\', port=23000, cntport=None, *, verbose=None):\n        """Create client and connect to the ZMQ Remote API server."""\n        self.verbose = int(os.environ.get(\'VERBOSE\', \'0\')) if verbose is None else verbose\n        self.context = zmq.Context()\n        self.socket = self.context.socket(zmq.REQ)\n        # Enable IPv6 on the socket\n        self.socket.setsockopt(zmq.IPV6, 1)\n        self.socket.connect(f\'tcp://{host}:{port}\')\n        self.uuid = str(uuid.uuid4())\n        self.callbackFuncs = {}\n        self.requiredItems = {}\n        self.VERSION = 2\n        self.timeout = 10 * 60\n        self.sendCnt = 0\n        main_globals = sys.modules[\'__main__\'].__dict__\n        main_globals[\'require\'] = self.require \n 最後 addOns\\ZMQ remote API server.lua 中也必須改為 IPv6 相容: \n --    if zmqRemoteApi.verbose() > 0 then\n        sim.addLog(\n            sim.verbosity_scriptinfos,\n            string.format(\'ZeroMQ Remote API server starting (rpcPort=%d)...\', rpcPort)\n        )\n--    end\n    cbor = require \'org.conman.cbor\'\n    context = simZMQ.ctx_new()\n    rpcSocket = simZMQ.socket(context, simZMQ.REP)\n    -- enable IPv6 for ZMQ, default is false to IPv6\n    simZMQ.setsockopt(rpcSocket,simZMQ.IPV6,sim.packUInt32Table{1})\n    -- ZMQ IPv4ONLY default is true: http://api.zeromq.org/4-2:zmq-setsockopt\n    simZMQ.setsockopt(rpcSocket,simZMQ.IPV4ONLY,sim.packUInt32Table{0})\n    -- end enabling IPv6\n    simZMQ.bind(rpcSocket, string.format(\'tcp://*:%d\', rpcPort))\n    if zmqRemoteApi.verbose() > 0 then\n        sim.addLog(sim.verbosity_scriptinfos, \'ZeroMQ Remote API server started\')\n    end \n 在 4.7.0 中執行的 ZMQ Remote API Python 測試程式: \n # CoppeliaSim 4.7.0 rev4 適用\n# 與 4.5.1 只差在:\n\'\'\'\n# 利用 size 數列, 建立圓柱物件, 2 代表 cylinder\n# 8 表示 respondable, 1 為 質量\ndigit1_handle = sim.createPureShape(2, 8, size, 1, None)\n已經改為 4.7.0 的:\ndigit1_handle = sim.createPrimitiveShape(sim.primitiveshape_cylinder, size, 0)\nrespondable 屬性與質量必須另外設定\n\'\'\'\n# zmqRemoteApi_IPv6 為將 zmq 通訊協定修改為 IPv4 與 IPv6 相容\n# pip install pyzmq cbor keyboard\n# for 4.5.1\n#from zmqRemoteApi_IPv6 import RemoteAPIClient\n# for 4.7.0\nfrom coppeliasim_zmqremoteapi_client import RemoteAPIClient\nimport time\nimport math\nimport keyboard\n  \n# 利用 zmqRemoteAPI 以 23000 對場景伺服器進行連線\nclient = RemoteAPIClient(\'[::1]\', 23000)\n# 以 getObject 方法取得場景物件\nsim = client.getObject(\'sim\')\nbox = sim.getObject(\'/box\')\n  \n# 啟動模擬\nsim.startSimulation()\n# 建立尺寸數列, 分別定義 x, y, z 方向尺寸\nx = 0.2\ny = 0.2\nz = 0.1\nsize = [x, y, z]\n  \n# 利用 size 數列, 建立圓柱物件\n# https://manual.coppeliarobotics.com/en/regularApi/simCreatePrimitiveShape.htm\ndigit1_handle = sim.createPrimitiveShape(sim.primitiveshape_cylinder, size, 0)\n# 將 digit1 設為動態\n# 設置質量屬性\nsim.setObjectFloatParam(digit1_handle, sim.shapefloatparam_mass , 1.0)\n# 設置物體為動態\nsim.setObjectInt32Param(digit1_handle, sim.shapeintparam_static, 0)\nsim.resetDynamicObject(digit1_handle)\n# 設為具備碰撞檢測屬性\nsim.setObjectInt32Param(digit1_handle, sim.shapeintparam_respondable , 1)\n# 將圓柱物件命名為 digit1, 若用於機械計分可做為個位數轉盤\n# 之後可再導入帶有數字組立的外型零件\nsim.setObjectAlias(digit1_handle, \'digit1\')\n# 轉角單位為徑度\nsim.setObjectOrientation(digit1_handle, -1, [0, math.pi/2, 0])\n# 起始物件中心位於 [0, 0, 0], 為了位於地板, 往 z 提升一個半徑高度\nsim.setObjectPosition(digit1_handle, -1, [0, 0, x/2])\n  \n# 建立 revolute joint 命名為 joint, 且將 joint mode 設為 dynamic, control mode 設為 velocity\njoint1_handle = sim.createJoint(sim.joint_revolute_subtype, sim.jointmode_dynamic, 0, None)\nsim.setObjectInt32Param(joint1_handle, sim.jointintparam_dynctrlmode, sim.jointdynctrl_velocity)\nsim.setObjectAlias(joint1_handle, \'joint1\')\n  \n# 取得 cylinder 的位置座標\ndigit1_pos = sim.getObjectPosition(digit1_handle, -1)\njoint1_pos = [digit1_pos[0], digit1_pos[1], digit1_pos[2]]\n  \n# 將 joint1 至於 cylinder 中心\nsim.setObjectPosition(joint1_handle, -1, joint1_pos)\n# 取得 digit1_handle 的方位\ndigit1_ori = sim.getObjectOrientation(digit1_handle, -1)\n# 將 joint1_handle 方位與 digit1 對齊\nsim.setObjectOrientation(joint1_handle, -1, digit1_ori)\n  \n# 將 joint1 置於 box 上\nsim.setObjectParent(joint1_handle, box, True)\n# 將 cylinder 置於 joint1 上\nsim.setObjectParent(digit1_handle, joint1_handle, True)\n  \n# 鎖定 joint1\n# for 4.5.1\n#sim.setJointForce(joint1_handle, float(\'inf\'))\n# for 4.7.1\nsim.setJointTargetForce(joint1_handle, float(\'inf\'))\n  \nprint("基本場景建立完成!")\n  \n# 設定主迴圈\nwhile True:\n    # 設定 joint1 目標速度\n    sim.setJointTargetVelocity(joint1_handle, 10)\n    # 讓 coppeliasim 有時間按照設定讓 joint1 旋轉\n    time.sleep(0.01) \n  \n    if keyboard.is_pressed(\'q\'):\n        # 可以按下 q 鍵跳出重複執行迴圈\n        break\n  \n# 終止模擬\nsim.stopSimulation() \n 若加入 Model 程式庫中的加速度規於輪子上, 並將轉動感測數據列出: \n from coppeliasim_zmqremoteapi_client import RemoteAPIClient\nimport time\nimport math\nimport keyboard\n\n# 利用 zmqRemoteAPI 以 23000 對場景伺服器進行連線\nclient = RemoteAPIClient(\'[::1]\', 23000)\n# 以 getObject 方法取得場景物件\nsim = client.getObject(\'sim\')\nbox = sim.getObject(\'/box\')\n\n# 啟動模擬\nsim.startSimulation()\n\n# 建立尺寸數列, 分別定義 x, y, z 方向尺寸\nx = 0.2\ny = 0.2\nz = 0.1\nsize = [x, y, z]\n\n# 利用 size 數列, 建立圓柱物件\ndigit1_handle = sim.createPrimitiveShape(sim.primitiveshape_cylinder, size, 0)\nsim.setObjectAlias(digit1_handle, \'digit1\')\nsim.setObjectOrientation(digit1_handle, -1, [0, math.pi/2, 0])\nsim.setObjectPosition(digit1_handle, -1, [0, 0, x/2])\n\n# 將 digit1 設為動態\n# 設置質量屬性\nsim.setObjectFloatParam(digit1_handle, sim.shapefloatparam_mass , 1.0)\n# 設置物體為動態\nsim.setObjectInt32Param(digit1_handle, sim.shapeintparam_static, 0)\nsim.resetDynamicObject(digit1_handle)\n# 設為具備碰撞檢測屬性\nsim.setObjectInt32Param(digit1_handle, sim.shapeintparam_respondable , 1)\n\n# 建立 revolute joint 命名為 joint, 且將 joint mode 設為 dynamic, control mode 設為 velocity\njoint1_handle = sim.createJoint(sim.joint_revolute_subtype, sim.jointmode_dynamic, 0, None)\nsim.setObjectInt32Param(joint1_handle, sim.jointintparam_dynctrlmode, sim.jointdynctrl_velocity)\nsim.setObjectAlias(joint1_handle, \'joint1\')\n\n# 取得 cylinder 的位置座標\ndigit1_pos = sim.getObjectPosition(digit1_handle, -1)\njoint1_pos = [digit1_pos[0], digit1_pos[1], digit1_pos[2]]\n\n# 將 joint1 至於 cylinder 中心\nsim.setObjectPosition(joint1_handle, -1, joint1_pos)\n# 取得 digit1_handle 的方位\ndigit1_ori = sim.getObjectOrientation(digit1_handle, -1)\n# 將 joint1_handle 方位與 digit1 對齊\nsim.setObjectOrientation(joint1_handle, -1, digit1_ori)\n\n# 將 joint1 置於 box 上\nsim.setObjectParent(joint1_handle, box, True)\n# 將 cylinder 置於 joint1 上\nsim.setObjectParent(digit1_handle, joint1_handle, True)\n\n# 鎖定 joint1\nsim.setJointTargetForce(joint1_handle, float(\'inf\'))\n\nprint("基本場景建立完成!")\n\n# 載入加速度計模型\naccel_model_path = \'models/components/sensors/Accelerometer.ttm\'\naccel_handle = sim.loadModel(accel_model_path)\n\n# 確保加速度計在圓柱物件上\nsim.setObjectPosition(accel_handle, digit1_handle, [0, 0, x/2])\nsim.setObjectParent(accel_handle, digit1_handle, True)\n\n# 取得加速度計的句柄\n# 通常模型載入後的物件名稱是 \'Accelerometer\'\naccel_sensor_handle = sim.getObjectHandle(\'Accelerometer\')\n\n# 設定主迴圈\nwhile True:\n    # 設定 joint1 目標速度\n    sim.setJointTargetVelocity(joint1_handle, 10)\n\n    # 嘗試讀取加速度計的數據\n    # 使用 getObjectPosition 和 getObjectOrientation 來讀取加速度計數據\n    # 這僅僅是示例，你需要根據實際 API 文檔來確定如何讀取數據\n    position = sim.getObjectPosition(accel_sensor_handle, -1)\n    orientation = sim.getObjectOrientation(accel_sensor_handle, -1)\n    \n    # 根據感測器的數據進行處理，這裡僅為示例\n    print(f\'Accelerometer position: {position}\')\n    print(f\'Accelerometer orientation: {orientation}\')\n\n    # 讓 CoppeliaSim 有時間按照設定讓 joint1 旋轉\n    time.sleep(0.1)  # 增加延遲以便更穩定地讀取數據\n\n    if keyboard.is_pressed(\'q\'):\n        # 可以按下 q 鍵跳出重複執行迴圈\n        break\n\n# 終止模擬\nsim.stopSimulation()\n \n 上列 ZMQ Remote API Python 範例含 CoppeliaSim 4.7.0 rev4 程式庫:  zmq_remote_api_ex.7z \n \n cad2024_foosball_with_ball_python_script.7z \n 將上列採用 Python script 控制的手足球, 改為使用 ZMQ Remote API Python 執行控制: \n cad2024_foosball.7z \n Ball-Plate-Control:\xa0 https://github.com/mdecycu/Ball-Plate-Control \xa0 \n', 'tags': '', 'url': 'CoppeliaSim.html'}, {'title': 'Copsim_EX', 'text': 'download_and_extract_python_2025_lite.bat 使用管理者身分執行, 目的是在 C: 下載一份python_2025_lite, 可以結合隨身碟中的可攜系統檔案, 選擇使用 C:\\ 中的 NX2312 或 CoppeliaSim 執行, 可以取得比較快速的反應. \n 但是 Python 系統在輔助設計開發過程可能會需要安裝特定模組, 因此 Python 仍可選擇使用隨身碟中的解譯系統. \n CoppeliaSim 執行 ZMQ Remote API 程式控制時, 需要 Python 解譯器安裝 pyzmq, cbor, cbor2 與 keyboard 等模組, 可攜系統啟動後, 可以利用命令列指令 pip list 查驗是否已經安裝這些模組. \n 另外一個必須注意的是: CoppeliaSim 4.7.0 rev4 啟動時必須位於 CoppeliaSim 套件所在目錄, 否則部分動態連結程式庫與 Lua 解譯系統將無法正常運作. 而且其 usrset.txt 設定檔案固定存入\xa0C:\\users\\%USERNAME%\\AppData\\Roaming\\CoppeliaSim 目錄, 因此使用者必須在啟動可攜系統時, 將先前對於 Python 解譯或其他設定從隨身碟中, 利用 XCOPY 指令存入指定位置, 否則每次都必須重新設定. \n AppData\\Roaming\\CoppeliaSim\\ usrset.txt 內容有關 Python 解譯器所在目錄設定： \n defaultPython = y:/python310/python.exe  \n 在啟動批次檔案的 XCOPY 指令:\xa0 \n REM for coppeliasim\nXcopy %Disk%:\\home_ipv6\\AppData\\Roaming\\CoppeliaSim C:\\users\\%USERNAME%\\AppData\\Roaming\\CoppeliaSim /E /H /C /I /Y \n 若希望以批次檔案啟動 CoppeliaSim, 將下列指令存入 y:\\copsim.bat: \n @echo off\ncd y:\\coppeliasim\ncoppeliasim.exe \n 可攜系統啟動後, 可以在命令列視窗中輸入 copsim 啟動 CoppeliaSim, 或將指令整合進可攜的啟動檔案. \n 滿足上述條件後, 請利用以下範例進行測試: \n 彈珠檯發射器:\xa0 Plunger ( Shooter ) (發射器) -\xa0 pinball_plunger.ttt \n \n 接下來要將上述發射器改為 ZMQ Remote API Python 程式.', 'tags': '', 'url': 'Copsim_EX.html'}, {'title': 'ZMQ', 'text': 'https://learning-0mq-with-pyzmq.readthedocs.io/en/latest/index.html \n ØMQ is a neat messaging library that allows you to build your own messaging infrastructure. ØMQ does not provide out of box messaging system experience like ActiveMQ or RabbitMQ. It is higher level concept than sockets and provides as low level conceptual framework as possible to build messaging systems. It can help build framework that scales where services could be handled by different applications that does one job well. \n Distributed applications are also easier to change compared to a monolithic applications. It’s expensive to try to define the behavior of each of many software applications that work together in a large network. It’s much cheaper, and more flexible, to define the interfaces between them: the APIs. Messaging is an API that can be stretched across a network. ØMQ 是一個精簡的訊息傳遞程式庫 (messaging library)，允許使用者自行建立訊息傳遞基礎架構。ØMQ 不像 ActiveMQ 或 RabbitMQ 那樣提供開箱即用的訊息系統體驗。ØMQ 是比封包更高層級的概念，同時提供了儘可能低階的概念框架來構建訊息傳遞系統。它能夠幫助構建可擴展的框架 (framework)，使得這個框架中，不同的服務可以由專注於單一任務的獨立應用程式來處理。 \n 與單一應用程式相比，分散式應用程式更容易更改。嘗試定義在大型網路中協同工作的眾多軟體應用程式的行為，其成本很高; 定義它們之間的介面（API）要便宜得多，也更靈活。使得訊息傳遞是一種可以跨網路擴展的 API。 \n 使用 pyzmq 建立程式範例: \n server: \n import zmq\nimport time\n\ncontext = zmq.Context()\nsocket = context.socket(zmq.REP)\nsocket.bind("tcp://*:5555")\n\ndef process_request(request):\n    # 模擬處理請求\n    time.sleep(1)\n    return f"已處理請求: {request}"\n\nprint("服務器已啟動，等待請求...")\n\nwhile True:\n    message = socket.recv_string()\n    print(f"收到請求: {message}")\n    \n    response = process_request(message)\n    \n    socket.send_string(response) \n client: \n import zmq\n\ncontext = zmq.Context()\nsocket = context.socket(zmq.REQ)\nsocket.connect("tcp://localhost:5555")\n\nfor request in range(5):\n    print(f"發送請求 {request}...")\n    socket.send_string(f"請求 {request}")\n    \n    response = socket.recv_string()\n    print(f"收到回覆: {response}") \n 上列採用 pyzmq 模組的程式組合，主要展示 ZMQ 程式庫在兩個應用程式間負責傳遞訊息，其特性如下: 1. 通訊介面： 伺服器端和客戶端之間透過 ZMQ 定義了一個簡單的通訊介面。雙方不需要了解對方的內部運作，只需知道如何發送和接收訊息。 2. 跨網路的應用程式介面（API）： 使用 ZMQ 建立了一個可以跨網路運作的 API。伺服器和客戶端程式可以在不同的電腦上執行，只要能夠透過網路連線即可傳遞訊息。 3. 彈性： 使用者可以輕鬆修改伺服器的內部邏輯（例如: 變更用來處理請求的函式設計），而不需要更動客戶端的程式碼。 同樣地，使用者也可以新增更多客戶端或甚至替換現有客戶端，只要客戶端程式遵循相同的訊息傳遞格式。 4. 成本效益： 定義這個簡單的訊息傳遞介面，比起詳細規劃每個應用程式的所有可能行為要簡單得多。 5. 可擴展性： 此一模型可以輕鬆擴展到更複雜的情境 (例如:新增多個伺服器、實現負載平衡等)，而基本的訊息傳遞模式可保持不變。 \n 另外一組範例，以解二階微分方程為例： \n y\'\' + p(x)y\' + q(x)y = f(x), with boundary conditions y(a) = α and y(b) = β \n 可將問題範圍分割成多個子區間，每個工作者負責解決一個子區間。 \n 首先，建立一個任務派送器： \n # task_dispatcher.py\nimport zmq\nimport numpy as np\nimport time\n\ndef task_dispatcher():\n    try:\n        context = zmq.Context()\n        task_sender = context.socket(zmq.PUSH)\n        task_sender.bind("tcp://127.0.0.1:5557")\n        print("Task sender bound to tcp://127.0.0.1:5557")\n\n        result_receiver = context.socket(zmq.PULL)\n        result_receiver.bind("tcp://127.0.0.1:5558")\n        print("Result receiver bound to tcp://127.0.0.1:5558")\n\n        print("Task dispatcher started. Waiting for workers to connect...")\n        time.sleep(1)  # 給工作者一些時間來連接\n        \n        # 定義問題參數\n        a, b = 0, 1  # 邊界\n        alpha, beta = 0, 1  # 邊界條件\n        N = 1000  # 總點數\n        num_workers = 4  # 工作者數量\n\n        h = (b - a) / (N - 1)  # 步長\n        x = np.linspace(a, b, N)\n\n        # 定義方程係數\n        def p(x): return 1\n        def q(x): return -2\n        def f(x): return np.exp(-x)\n\n        print("Dispatching tasks...")\n        # 分配任務\n        points_per_worker = N // num_workers\n        for i in range(num_workers):\n            start = i * points_per_worker\n            end = (i + 1) * points_per_worker if i < num_workers - 1 else N\n            task = {\n                \'worker_id\': i,\n                \'start\': start,\n                \'end\': end,\n                \'x\': x[start:end].tolist(),\n                \'h\': h,\n                \'p\': [p(xi) for xi in x[start:end]],\n                \'q\': [q(xi) for xi in x[start:end]],\n                \'f\': [f(xi) for xi in x[start:end]]\n            }\n            task_sender.send_pyobj(task)\n            print(f"Task sent to worker {i}")\n\n        print("All tasks dispatched. Waiting for results...")\n\n        # 收集結果\n        results = [None] * num_workers\n        for _ in range(num_workers):\n            result = result_receiver.recv_pyobj()\n            worker_id = result[\'worker_id\']\n            results[worker_id] = result[\'y\']\n            print(f"Received result from worker {worker_id}")\n\n        # 組合結果\n        y = np.concatenate(results)\n\n        # 應用邊界條件\n        y[0] = alpha\n        y[-1] = beta\n\n        print("Solution computed. First few values:", y[:5])\n        print("Last few values:", y[-5:])\n\n    except zmq.ZMQError as e:\n        print(f"ZMQ Error occurred: {e}")\n    except Exception as e:\n        print(f"An unexpected error occurred: {e}")\n\nif __name__ == "__main__":\n    task_dispatcher() \n 接著安排負責運算的 client 端程式: \n # worker.py\nimport zmq\nimport numpy as np\n\ndef solve_segment(x, h, p, q, f):\n    n = len(x)\n    A = np.zeros((n, n))\n    b = np.zeros(n)\n\n    # 設置三對角矩陣\n    for i in range(1, n-1):\n        A[i, i-1] = 1 - h * p[i] / 2\n        A[i, i] = -2 + h**2 * q[i]\n        A[i, i+1] = 1 + h * p[i] / 2\n        b[i] = h**2 * f[i]\n\n    # 設置邊界條件（這裡使用自然邊界條件）\n    A[0, 0] = A[-1, -1] = 1\n    A[0, 1] = A[-1, -2] = -1\n\n    return np.linalg.solve(A, b)\n\ndef worker(worker_id):\n    context = zmq.Context()\n    task_receiver = context.socket(zmq.PULL)\n    task_receiver.connect("tcp://localhost:5557")\n\n    result_sender = context.socket(zmq.PUSH)\n    result_sender.connect("tcp://localhost:5558")\n\n    print(f"Worker {worker_id} started. Waiting for task...")\n\n    task = task_receiver.recv_pyobj()\n    print(f"Worker {worker_id} received task")\n\n    x = np.array(task[\'x\'])\n    h = task[\'h\']\n    p = np.array(task[\'p\'])\n    q = np.array(task[\'q\'])\n    f = np.array(task[\'f\'])\n\n    y = solve_segment(x, h, p, q, f)\n\n    result = {\n        \'worker_id\': worker_id,\n        \'y\': y.tolist()\n    }\n    result_sender.send_pyobj(result)\n    print(f"Worker {worker_id} sent result")\n\nif __name__ == "__main__":\n    import sys\n    worker(int(sys.argv[1]) if len(sys.argv) > 1 else 0) \n 執行流程，先執行任務派送程式: \n python task_dispatcher.py \n 然後在不同的終端中運行多個工作者： \n python worker.py 0 python worker.py 1 python worker.py 2 python worker.py 3 \n 此一系統的工作原理: \n \n 任務派發器將整個問題域分割成幾個子區間。 \n 每個子區間的資料（包括 x 值、步長 h、方程式係數 p、q 和 f）被打包成一個任務，發送給工作者。 \n 每個工作者接收一個子區間的任務，使用有限差分法解決該子區間的方程。 \n 工作者將解決方案發送回任務派發器。 \n 任務派發器收集所有工作者的結果，將它們組合成完整的解，並應用邊界條件。 \n \n 這個例子展示了如何使用 pyzmq 來實現一個分散式計算系統，用於解決複雜的數值問題。它將一個大問題分解成多個小問題，利用多台機器或多個處理器並行計算，從而提高計算效率。 \n 注意：這個實現使用了自然邊界條件（Neumann邊界條件）來處理子區間的邊界。在實際應用中，可能需要根據具體問題調整邊界條件的處理方式。 \n Reference \n', 'tags': '', 'url': 'ZMQ.html'}, {'title': 'Webots', 'text': 'Stable version:  Webots_2023b.7z \n 1.  與  python_2025_lite.7z  結合使用, Webots - Tools - Preferences - Python Command 設定為 Y:\\Python310\\python.exe \n 2.  start_ipv6.bat 必須設定: \n REM for Webots\nset PYTHON_PATH=%Disk%:\\Python310\n\nREM for Webots\nset  path_webots=%Disk%:\\Webots_2023b\\msys64\\mingw64\\bin\n\nREM 在 path 納入 %path_webots%\npath=~~;%path_webots%;%path%; \n 3.  pip install opencv-python \n 配置完成後, 測試 Python 是否設定正確:  Webots_examples.zip \xa0( source ) \n vrml97specification.pdf  ( VRML 2.0 ,  VRML ) \n https://github.com/Introduction-to-Autonomous-Robots/Introduction-to-Autonomous-Robots \n Webots 原始碼:  https://github.com/cyberbotics/webots \n 官方網站:  https://cyberbotics.com/ \n https://webots.cloud/ \n https://www.cyberbotics.com/doc/guide/samples-howto?version=cyberbotics:R2023b \n https://www.cyberbotics.com/doc/guide/index.php?version=cyberbotics:R2019a \n License:  https://cyberbotics.com/doc/guide/webots-license-agreement \n https://cyberbotics.com/doc/guide/web-interface  (無法使用 Firefox 觀看) \n https://cyberbotics.com/doc/guide/web-server  ( Github ) \n https://cyberbotics.com/doc/guide/web-streaming  ( Command Line Arguments ) (無法使用 Firefox 觀看) \n webotsw --stream \n 使用 Edge 連線到 http://localhost:1234/index.html \n https://cyberbotics.com/doc/guide/interfacing-webots-to-third-party-software-with-tcp-ip \n https://felipenmartins.github.io/Robotics-Simulation-Labs/ \u3000 \n', 'tags': '', 'url': 'Webots.html'}, {'title': 'Webots_ex', 'text': 'Webots 最新版可直接從  https://github.com/cyberbotics/webots/releases  下載. \n Stable version:  Webots_2023b.7z \n 使用授權:  https://cyberbotics.com/doc/guide/webots-license-agreement \n Webots Source Code Webots is released under the terms of the Apache 2.0 license agreement. Apache 2.0 is a industry friendly, non-contaminating, permissive open source license that grants everyone the right to use a software source code, free of charge,  for any purpose, including commercial applications . \n Webots Sample Simulations \n Webots sample simulations include world files, robot and object models, robot controllers, plugins, libraries, etc. Generally, all the sample simulations source files distributed with Webots have a license header referring to the Apache 2.0 license, except for a few robot and object assets (proto files) which are distributed under the terms of the open source Webots Assets license agreement and a few sample simulations which were contributed by users under various license agreements, mostly open source ones. In any case, the license agreement is explicitly included in the corresponding files and/or folders. \n Webots 原始碼 \n Webots 是根據 Apache 2.0 授權協議發布的。Apache 2.0 是一個對產業友善、非強制衍生性的寬鬆開源授權，讓所有人都有權利免費使用軟體原始碼， 可用於任何目的，包括商業應用 。 \n Webots 範例模擬 \n Webots 範例模擬包含場景檔案、機器人和物件模型、機器人控制器、外掛程式、程式庫等。一般來說，所有隨 Webots 發布的範例模擬原始檔都有引用 Apache 2.0 授權的授權標頭，但有少數機器人和物件資產（proto 檔案）是根據開源的 Webots Assets 授權協議發布，還有一些由使用者貢獻的範例模擬則是根據各種授權協議發布，大多是開源授權。無論如何，相關授權協議都明確包含在對應的檔案和/或資料夾中。 \n \n https://github.com/cyberbotics/webots/tree/released/resources/translations  中並沒有繁體中文翻譯, 但建議使用英文版即可. \n 自行編譯 Webots 導引:  https://github.com/cyberbotics/webots/wiki \n 自行建立網際模擬伺服器導引:  https://cyberbotics.com/doc/guide/web-server \n \n 操作教學:  https://cyberbotics.com/doc/guide/tutorials \n 導入 STL 模型:  https://cyberbotics.com/doc/reference/mesh \n 使用 C 執行控制:  https://cyberbotics.com/doc/guide/using-c \n 使用 Python 執行控制:  https://cyberbotics.com/doc/guide/using-python \n \n References: \n https://felipenmartins.github.io/Robotics-Simulation-Labs/ \u3000 \n https://courses.ideate.cmu.edu/16-375/f2022/ref/text/resources/Webots.html \n https://courses.ideate.cmu.edu/16-375/f2024/text/simulations/index.html \n https://www.bx.psu.edu/~thanh/naoqi/software/webots/webots_index.html \n https://uclalemur.com/ \n https://www.cs.csubak.edu/~wli/Wei_Li_Tch/CS_456/456_LAB/Guide.pdf \xa0 \n https://www.udemy.com/course/learn-mobile-robotics-with-webots \n https://robmosys.eu/ \n https://opendr.eu/robotic-simulations-on-the-web-education-dissemination-and-competition-organization/ \n https://www.innovationplace.eu/project/open-source-3d-robot-simulator-with-web-interface-helps-industries-to-implement-digital-twin-models/2957 \n A Swiss company developed a realistic robot simulator which can be used to simulate various digital twin scenarios involving mobile robots, robotics arms, drones, autonomous vehicles, industrial processes, etc. Sensors and actuators can be modeled, such as cameras, lidars, laser range-finder, etc. Robots are controlled by intelligent programs processing sensor data with AI algorithms. The software is fully open-source, runs on the desktop and features a cloud-based 3D web interface. \n 這家瑞士公司開發了一款逼真的機器人模擬器，可用於模擬包括移動機器人、機械手臂、無人機、自動駕駛車輛、工業製程等各種數位分身的情境。此模擬器可以模擬各種感測器和致動器，例如攝影機、光達、雷射測距儀等。機器人由智慧程式控制，透過人工智慧演算法處理感測器數據。這款軟體完全開源，可在桌面電腦上執行，並提供基於雲端的 3D 網頁介面。 \n 這家中小企業開發的 Webots 軟體是一款開源且跨平台的桌面應用程式，用於模擬機器人。它提供完整的開發環境，可用於建模、程式設計和模擬機器人。該軟體專為專業用途設計，在工業、教育和研究領域被廣泛使用。自 1998 年以來，這家中小企業持續將 Webots 作為其主要產品進行維護。該軟體最初是在瑞士洛桑聯邦理工學院（EPFL）開發的。 \n Webots 可用於建立機器人原型、開發、測試和驗證人工智慧和控制演算法、教授學生機器人學等。使用者可以利用豐富的 Webots 資產庫（包含機器人、感測器、致動器、物件和材質）輕鬆設計完整的機器人模擬。軟體支援匯入現有的 CAD 模型（來自 Blender 或通用機器人描述格式 URDF）以及 OpenStreetMap 地圖。現代化的圖形使用者介面讓使用者可以編輯他們的模擬和機器人控制器，節省機器人專案開發時間。 \n 使用者可以建立各種類型的模擬，包括雙輪桌面機器人、工業機械臂、雙足機器人、多足機器人、模組化機器人、汽車、飛行無人機、水下自主載具、履帶式機器人、航太載具等。他們可以設置室內或室外的互動環境。這些數位分身模型可用於建立對應實體系統的虛擬原型，並在模擬中測試各種改進。如果模擬中測試的改進顯示出效益，就可以實作到實體系統中。數位分身原型方法提供多項優勢，包括更好的系統功能溝通、更快速且更經濟的系統改進探索，以及包含持續整合的更有效率開發工作流程。 \n Webots 的核心是基於現代圖形使用者介面（基於 Qt 函式庫）、物理引擎（基於開放動力學引擎 ODE 的分支版本）和基於 OpenGL 3.3 函式庫的 3D 渲染引擎的組合。它可在 Windows、Linux 和 macOS 上執行。Webots 模擬可匯出為影片、互動式 HTML 場景或動畫，甚至可以 3D 形式串流至網頁。機器人可以使用簡單的 API 以不同程式語言進行程式設計，如 C、C++、Python、Java、MATLAB 或 ROS，涵蓋所有基本的機器人需求。Webots 提供網頁介面（展示於 https://webots.cloud），可在雲端執行模擬、播放 3D 動畫，以及展示場景和物件。 \n 透過這家中小企業開發的工具，使用者可以： \n 1. 受惠於高品質的免費開源技術來模擬機器人系統。 \n 2. 輕鬆將模擬、3D 動畫和 3D 模型匯出至網頁，以便與同事、合作夥伴、客戶和大眾分享。 \n 3. 受惠於這家瑞士中小企業的專業知識，該企業積極支援 Webots 軟體，並為客戶提供顧問諮詢和客製化開發服務。 \n 4. 善用 Webots 使用者社群的貢獻，社群會分享機器人、感測器、致動器、物件、環境、基準測試、控制器程式等模型。 \n 5. 可以透過 https://webots.cloud/competition 輕鬆舉辦機器人挑戰賽和程式設計競賽。 \n', 'tags': '', 'url': 'Webots_ex.html'}, {'title': 'SolidWorks', 'text': '下載  SolidWorks_2023.7z  (學校所提供的教育版 SolidWorks 2023 SP2.1) \n 安裝過程: \n 確定電腦在安裝其他套件或更新時, 已經重新啟動電腦, 否則請在安裝前重新啟動電腦. \n 另外若安裝時電腦並非位於校網中, 請透過 VPN 連線進入校區網段, 使用 VPN 連網細節請參考"VPN_校外網路取得校內IP服務.docx" 中的說明. \n 以下安裝資訊僅適用於校網中, 在其他網段無法使用, 安裝完成後電腦必須位於校網或以 VPN 登入校網, 否則無法使用. \n 解開上列壓縮檔案後, 執行 setup.exe 進行安裝, 畫面如下: \n \n 選擇安裝在此電腦上, 接著下一步: \n 安裝序號有 24 碼, 可從" SOLIDWORKS2023安裝序號及IP＿README_utf8.txt " 檔案中取得, 複製序號後貼上即可. \n \n 接著下一步, 安裝程式將會連線至 SolidWorks, 之後選擇不要安裝更新版本: \n \n 接下來選擇接受 SolidWorks 的條款, 若全部安裝需要 21 GB: \n \n \n 其中: \n 繁體中文佔 327MB \n Flow Simulation 佔 1.3GB \n Plastics 佔 1.7GB \n Composer 佔 1.6GB \n CAM 佔 2.3GB \n Visualize 佔 3.9GB \n Electrical 佔 733MB \n 3D Experience Marketplace 佔 2MB \n 3D Experience Exchange for SolidWorks 佔 2MB \n Simulation 佔 350MB \n Motion 佔 5MB \n 若上述延伸套件都選擇不安裝, 則需要 8.6GB: \n \n 確定安裝內容後, 選擇馬上安裝: \n \n 按下確定後開始進行下載安裝. \n \n 安裝完成前, 選擇是否參加客戶經驗改進計畫: \n \n 選擇完成, 並且重新啟動電腦: \n \n 重新啟動電腦後, 利用桌面上的"SOLIDWORKS 2023" 開啟, 出現下列畫面, 選擇 Accept (若只安裝英文版介面) 後開始執行: \n \n 上列流程選擇安裝英文版介面, 且僅安裝 SolidWorks 2023 本體以及 eDrawings, 實際配置於 ::6 電腦上. \n \n \n \n \n \n \n \n \n \n \n \n', 'tags': '', 'url': 'SolidWorks.html'}, {'title': 'Python', 'text': '以 Python 為主的可攜程式環境架構: \n https://github.com/mdecycu/python_2025 \n 2024 Fall 開始採用的 python_2025.7z (5.2GB), 包含下列模組: \n 與 NX2406 配合的  Python310_pip_only.7z  (3.10.11 版) \n Python310_jupyter_notebook.7z \n Python310_jupyter_lab_collaborative.7z \n python_2025_batch_files.7z  (2.64KB) \n 下載 \xa0NX2406 可攜 CAD 壓縮檔案 (1.76 GB, 解開後約 9 GB) \n CoppeliaSim_Edu_4.7.0_rev4_for_2024Fall.7z  (190MB) \n homes_and_tmp.7z  (84MB) \n msys64_20240507.7z  (188MB) \n git_putty_python.7z  (559MB) \n sharex_wscite_wink3.7z  (44.2MB) \n solvespace_and_utilities.7z  (7.28MB) \n kmolab_ex.7z  (314MB) \n \n Python 3.12 版已經移除 distutils, 表示先前利用 MSYS2 編譯模組的 設定 , 已經不再適用: \n The entire  distutils  package is deprecated, to be removed in Python 3.12. Its functionality for specifying package builds has already been completely replaced by third-party packages  setuptools  and  packaging , and most other commonly used APIs are available elsewhere in the standard library (such as  platform ,  shutil ,  subprocess  or  sysconfig ). There are no plans to migrate any other functionality from  distutils , and applications that are using other functions should plan to make private copies of the code. Refer to  PEP 632  for discussion. \n The  bdist_wininst  command deprecated in Python 3.8 has been removed. The  bdist_wheel  command is now recommended to distribute binary packages on Windows. (Contributed by Victor Stinner in  bpo-42802 .) \n 若希望在 Windows 環境中利用 Visual Studio C++ 編譯 Python 模組, 可以下載\xa0  https://visualstudio.microsoft.com/zh-hant/visual-cpp-build-tools/  安裝後, 重新開機即可. \n 若要將 visual-cpp-build-tools 配置為可攜套件模組, 則可透過  https://github.com/Data-Oriented-House/PortableBuildTools  完成. \n nxopen_base_and_center_pole_python.txt \n split_pdf.py \n # pypdf2_split.py\n# pip install pypdf2 pycryptodome\nimport os\nfrom PyPDF2 import PdfWriter, PdfReader\n \npdfReader = PdfReader(open("parm.pdf", "rb"))\ninformation = [("151.pdf",1,300)]\n  \nfor page in range(len(information)):\n    pdf_writer = PdfWriter()\n    start = information[page][1]\n    end = information[page][2]\n    while start<=end:\n        pdf_writer.add_page(pdfReader.pages[start-1])\n        start+=1\n    if not os.path.exists("./"):\n        os.makedirs(savepath)\n    output_filename = \'{}_{}_page_{}.pdf\'.format(information[page][0],information[page][1], information[page][2])\n    with open(output_filename,\'wb\') as out:\n        pdf_writer.write(out)\nprint("已經完成 pdf 切割與存檔") \n combine_pdf.py \n # pip install pypdf2 pycryptodome\nimport os\nfrom PyPDF2 import PdfWriter, PdfReader\n \npdf_write_object = PdfWriter()\n \npdfFileNames = ["1.pdf", "2.pdf", "3.pdf"]\nnewFileName = "Programming_Process_in_NX_CAM_en"\nfilenameString = ""\n \nfor filename in pdfFileNames:\n    pdf_read_object = PdfReader(open(filename, "rb"))\n    filenameString += filename + ", "\n    for page in range(len(pdf_read_object.pages)):\n        pdf_write_object.add_page(pdf_read_object.pages[page])\n  \nfinal_file_object = open(newFileName + ".pdf", \'wb\')\npdf_write_object.write(final_file_object)\nfinal_file_object.close()\n \nprint("已經將 " + filenameString+ " 合併為: "+ newFileName + ".pdf") \n gen_python_3.10.11.py for NX2312 \n import urllib.request\nimport os\n   \ndir_path = os.path.dirname(os.path.realpath(__file__))\n# basic files for Python installation\n# before 3.12.0\npy_list = ["core", "dev", "exe", "lib", "tcltk", "tools"]\n# 3.12.1 no tools.msi\n#py_list = ["core", "dev", "exe", "lib", "tcltk"]\n# Python version 3.10.11 for NX2312\nversion = "3.10.11"\n# Python msi download URL\nftp = "https://www.python.org/ftp/python/" + version + "/amd64/"\n# location for Portable Python\npath = "y:\\\\tmp\\\\Python310"\n# create directory\ntry:\n    os.mkdir(path)\nexcept:\n    # path exists\n    pass\n# get Python installation msi files and extract into target dir\nfor i in py_list:\n    filename = i + ".msi"\n    url = ftp + filename\n    # download basic python msi file\n    urllib.request.urlretrieve(url, filename)\n    os.system("msiexec.exe /a " + i + ".msi targetdir=" + path)\n    # delete msi file\n    os.remove(dir_path + "\\\\" + i + ".msi")\n    os.remove(path + "\\\\" + i + ".msi")\n \n', 'tags': '', 'url': 'Python.html'}, {'title': 'Python_ex', 'text': '利用 Python 指定使用 mm 尺寸單位, 建立新零件檔案: \n file_new_model_py.txt \n # NX 2312 Journal\n\nimport math\nimport NXOpen\nimport os\nimport NXOpen.UF\n\nFileName = "Y:\\\\tmp\\\\nx_ex\\\\model1.prt"\n\n# --------------------------------------------------------------------------------------------\ncurrent_directory = os.path.dirname(os.path.realpath(__file__))\ntheUfSession = NXOpen.UF.UFSession.GetUFSession()\ntheUfSession.Part.CloseAll() \n# --------------------------------------------------------------------------------------------\n    \ndef main() : \n\n    theSession  = NXOpen.Session.GetSession() \n    fileNew1 = theSession.Parts.FileNew()\n    fileNew1.TemplateFileName = "model-plain-1-mm-template.prt"\n    fileNew1.Units = NXOpen.Part.Units.Millimeters\n    fileNew1.TemplatePresentationName = "Model"\n    fileNew1.NewFileName = FileName\n    nXObject1 = fileNew1.Commit()\n    workPart = theSession.Parts.Work\n    displayPart = theSession.Parts.Display\n    fileNew1.Destroy()\n    \nif __name__ == \'__main__\':\n    main() \n 利用 Python 建立 Block: \n new_model_sketch_extrude_save_py.txt \n 參數化之後的  block_nx2312_py.txt \n Examples:  https://github.com/mdecycu/nxopen \n', 'tags': '', 'url': 'Python_ex.html'}, {'title': 'Brython', 'text': '從 1 累加到 100: \n 1 add to 100 \n  導入 brython 程式庫  \n \n \n \n \n  啟動 Brython  \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n \n \n \n  add 1 to 100 開始  \n \n \n  add 1 to 100 結束 \n  editor1 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor1 結束   ##########################################  \n 從 1 累加到 100 part2: \n 1 add to 100 cango_three_gears BSnake AI Tetris Rotating Block \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  add 1 to 100 part2 開始  \n \n \n  add 1 to 100 part2 結束 \n  editor2 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor2 結束  \n \n \n', 'tags': '', 'url': 'Brython.html'}]};